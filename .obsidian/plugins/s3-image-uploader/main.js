/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb2, mod) => function __require() {
  return mod || (0, cb2[__getOwnPropNames(cb2)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};

// node_modules/fast-xml-parser/src/util.js
var require_util = __commonJS({
  "node_modules/fast-xml-parser/src/util.js"(exports) {
    "use strict";
    var nameStartChar = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
    var nameChar = nameStartChar + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
    var nameRegexp = "[" + nameStartChar + "][" + nameChar + "]*";
    var regexName = new RegExp("^" + nameRegexp + "$");
    var getAllMatches = function(string, regex) {
      const matches = [];
      let match2 = regex.exec(string);
      while (match2) {
        const allmatches = [];
        allmatches.startIndex = regex.lastIndex - match2[0].length;
        const len = match2.length;
        for (let index = 0; index < len; index++) {
          allmatches.push(match2[index]);
        }
        matches.push(allmatches);
        match2 = regex.exec(string);
      }
      return matches;
    };
    var isName = function(string) {
      const match2 = regexName.exec(string);
      return !(match2 === null || typeof match2 === "undefined");
    };
    exports.isExist = function(v2) {
      return typeof v2 !== "undefined";
    };
    exports.isEmptyObject = function(obj) {
      return Object.keys(obj).length === 0;
    };
    exports.merge = function(target, a3, arrayMode) {
      if (a3) {
        const keys = Object.keys(a3);
        const len = keys.length;
        for (let i3 = 0; i3 < len; i3++) {
          if (arrayMode === "strict") {
            target[keys[i3]] = [a3[keys[i3]]];
          } else {
            target[keys[i3]] = a3[keys[i3]];
          }
        }
      }
    };
    exports.getValue = function(v2) {
      if (exports.isExist(v2)) {
        return v2;
      } else {
        return "";
      }
    };
    exports.isName = isName;
    exports.getAllMatches = getAllMatches;
    exports.nameRegexp = nameRegexp;
  }
});

// node_modules/fast-xml-parser/src/validator.js
var require_validator = __commonJS({
  "node_modules/fast-xml-parser/src/validator.js"(exports) {
    "use strict";
    var util = require_util();
    var defaultOptions = {
      allowBooleanAttributes: false,
      unpairedTags: []
    };
    exports.validate = function(xmlData, options) {
      options = Object.assign({}, defaultOptions, options);
      const tags = [];
      let tagFound = false;
      let reachedRoot = false;
      if (xmlData[0] === "\uFEFF") {
        xmlData = xmlData.substr(1);
      }
      for (let i3 = 0; i3 < xmlData.length; i3++) {
        if (xmlData[i3] === "<" && xmlData[i3 + 1] === "?") {
          i3 += 2;
          i3 = readPI(xmlData, i3);
          if (i3.err)
            return i3;
        } else if (xmlData[i3] === "<") {
          let tagStartPos = i3;
          i3++;
          if (xmlData[i3] === "!") {
            i3 = readCommentAndCDATA(xmlData, i3);
            continue;
          } else {
            let closingTag = false;
            if (xmlData[i3] === "/") {
              closingTag = true;
              i3++;
            }
            let tagName = "";
            for (; i3 < xmlData.length && xmlData[i3] !== ">" && xmlData[i3] !== " " && xmlData[i3] !== "	" && xmlData[i3] !== "\n" && xmlData[i3] !== "\r"; i3++) {
              tagName += xmlData[i3];
            }
            tagName = tagName.trim();
            if (tagName[tagName.length - 1] === "/") {
              tagName = tagName.substring(0, tagName.length - 1);
              i3--;
            }
            if (!validateTagName(tagName)) {
              let msg;
              if (tagName.trim().length === 0) {
                msg = "Invalid space after '<'.";
              } else {
                msg = "Tag '" + tagName + "' is an invalid name.";
              }
              return getErrorObject("InvalidTag", msg, getLineNumberForPosition(xmlData, i3));
            }
            const result = readAttributeStr(xmlData, i3);
            if (result === false) {
              return getErrorObject("InvalidAttr", "Attributes for '" + tagName + "' have open quote.", getLineNumberForPosition(xmlData, i3));
            }
            let attrStr = result.value;
            i3 = result.index;
            if (attrStr[attrStr.length - 1] === "/") {
              const attrStrStart = i3 - attrStr.length;
              attrStr = attrStr.substring(0, attrStr.length - 1);
              const isValid = validateAttributeString(attrStr, options);
              if (isValid === true) {
                tagFound = true;
              } else {
                return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));
              }
            } else if (closingTag) {
              if (!result.tagClosed) {
                return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' doesn't have proper closing.", getLineNumberForPosition(xmlData, i3));
              } else if (attrStr.trim().length > 0) {
                return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' can't have attributes or invalid starting.", getLineNumberForPosition(xmlData, tagStartPos));
              } else {
                const otg = tags.pop();
                if (tagName !== otg.tagName) {
                  let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);
                  return getErrorObject("InvalidTag", "Expected closing tag '" + otg.tagName + "' (opened in line " + openPos.line + ", col " + openPos.col + ") instead of closing tag '" + tagName + "'.", getLineNumberForPosition(xmlData, tagStartPos));
                }
                if (tags.length == 0) {
                  reachedRoot = true;
                }
              }
            } else {
              const isValid = validateAttributeString(attrStr, options);
              if (isValid !== true) {
                return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i3 - attrStr.length + isValid.err.line));
              }
              if (reachedRoot === true) {
                return getErrorObject("InvalidXml", "Multiple possible root nodes found.", getLineNumberForPosition(xmlData, i3));
              } else if (options.unpairedTags.indexOf(tagName) !== -1) {
              } else {
                tags.push({ tagName, tagStartPos });
              }
              tagFound = true;
            }
            for (i3++; i3 < xmlData.length; i3++) {
              if (xmlData[i3] === "<") {
                if (xmlData[i3 + 1] === "!") {
                  i3++;
                  i3 = readCommentAndCDATA(xmlData, i3);
                  continue;
                } else if (xmlData[i3 + 1] === "?") {
                  i3 = readPI(xmlData, ++i3);
                  if (i3.err)
                    return i3;
                } else {
                  break;
                }
              } else if (xmlData[i3] === "&") {
                const afterAmp = validateAmpersand(xmlData, i3);
                if (afterAmp == -1)
                  return getErrorObject("InvalidChar", "char '&' is not expected.", getLineNumberForPosition(xmlData, i3));
                i3 = afterAmp;
              } else {
                if (reachedRoot === true && !isWhiteSpace(xmlData[i3])) {
                  return getErrorObject("InvalidXml", "Extra text at the end", getLineNumberForPosition(xmlData, i3));
                }
              }
            }
            if (xmlData[i3] === "<") {
              i3--;
            }
          }
        } else {
          if (isWhiteSpace(xmlData[i3])) {
            continue;
          }
          return getErrorObject("InvalidChar", "char '" + xmlData[i3] + "' is not expected.", getLineNumberForPosition(xmlData, i3));
        }
      }
      if (!tagFound) {
        return getErrorObject("InvalidXml", "Start tag expected.", 1);
      } else if (tags.length == 1) {
        return getErrorObject("InvalidTag", "Unclosed tag '" + tags[0].tagName + "'.", getLineNumberForPosition(xmlData, tags[0].tagStartPos));
      } else if (tags.length > 0) {
        return getErrorObject("InvalidXml", "Invalid '" + JSON.stringify(tags.map((t3) => t3.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", { line: 1, col: 1 });
      }
      return true;
    };
    function isWhiteSpace(char) {
      return char === " " || char === "	" || char === "\n" || char === "\r";
    }
    function readPI(xmlData, i3) {
      const start = i3;
      for (; i3 < xmlData.length; i3++) {
        if (xmlData[i3] == "?" || xmlData[i3] == " ") {
          const tagname = xmlData.substr(start, i3 - start);
          if (i3 > 5 && tagname === "xml") {
            return getErrorObject("InvalidXml", "XML declaration allowed only at the start of the document.", getLineNumberForPosition(xmlData, i3));
          } else if (xmlData[i3] == "?" && xmlData[i3 + 1] == ">") {
            i3++;
            break;
          } else {
            continue;
          }
        }
      }
      return i3;
    }
    function readCommentAndCDATA(xmlData, i3) {
      if (xmlData.length > i3 + 5 && xmlData[i3 + 1] === "-" && xmlData[i3 + 2] === "-") {
        for (i3 += 3; i3 < xmlData.length; i3++) {
          if (xmlData[i3] === "-" && xmlData[i3 + 1] === "-" && xmlData[i3 + 2] === ">") {
            i3 += 2;
            break;
          }
        }
      } else if (xmlData.length > i3 + 8 && xmlData[i3 + 1] === "D" && xmlData[i3 + 2] === "O" && xmlData[i3 + 3] === "C" && xmlData[i3 + 4] === "T" && xmlData[i3 + 5] === "Y" && xmlData[i3 + 6] === "P" && xmlData[i3 + 7] === "E") {
        let angleBracketsCount = 1;
        for (i3 += 8; i3 < xmlData.length; i3++) {
          if (xmlData[i3] === "<") {
            angleBracketsCount++;
          } else if (xmlData[i3] === ">") {
            angleBracketsCount--;
            if (angleBracketsCount === 0) {
              break;
            }
          }
        }
      } else if (xmlData.length > i3 + 9 && xmlData[i3 + 1] === "[" && xmlData[i3 + 2] === "C" && xmlData[i3 + 3] === "D" && xmlData[i3 + 4] === "A" && xmlData[i3 + 5] === "T" && xmlData[i3 + 6] === "A" && xmlData[i3 + 7] === "[") {
        for (i3 += 8; i3 < xmlData.length; i3++) {
          if (xmlData[i3] === "]" && xmlData[i3 + 1] === "]" && xmlData[i3 + 2] === ">") {
            i3 += 2;
            break;
          }
        }
      }
      return i3;
    }
    var doubleQuote = '"';
    var singleQuote = "'";
    function readAttributeStr(xmlData, i3) {
      let attrStr = "";
      let startChar = "";
      let tagClosed = false;
      for (; i3 < xmlData.length; i3++) {
        if (xmlData[i3] === doubleQuote || xmlData[i3] === singleQuote) {
          if (startChar === "") {
            startChar = xmlData[i3];
          } else if (startChar !== xmlData[i3]) {
          } else {
            startChar = "";
          }
        } else if (xmlData[i3] === ">") {
          if (startChar === "") {
            tagClosed = true;
            break;
          }
        }
        attrStr += xmlData[i3];
      }
      if (startChar !== "") {
        return false;
      }
      return {
        value: attrStr,
        index: i3,
        tagClosed
      };
    }
    var validAttrStrRegxp = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`, "g");
    function validateAttributeString(attrStr, options) {
      const matches = util.getAllMatches(attrStr, validAttrStrRegxp);
      const attrNames = {};
      for (let i3 = 0; i3 < matches.length; i3++) {
        if (matches[i3][1].length === 0) {
          return getErrorObject("InvalidAttr", "Attribute '" + matches[i3][2] + "' has no space in starting.", getPositionFromMatch(matches[i3]));
        } else if (matches[i3][3] !== void 0 && matches[i3][4] === void 0) {
          return getErrorObject("InvalidAttr", "Attribute '" + matches[i3][2] + "' is without value.", getPositionFromMatch(matches[i3]));
        } else if (matches[i3][3] === void 0 && !options.allowBooleanAttributes) {
          return getErrorObject("InvalidAttr", "boolean attribute '" + matches[i3][2] + "' is not allowed.", getPositionFromMatch(matches[i3]));
        }
        const attrName = matches[i3][2];
        if (!validateAttrName(attrName)) {
          return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is an invalid name.", getPositionFromMatch(matches[i3]));
        }
        if (!attrNames.hasOwnProperty(attrName)) {
          attrNames[attrName] = 1;
        } else {
          return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is repeated.", getPositionFromMatch(matches[i3]));
        }
      }
      return true;
    }
    function validateNumberAmpersand(xmlData, i3) {
      let re = /\d/;
      if (xmlData[i3] === "x") {
        i3++;
        re = /[\da-fA-F]/;
      }
      for (; i3 < xmlData.length; i3++) {
        if (xmlData[i3] === ";")
          return i3;
        if (!xmlData[i3].match(re))
          break;
      }
      return -1;
    }
    function validateAmpersand(xmlData, i3) {
      i3++;
      if (xmlData[i3] === ";")
        return -1;
      if (xmlData[i3] === "#") {
        i3++;
        return validateNumberAmpersand(xmlData, i3);
      }
      let count = 0;
      for (; i3 < xmlData.length; i3++, count++) {
        if (xmlData[i3].match(/\w/) && count < 20)
          continue;
        if (xmlData[i3] === ";")
          break;
        return -1;
      }
      return i3;
    }
    function getErrorObject(code, message, lineNumber) {
      return {
        err: {
          code,
          msg: message,
          line: lineNumber.line || lineNumber,
          col: lineNumber.col
        }
      };
    }
    function validateAttrName(attrName) {
      return util.isName(attrName);
    }
    function validateTagName(tagname) {
      return util.isName(tagname);
    }
    function getLineNumberForPosition(xmlData, index) {
      const lines = xmlData.substring(0, index).split(/\r?\n/);
      return {
        line: lines.length,
        col: lines[lines.length - 1].length + 1
      };
    }
    function getPositionFromMatch(match2) {
      return match2.startIndex + match2[1].length;
    }
  }
});

// node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js
var require_OptionsBuilder = __commonJS({
  "node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js"(exports) {
    var defaultOptions = {
      preserveOrder: false,
      attributeNamePrefix: "@_",
      attributesGroupName: false,
      textNodeName: "#text",
      ignoreAttributes: true,
      removeNSPrefix: false,
      allowBooleanAttributes: false,
      parseTagValue: true,
      parseAttributeValue: false,
      trimValues: true,
      cdataPropName: false,
      numberParseOptions: {
        hex: true,
        leadingZeros: true,
        eNotation: true
      },
      tagValueProcessor: function(tagName, val) {
        return val;
      },
      attributeValueProcessor: function(attrName, val) {
        return val;
      },
      stopNodes: [],
      alwaysCreateTextNode: false,
      isArray: () => false,
      commentPropName: false,
      unpairedTags: [],
      processEntities: true,
      htmlEntities: false,
      ignoreDeclaration: false,
      ignorePiTags: false,
      transformTagName: false,
      transformAttributeName: false
    };
    var buildOptions = function(options) {
      return Object.assign({}, defaultOptions, options);
    };
    exports.buildOptions = buildOptions;
    exports.defaultOptions = defaultOptions;
  }
});

// node_modules/fast-xml-parser/src/xmlparser/xmlNode.js
var require_xmlNode = __commonJS({
  "node_modules/fast-xml-parser/src/xmlparser/xmlNode.js"(exports, module2) {
    "use strict";
    var XmlNode2 = class {
      constructor(tagname) {
        this.tagname = tagname;
        this.child = [];
        this[":@"] = {};
      }
      add(key, val) {
        if (key === "__proto__")
          key = "#__proto__";
        this.child.push({ [key]: val });
      }
      addChild(node) {
        if (node.tagname === "__proto__")
          node.tagname = "#__proto__";
        if (node[":@"] && Object.keys(node[":@"]).length > 0) {
          this.child.push({ [node.tagname]: node.child, [":@"]: node[":@"] });
        } else {
          this.child.push({ [node.tagname]: node.child });
        }
      }
    };
    module2.exports = XmlNode2;
  }
});

// node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js
var require_DocTypeReader = __commonJS({
  "node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js"(exports, module2) {
    function readDocType(xmlData, i3) {
      const entities = {};
      if (xmlData[i3 + 3] === "O" && xmlData[i3 + 4] === "C" && xmlData[i3 + 5] === "T" && xmlData[i3 + 6] === "Y" && xmlData[i3 + 7] === "P" && xmlData[i3 + 8] === "E") {
        i3 = i3 + 9;
        let angleBracketsCount = 1;
        let hasBody = false, entity = false, comment = false;
        let exp = "";
        for (; i3 < xmlData.length; i3++) {
          if (xmlData[i3] === "<" && !comment) {
            if (hasBody && xmlData[i3 + 1] === "!" && xmlData[i3 + 2] === "E" && xmlData[i3 + 3] === "N" && xmlData[i3 + 4] === "T" && xmlData[i3 + 5] === "I" && xmlData[i3 + 6] === "T" && xmlData[i3 + 7] === "Y") {
              i3 += 7;
              entity = true;
            } else if (hasBody && xmlData[i3 + 1] === "!" && xmlData[i3 + 2] === "E" && xmlData[i3 + 3] === "L" && xmlData[i3 + 4] === "E" && xmlData[i3 + 5] === "M" && xmlData[i3 + 6] === "E" && xmlData[i3 + 7] === "N" && xmlData[i3 + 8] === "T") {
              i3 += 8;
            } else if (hasBody && xmlData[i3 + 1] === "!" && xmlData[i3 + 2] === "A" && xmlData[i3 + 3] === "T" && xmlData[i3 + 4] === "T" && xmlData[i3 + 5] === "L" && xmlData[i3 + 6] === "I" && xmlData[i3 + 7] === "S" && xmlData[i3 + 8] === "T") {
              i3 += 8;
            } else if (hasBody && xmlData[i3 + 1] === "!" && xmlData[i3 + 2] === "N" && xmlData[i3 + 3] === "O" && xmlData[i3 + 4] === "T" && xmlData[i3 + 5] === "A" && xmlData[i3 + 6] === "T" && xmlData[i3 + 7] === "I" && xmlData[i3 + 8] === "O" && xmlData[i3 + 9] === "N") {
              i3 += 9;
            } else if (xmlData[i3 + 1] === "!" && xmlData[i3 + 2] === "-" && xmlData[i3 + 3] === "-") {
              comment = true;
            } else {
              throw new Error("Invalid DOCTYPE");
            }
            angleBracketsCount++;
            exp = "";
          } else if (xmlData[i3] === ">") {
            if (comment) {
              if (xmlData[i3 - 1] === "-" && xmlData[i3 - 2] === "-") {
                comment = false;
                angleBracketsCount--;
              }
            } else {
              if (entity) {
                parseEntityExp(exp, entities);
                entity = false;
              }
              angleBracketsCount--;
            }
            if (angleBracketsCount === 0) {
              break;
            }
          } else if (xmlData[i3] === "[") {
            hasBody = true;
          } else {
            exp += xmlData[i3];
          }
        }
        if (angleBracketsCount !== 0) {
          throw new Error(`Unclosed DOCTYPE`);
        }
      } else {
        throw new Error(`Invalid Tag instead of DOCTYPE`);
      }
      return { entities, i: i3 };
    }
    var entityRegex = RegExp(`^\\s([a-zA-z0-0]+)[ 	](['"])([^&]+)\\2`);
    function parseEntityExp(exp, entities) {
      const match2 = entityRegex.exec(exp);
      if (match2) {
        entities[match2[1]] = {
          regx: RegExp(`&${match2[1]};`, "g"),
          val: match2[3]
        };
      }
    }
    module2.exports = readDocType;
  }
});

// node_modules/strnum/strnum.js
var require_strnum = __commonJS({
  "node_modules/strnum/strnum.js"(exports, module2) {
    var hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;
    var numRegex = /^([\-\+])?(0*)(\.[0-9]+([eE]\-?[0-9]+)?|[0-9]+(\.[0-9]+([eE]\-?[0-9]+)?)?)$/;
    if (!Number.parseInt && window.parseInt) {
      Number.parseInt = window.parseInt;
    }
    if (!Number.parseFloat && window.parseFloat) {
      Number.parseFloat = window.parseFloat;
    }
    var consider = {
      hex: true,
      leadingZeros: true,
      decimalPoint: ".",
      eNotation: true
    };
    function toNumber(str, options = {}) {
      options = Object.assign({}, consider, options);
      if (!str || typeof str !== "string")
        return str;
      let trimmedStr = str.trim();
      if (options.skipLike !== void 0 && options.skipLike.test(trimmedStr))
        return str;
      else if (options.hex && hexRegex.test(trimmedStr)) {
        return Number.parseInt(trimmedStr, 16);
      } else {
        const match2 = numRegex.exec(trimmedStr);
        if (match2) {
          const sign = match2[1];
          const leadingZeros = match2[2];
          let numTrimmedByZeros = trimZeros(match2[3]);
          const eNotation = match2[4] || match2[6];
          if (!options.leadingZeros && leadingZeros.length > 0 && sign && trimmedStr[2] !== ".")
            return str;
          else if (!options.leadingZeros && leadingZeros.length > 0 && !sign && trimmedStr[1] !== ".")
            return str;
          else {
            const num = Number(trimmedStr);
            const numStr = "" + num;
            if (numStr.search(/[eE]/) !== -1) {
              if (options.eNotation)
                return num;
              else
                return str;
            } else if (eNotation) {
              if (options.eNotation)
                return num;
              else
                return str;
            } else if (trimmedStr.indexOf(".") !== -1) {
              if (numStr === "0" && numTrimmedByZeros === "")
                return num;
              else if (numStr === numTrimmedByZeros)
                return num;
              else if (sign && numStr === "-" + numTrimmedByZeros)
                return num;
              else
                return str;
            }
            if (leadingZeros) {
              if (numTrimmedByZeros === numStr)
                return num;
              else if (sign + numTrimmedByZeros === numStr)
                return num;
              else
                return str;
            }
            if (trimmedStr === numStr)
              return num;
            else if (trimmedStr === sign + numStr)
              return num;
            return str;
          }
        } else {
          return str;
        }
      }
    }
    function trimZeros(numStr) {
      if (numStr && numStr.indexOf(".") !== -1) {
        numStr = numStr.replace(/0+$/, "");
        if (numStr === ".")
          numStr = "0";
        else if (numStr[0] === ".")
          numStr = "0" + numStr;
        else if (numStr[numStr.length - 1] === ".")
          numStr = numStr.substr(0, numStr.length - 1);
        return numStr;
      }
      return numStr;
    }
    module2.exports = toNumber;
  }
});

// node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js
var require_OrderedObjParser = __commonJS({
  "node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js"(exports, module2) {
    "use strict";
    var util = require_util();
    var xmlNode = require_xmlNode();
    var readDocType = require_DocTypeReader();
    var toNumber = require_strnum();
    var regx = "<((!\\[CDATA\\[([\\s\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\/)(NAME)\\s*>))([^<]*)".replace(/NAME/g, util.nameRegexp);
    var OrderedObjParser = class {
      constructor(options) {
        this.options = options;
        this.currentNode = null;
        this.tagsNodeStack = [];
        this.docTypeEntities = {};
        this.lastEntities = {
          "apos": { regex: /&(apos|#39|#x27);/g, val: "'" },
          "gt": { regex: /&(gt|#62|#x3E);/g, val: ">" },
          "lt": { regex: /&(lt|#60|#x3C);/g, val: "<" },
          "quot": { regex: /&(quot|#34|#x22);/g, val: '"' }
        };
        this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" };
        this.htmlEntities = {
          "space": { regex: /&(nbsp|#160);/g, val: " " },
          "cent": { regex: /&(cent|#162);/g, val: "\xA2" },
          "pound": { regex: /&(pound|#163);/g, val: "\xA3" },
          "yen": { regex: /&(yen|#165);/g, val: "\xA5" },
          "euro": { regex: /&(euro|#8364);/g, val: "\u20AC" },
          "copyright": { regex: /&(copy|#169);/g, val: "\xA9" },
          "reg": { regex: /&(reg|#174);/g, val: "\xAE" },
          "inr": { regex: /&(inr|#8377);/g, val: "\u20B9" }
        };
        this.addExternalEntities = addExternalEntities;
        this.parseXml = parseXml;
        this.parseTextData = parseTextData;
        this.resolveNameSpace = resolveNameSpace;
        this.buildAttributesMap = buildAttributesMap;
        this.isItStopNode = isItStopNode;
        this.replaceEntitiesValue = replaceEntitiesValue;
        this.readStopNodeData = readStopNodeData;
        this.saveTextToParentTag = saveTextToParentTag;
      }
    };
    function addExternalEntities(externalEntities) {
      const entKeys = Object.keys(externalEntities);
      for (let i3 = 0; i3 < entKeys.length; i3++) {
        const ent = entKeys[i3];
        this.lastEntities[ent] = {
          regex: new RegExp("&" + ent + ";", "g"),
          val: externalEntities[ent]
        };
      }
    }
    function parseTextData(val, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {
      if (val !== void 0) {
        if (this.options.trimValues && !dontTrim) {
          val = val.trim();
        }
        if (val.length > 0) {
          if (!escapeEntities)
            val = this.replaceEntitiesValue(val);
          const newval = this.options.tagValueProcessor(tagName, val, jPath, hasAttributes, isLeafNode);
          if (newval === null || newval === void 0) {
            return val;
          } else if (typeof newval !== typeof val || newval !== val) {
            return newval;
          } else if (this.options.trimValues) {
            return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);
          } else {
            const trimmedVal = val.trim();
            if (trimmedVal === val) {
              return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);
            } else {
              return val;
            }
          }
        }
      }
    }
    function resolveNameSpace(tagname) {
      if (this.options.removeNSPrefix) {
        const tags = tagname.split(":");
        const prefix = tagname.charAt(0) === "/" ? "/" : "";
        if (tags[0] === "xmlns") {
          return "";
        }
        if (tags.length === 2) {
          tagname = prefix + tags[1];
        }
      }
      return tagname;
    }
    var attrsRegx = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
    function buildAttributesMap(attrStr, jPath) {
      if (!this.options.ignoreAttributes && typeof attrStr === "string") {
        const matches = util.getAllMatches(attrStr, attrsRegx);
        const len = matches.length;
        const attrs = {};
        for (let i3 = 0; i3 < len; i3++) {
          const attrName = this.resolveNameSpace(matches[i3][1]);
          let oldVal = matches[i3][4];
          let aName = this.options.attributeNamePrefix + attrName;
          if (attrName.length) {
            if (this.options.transformAttributeName) {
              aName = this.options.transformAttributeName(aName);
            }
            if (aName === "__proto__")
              aName = "#__proto__";
            if (oldVal !== void 0) {
              if (this.options.trimValues) {
                oldVal = oldVal.trim();
              }
              oldVal = this.replaceEntitiesValue(oldVal);
              const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);
              if (newVal === null || newVal === void 0) {
                attrs[aName] = oldVal;
              } else if (typeof newVal !== typeof oldVal || newVal !== oldVal) {
                attrs[aName] = newVal;
              } else {
                attrs[aName] = parseValue(oldVal, this.options.parseAttributeValue, this.options.numberParseOptions);
              }
            } else if (this.options.allowBooleanAttributes) {
              attrs[aName] = true;
            }
          }
        }
        if (!Object.keys(attrs).length) {
          return;
        }
        if (this.options.attributesGroupName) {
          const attrCollection = {};
          attrCollection[this.options.attributesGroupName] = attrs;
          return attrCollection;
        }
        return attrs;
      }
    }
    var parseXml = function(xmlData) {
      xmlData = xmlData.replace(/\r\n?/g, "\n");
      const xmlObj = new xmlNode("!xml");
      let currentNode = xmlObj;
      let textData = "";
      let jPath = "";
      for (let i3 = 0; i3 < xmlData.length; i3++) {
        const ch2 = xmlData[i3];
        if (ch2 === "<") {
          if (xmlData[i3 + 1] === "/") {
            const closeIndex = findClosingIndex(xmlData, ">", i3, "Closing Tag is not closed.");
            let tagName = xmlData.substring(i3 + 2, closeIndex).trim();
            if (this.options.removeNSPrefix) {
              const colonIndex = tagName.indexOf(":");
              if (colonIndex !== -1) {
                tagName = tagName.substr(colonIndex + 1);
              }
            }
            if (this.options.transformTagName) {
              tagName = this.options.transformTagName(tagName);
            }
            if (currentNode) {
              textData = this.saveTextToParentTag(textData, currentNode, jPath);
            }
            jPath = jPath.substr(0, jPath.lastIndexOf("."));
            currentNode = this.tagsNodeStack.pop();
            textData = "";
            i3 = closeIndex;
          } else if (xmlData[i3 + 1] === "?") {
            let tagData = readTagExp(xmlData, i3, false, "?>");
            if (!tagData)
              throw new Error("Pi Tag is not closed.");
            textData = this.saveTextToParentTag(textData, currentNode, jPath);
            if (this.options.ignoreDeclaration && tagData.tagName === "?xml" || this.options.ignorePiTags) {
            } else {
              const childNode = new xmlNode(tagData.tagName);
              childNode.add(this.options.textNodeName, "");
              if (tagData.tagName !== tagData.tagExp && tagData.attrExpPresent) {
                childNode[":@"] = this.buildAttributesMap(tagData.tagExp, jPath);
              }
              currentNode.addChild(childNode);
            }
            i3 = tagData.closeIndex + 1;
          } else if (xmlData.substr(i3 + 1, 3) === "!--") {
            const endIndex = findClosingIndex(xmlData, "-->", i3 + 4, "Comment is not closed.");
            if (this.options.commentPropName) {
              const comment = xmlData.substring(i3 + 4, endIndex - 2);
              textData = this.saveTextToParentTag(textData, currentNode, jPath);
              currentNode.add(this.options.commentPropName, [{ [this.options.textNodeName]: comment }]);
            }
            i3 = endIndex;
          } else if (xmlData.substr(i3 + 1, 2) === "!D") {
            const result = readDocType(xmlData, i3);
            this.docTypeEntities = result.entities;
            i3 = result.i;
          } else if (xmlData.substr(i3 + 1, 2) === "![") {
            const closeIndex = findClosingIndex(xmlData, "]]>", i3, "CDATA is not closed.") - 2;
            const tagExp = xmlData.substring(i3 + 9, closeIndex);
            textData = this.saveTextToParentTag(textData, currentNode, jPath);
            if (this.options.cdataPropName) {
              currentNode.add(this.options.cdataPropName, [{ [this.options.textNodeName]: tagExp }]);
            } else {
              let val = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true);
              if (val == void 0)
                val = "";
              currentNode.add(this.options.textNodeName, val);
            }
            i3 = closeIndex + 2;
          } else {
            let result = readTagExp(xmlData, i3, this.options.removeNSPrefix);
            let tagName = result.tagName;
            let tagExp = result.tagExp;
            let attrExpPresent = result.attrExpPresent;
            let closeIndex = result.closeIndex;
            if (this.options.transformTagName) {
              tagName = this.options.transformTagName(tagName);
            }
            if (currentNode && textData) {
              if (currentNode.tagname !== "!xml") {
                textData = this.saveTextToParentTag(textData, currentNode, jPath, false);
              }
            }
            if (tagName !== xmlObj.tagname) {
              jPath += jPath ? "." + tagName : tagName;
            }
            const lastTag = currentNode;
            if (lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1) {
              currentNode = this.tagsNodeStack.pop();
            }
            if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) {
              let tagContent = "";
              if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
                i3 = result.closeIndex;
              } else if (this.options.unpairedTags.indexOf(tagName) !== -1) {
                i3 = result.closeIndex;
              } else {
                const result2 = this.readStopNodeData(xmlData, tagName, closeIndex + 1);
                if (!result2)
                  throw new Error(`Unexpected end of ${tagName}`);
                i3 = result2.i;
                tagContent = result2.tagContent;
              }
              const childNode = new xmlNode(tagName);
              if (tagName !== tagExp && attrExpPresent) {
                childNode[":@"] = this.buildAttributesMap(tagExp, jPath);
              }
              if (tagContent) {
                tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);
              }
              jPath = jPath.substr(0, jPath.lastIndexOf("."));
              childNode.add(this.options.textNodeName, tagContent);
              currentNode.addChild(childNode);
            } else {
              if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
                if (tagName[tagName.length - 1] === "/") {
                  tagName = tagName.substr(0, tagName.length - 1);
                  tagExp = tagName;
                } else {
                  tagExp = tagExp.substr(0, tagExp.length - 1);
                }
                if (this.options.transformTagName) {
                  tagName = this.options.transformTagName(tagName);
                }
                const childNode = new xmlNode(tagName);
                if (tagName !== tagExp && attrExpPresent) {
                  childNode[":@"] = this.buildAttributesMap(tagExp, jPath);
                }
                jPath = jPath.substr(0, jPath.lastIndexOf("."));
                currentNode.addChild(childNode);
              } else {
                const childNode = new xmlNode(tagName);
                this.tagsNodeStack.push(currentNode);
                if (tagName !== tagExp && attrExpPresent) {
                  childNode[":@"] = this.buildAttributesMap(tagExp, jPath);
                }
                currentNode.addChild(childNode);
                currentNode = childNode;
              }
              textData = "";
              i3 = closeIndex;
            }
          }
        } else {
          textData += xmlData[i3];
        }
      }
      return xmlObj.child;
    };
    var replaceEntitiesValue = function(val) {
      if (this.options.processEntities) {
        for (let entityName in this.docTypeEntities) {
          const entity = this.docTypeEntities[entityName];
          val = val.replace(entity.regx, entity.val);
        }
        for (let entityName in this.lastEntities) {
          const entity = this.lastEntities[entityName];
          val = val.replace(entity.regex, entity.val);
        }
        if (this.options.htmlEntities) {
          for (let entityName in this.htmlEntities) {
            const entity = this.htmlEntities[entityName];
            val = val.replace(entity.regex, entity.val);
          }
        }
        val = val.replace(this.ampEntity.regex, this.ampEntity.val);
      }
      return val;
    };
    function saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {
      if (textData) {
        if (isLeafNode === void 0)
          isLeafNode = Object.keys(currentNode.child).length === 0;
        textData = this.parseTextData(textData, currentNode.tagname, jPath, false, currentNode[":@"] ? Object.keys(currentNode[":@"]).length !== 0 : false, isLeafNode);
        if (textData !== void 0 && textData !== "")
          currentNode.add(this.options.textNodeName, textData);
        textData = "";
      }
      return textData;
    }
    function isItStopNode(stopNodes, jPath, currentTagName) {
      const allNodesExp = "*." + currentTagName;
      for (const stopNodePath in stopNodes) {
        const stopNodeExp = stopNodes[stopNodePath];
        if (allNodesExp === stopNodeExp || jPath === stopNodeExp)
          return true;
      }
      return false;
    }
    function tagExpWithClosingIndex(xmlData, i3, closingChar = ">") {
      let attrBoundary;
      let tagExp = "";
      for (let index = i3; index < xmlData.length; index++) {
        let ch2 = xmlData[index];
        if (attrBoundary) {
          if (ch2 === attrBoundary)
            attrBoundary = "";
        } else if (ch2 === '"' || ch2 === "'") {
          attrBoundary = ch2;
        } else if (ch2 === closingChar[0]) {
          if (closingChar[1]) {
            if (xmlData[index + 1] === closingChar[1]) {
              return {
                data: tagExp,
                index
              };
            }
          } else {
            return {
              data: tagExp,
              index
            };
          }
        } else if (ch2 === "	") {
          ch2 = " ";
        }
        tagExp += ch2;
      }
    }
    function findClosingIndex(xmlData, str, i3, errMsg) {
      const closingIndex = xmlData.indexOf(str, i3);
      if (closingIndex === -1) {
        throw new Error(errMsg);
      } else {
        return closingIndex + str.length - 1;
      }
    }
    function readTagExp(xmlData, i3, removeNSPrefix, closingChar = ">") {
      const result = tagExpWithClosingIndex(xmlData, i3 + 1, closingChar);
      if (!result)
        return;
      let tagExp = result.data;
      const closeIndex = result.index;
      const separatorIndex = tagExp.search(/\s/);
      let tagName = tagExp;
      let attrExpPresent = true;
      if (separatorIndex !== -1) {
        tagName = tagExp.substr(0, separatorIndex).replace(/\s\s*$/, "");
        tagExp = tagExp.substr(separatorIndex + 1);
      }
      if (removeNSPrefix) {
        const colonIndex = tagName.indexOf(":");
        if (colonIndex !== -1) {
          tagName = tagName.substr(colonIndex + 1);
          attrExpPresent = tagName !== result.data.substr(colonIndex + 1);
        }
      }
      return {
        tagName,
        tagExp,
        closeIndex,
        attrExpPresent
      };
    }
    function readStopNodeData(xmlData, tagName, i3) {
      const startIndex = i3;
      let openTagCount = 1;
      for (; i3 < xmlData.length; i3++) {
        if (xmlData[i3] === "<") {
          if (xmlData[i3 + 1] === "/") {
            const closeIndex = findClosingIndex(xmlData, ">", i3, `${tagName} is not closed`);
            let closeTagName = xmlData.substring(i3 + 2, closeIndex).trim();
            if (closeTagName === tagName) {
              openTagCount--;
              if (openTagCount === 0) {
                return {
                  tagContent: xmlData.substring(startIndex, i3),
                  i: closeIndex
                };
              }
            }
            i3 = closeIndex;
          } else if (xmlData[i3 + 1] === "?") {
            const closeIndex = findClosingIndex(xmlData, "?>", i3 + 1, "StopNode is not closed.");
            i3 = closeIndex;
          } else if (xmlData.substr(i3 + 1, 3) === "!--") {
            const closeIndex = findClosingIndex(xmlData, "-->", i3 + 3, "StopNode is not closed.");
            i3 = closeIndex;
          } else if (xmlData.substr(i3 + 1, 2) === "![") {
            const closeIndex = findClosingIndex(xmlData, "]]>", i3, "StopNode is not closed.") - 2;
            i3 = closeIndex;
          } else {
            const tagData = readTagExp(xmlData, i3, ">");
            if (tagData) {
              const openTagName = tagData && tagData.tagName;
              if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length - 1] !== "/") {
                openTagCount++;
              }
              i3 = tagData.closeIndex;
            }
          }
        }
      }
    }
    function parseValue(val, shouldParse, options) {
      if (shouldParse && typeof val === "string") {
        const newval = val.trim();
        if (newval === "true")
          return true;
        else if (newval === "false")
          return false;
        else
          return toNumber(val, options);
      } else {
        if (util.isExist(val)) {
          return val;
        } else {
          return "";
        }
      }
    }
    module2.exports = OrderedObjParser;
  }
});

// node_modules/fast-xml-parser/src/xmlparser/node2json.js
var require_node2json = __commonJS({
  "node_modules/fast-xml-parser/src/xmlparser/node2json.js"(exports) {
    "use strict";
    function prettify(node, options) {
      return compress2(node, options);
    }
    function compress2(arr, options, jPath) {
      let text;
      const compressedObj = {};
      for (let i3 = 0; i3 < arr.length; i3++) {
        const tagObj = arr[i3];
        const property = propName(tagObj);
        let newJpath = "";
        if (jPath === void 0)
          newJpath = property;
        else
          newJpath = jPath + "." + property;
        if (property === options.textNodeName) {
          if (text === void 0)
            text = tagObj[property];
          else
            text += "" + tagObj[property];
        } else if (property === void 0) {
          continue;
        } else if (tagObj[property]) {
          let val = compress2(tagObj[property], options, newJpath);
          const isLeaf = isLeafTag(val, options);
          if (tagObj[":@"]) {
            assignAttributes(val, tagObj[":@"], newJpath, options);
          } else if (Object.keys(val).length === 1 && val[options.textNodeName] !== void 0 && !options.alwaysCreateTextNode) {
            val = val[options.textNodeName];
          } else if (Object.keys(val).length === 0) {
            if (options.alwaysCreateTextNode)
              val[options.textNodeName] = "";
            else
              val = "";
          }
          if (compressedObj[property] !== void 0 && compressedObj.hasOwnProperty(property)) {
            if (!Array.isArray(compressedObj[property])) {
              compressedObj[property] = [compressedObj[property]];
            }
            compressedObj[property].push(val);
          } else {
            if (options.isArray(property, newJpath, isLeaf)) {
              compressedObj[property] = [val];
            } else {
              compressedObj[property] = val;
            }
          }
        }
      }
      if (typeof text === "string") {
        if (text.length > 0)
          compressedObj[options.textNodeName] = text;
      } else if (text !== void 0)
        compressedObj[options.textNodeName] = text;
      return compressedObj;
    }
    function propName(obj) {
      const keys = Object.keys(obj);
      for (let i3 = 0; i3 < keys.length; i3++) {
        const key = keys[i3];
        if (key !== ":@")
          return key;
      }
    }
    function assignAttributes(obj, attrMap, jpath, options) {
      if (attrMap) {
        const keys = Object.keys(attrMap);
        const len = keys.length;
        for (let i3 = 0; i3 < len; i3++) {
          const atrrName = keys[i3];
          if (options.isArray(atrrName, jpath + "." + atrrName, true, true)) {
            obj[atrrName] = [attrMap[atrrName]];
          } else {
            obj[atrrName] = attrMap[atrrName];
          }
        }
      }
    }
    function isLeafTag(obj, options) {
      const propCount = Object.keys(obj).length;
      if (propCount === 0 || propCount === 1 && obj[options.textNodeName])
        return true;
      return false;
    }
    exports.prettify = prettify;
  }
});

// node_modules/fast-xml-parser/src/xmlparser/XMLParser.js
var require_XMLParser = __commonJS({
  "node_modules/fast-xml-parser/src/xmlparser/XMLParser.js"(exports, module2) {
    var { buildOptions } = require_OptionsBuilder();
    var OrderedObjParser = require_OrderedObjParser();
    var { prettify } = require_node2json();
    var validator = require_validator();
    var XMLParser2 = class {
      constructor(options) {
        this.externalEntities = {};
        this.options = buildOptions(options);
      }
      parse(xmlData, validationOption) {
        if (typeof xmlData === "string") {
        } else if (xmlData.toString) {
          xmlData = xmlData.toString();
        } else {
          throw new Error("XML data is accepted in String or Bytes[] form.");
        }
        if (validationOption) {
          if (validationOption === true)
            validationOption = {};
          const result = validator.validate(xmlData, validationOption);
          if (result !== true) {
            throw Error(`${result.err.msg}:${result.err.line}:${result.err.col}`);
          }
        }
        const orderedObjParser = new OrderedObjParser(this.options);
        orderedObjParser.addExternalEntities(this.externalEntities);
        const orderedResult = orderedObjParser.parseXml(xmlData);
        if (this.options.preserveOrder || orderedResult === void 0)
          return orderedResult;
        else
          return prettify(orderedResult, this.options);
      }
      addEntity(key, value) {
        if (value.indexOf("&") !== -1) {
          throw new Error("Entity value can't have '&'");
        } else if (key.indexOf("&") !== -1 || key.indexOf(";") !== -1) {
          throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
        } else if (value === "&") {
          throw new Error("An entity with value '&' is not permitted");
        } else {
          this.externalEntities[key] = value;
        }
      }
    };
    module2.exports = XMLParser2;
  }
});

// node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js
var require_orderedJs2Xml = __commonJS({
  "node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js"(exports, module2) {
    var EOL = "\n";
    function toXml(jArray, options) {
      let indentation = "";
      if (options.format && options.indentBy.length > 0) {
        indentation = EOL;
      }
      return arrToStr(jArray, options, "", indentation);
    }
    function arrToStr(arr, options, jPath, indentation) {
      let xmlStr = "";
      let isPreviousElementTag = false;
      for (let i3 = 0; i3 < arr.length; i3++) {
        const tagObj = arr[i3];
        const tagName = propName(tagObj);
        let newJPath = "";
        if (jPath.length === 0)
          newJPath = tagName;
        else
          newJPath = `${jPath}.${tagName}`;
        if (tagName === options.textNodeName) {
          let tagText = tagObj[tagName];
          if (!isStopNode(newJPath, options)) {
            tagText = options.tagValueProcessor(tagName, tagText);
            tagText = replaceEntitiesValue(tagText, options);
          }
          if (isPreviousElementTag) {
            xmlStr += indentation;
          }
          xmlStr += tagText;
          isPreviousElementTag = false;
          continue;
        } else if (tagName === options.cdataPropName) {
          if (isPreviousElementTag) {
            xmlStr += indentation;
          }
          xmlStr += `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;
          isPreviousElementTag = false;
          continue;
        } else if (tagName === options.commentPropName) {
          xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;
          isPreviousElementTag = true;
          continue;
        } else if (tagName[0] === "?") {
          const attStr2 = attr_to_str(tagObj[":@"], options);
          const tempInd = tagName === "?xml" ? "" : indentation;
          let piTextNodeName = tagObj[tagName][0][options.textNodeName];
          piTextNodeName = piTextNodeName.length !== 0 ? " " + piTextNodeName : "";
          xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr2}?>`;
          isPreviousElementTag = true;
          continue;
        }
        let newIdentation = indentation;
        if (newIdentation !== "") {
          newIdentation += options.indentBy;
        }
        const attStr = attr_to_str(tagObj[":@"], options);
        const tagStart = indentation + `<${tagName}${attStr}`;
        const tagValue = arrToStr(tagObj[tagName], options, newJPath, newIdentation);
        if (options.unpairedTags.indexOf(tagName) !== -1) {
          if (options.suppressUnpairedNode)
            xmlStr += tagStart + ">";
          else
            xmlStr += tagStart + "/>";
        } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {
          xmlStr += tagStart + "/>";
        } else if (tagValue && tagValue.endsWith(">")) {
          xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;
        } else {
          xmlStr += tagStart + ">";
          if (tagValue && indentation !== "" && (tagValue.includes("/>") || tagValue.includes("</"))) {
            xmlStr += indentation + options.indentBy + tagValue + indentation;
          } else {
            xmlStr += tagValue;
          }
          xmlStr += `</${tagName}>`;
        }
        isPreviousElementTag = true;
      }
      return xmlStr;
    }
    function propName(obj) {
      const keys = Object.keys(obj);
      for (let i3 = 0; i3 < keys.length; i3++) {
        const key = keys[i3];
        if (key !== ":@")
          return key;
      }
    }
    function attr_to_str(attrMap, options) {
      let attrStr = "";
      if (attrMap && !options.ignoreAttributes) {
        for (let attr in attrMap) {
          let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);
          attrVal = replaceEntitiesValue(attrVal, options);
          if (attrVal === true && options.suppressBooleanAttributes) {
            attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;
          } else {
            attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}="${attrVal}"`;
          }
        }
      }
      return attrStr;
    }
    function isStopNode(jPath, options) {
      jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);
      let tagName = jPath.substr(jPath.lastIndexOf(".") + 1);
      for (let index in options.stopNodes) {
        if (options.stopNodes[index] === jPath || options.stopNodes[index] === "*." + tagName)
          return true;
      }
      return false;
    }
    function replaceEntitiesValue(textValue, options) {
      if (textValue && textValue.length > 0 && options.processEntities) {
        for (let i3 = 0; i3 < options.entities.length; i3++) {
          const entity = options.entities[i3];
          textValue = textValue.replace(entity.regex, entity.val);
        }
      }
      return textValue;
    }
    module2.exports = toXml;
  }
});

// node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js
var require_json2xml = __commonJS({
  "node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js"(exports, module2) {
    "use strict";
    var buildFromOrderedJs = require_orderedJs2Xml();
    var defaultOptions = {
      attributeNamePrefix: "@_",
      attributesGroupName: false,
      textNodeName: "#text",
      ignoreAttributes: true,
      cdataPropName: false,
      format: false,
      indentBy: "  ",
      suppressEmptyNode: false,
      suppressUnpairedNode: true,
      suppressBooleanAttributes: true,
      tagValueProcessor: function(key, a3) {
        return a3;
      },
      attributeValueProcessor: function(attrName, a3) {
        return a3;
      },
      preserveOrder: false,
      commentPropName: false,
      unpairedTags: [],
      entities: [
        { regex: new RegExp("&", "g"), val: "&amp;" },
        { regex: new RegExp(">", "g"), val: "&gt;" },
        { regex: new RegExp("<", "g"), val: "&lt;" },
        { regex: new RegExp("'", "g"), val: "&apos;" },
        { regex: new RegExp('"', "g"), val: "&quot;" }
      ],
      processEntities: true,
      stopNodes: []
    };
    function Builder(options) {
      this.options = Object.assign({}, defaultOptions, options);
      if (this.options.ignoreAttributes || this.options.attributesGroupName) {
        this.isAttribute = function() {
          return false;
        };
      } else {
        this.attrPrefixLen = this.options.attributeNamePrefix.length;
        this.isAttribute = isAttribute;
      }
      this.processTextOrObjNode = processTextOrObjNode;
      if (this.options.format) {
        this.indentate = indentate;
        this.tagEndChar = ">\n";
        this.newLine = "\n";
      } else {
        this.indentate = function() {
          return "";
        };
        this.tagEndChar = ">";
        this.newLine = "";
      }
    }
    Builder.prototype.build = function(jObj) {
      if (this.options.preserveOrder) {
        return buildFromOrderedJs(jObj, this.options);
      } else {
        if (Array.isArray(jObj) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1) {
          jObj = {
            [this.options.arrayNodeName]: jObj
          };
        }
        return this.j2x(jObj, 0).val;
      }
    };
    Builder.prototype.j2x = function(jObj, level) {
      let attrStr = "";
      let val = "";
      for (let key in jObj) {
        if (typeof jObj[key] === "undefined") {
        } else if (jObj[key] === null) {
          if (key[0] === "?")
            val += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
          else
            val += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
        } else if (jObj[key] instanceof Date) {
          val += this.buildTextValNode(jObj[key], key, "", level);
        } else if (typeof jObj[key] !== "object") {
          const attr = this.isAttribute(key);
          if (attr) {
            attrStr += this.buildAttrPairStr(attr, "" + jObj[key]);
          } else {
            if (key === this.options.textNodeName) {
              let newval = this.options.tagValueProcessor(key, "" + jObj[key]);
              val += this.replaceEntitiesValue(newval);
            } else {
              val += this.buildTextValNode(jObj[key], key, "", level);
            }
          }
        } else if (Array.isArray(jObj[key])) {
          const arrLen = jObj[key].length;
          for (let j2 = 0; j2 < arrLen; j2++) {
            const item = jObj[key][j2];
            if (typeof item === "undefined") {
            } else if (item === null) {
              if (key[0] === "?")
                val += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
              else
                val += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
            } else if (typeof item === "object") {
              val += this.processTextOrObjNode(item, key, level);
            } else {
              val += this.buildTextValNode(item, key, "", level);
            }
          }
        } else {
          if (this.options.attributesGroupName && key === this.options.attributesGroupName) {
            const Ks = Object.keys(jObj[key]);
            const L2 = Ks.length;
            for (let j2 = 0; j2 < L2; j2++) {
              attrStr += this.buildAttrPairStr(Ks[j2], "" + jObj[key][Ks[j2]]);
            }
          } else {
            val += this.processTextOrObjNode(jObj[key], key, level);
          }
        }
      }
      return { attrStr, val };
    };
    Builder.prototype.buildAttrPairStr = function(attrName, val) {
      val = this.options.attributeValueProcessor(attrName, "" + val);
      val = this.replaceEntitiesValue(val);
      if (this.options.suppressBooleanAttributes && val === "true") {
        return " " + attrName;
      } else
        return " " + attrName + '="' + val + '"';
    };
    function processTextOrObjNode(object, key, level) {
      const result = this.j2x(object, level + 1);
      if (object[this.options.textNodeName] !== void 0 && Object.keys(object).length === 1) {
        return this.buildTextValNode(object[this.options.textNodeName], key, result.attrStr, level);
      } else {
        return this.buildObjectNode(result.val, key, result.attrStr, level);
      }
    }
    Builder.prototype.buildObjectNode = function(val, key, attrStr, level) {
      if (val === "") {
        if (key[0] === "?")
          return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
        else {
          return this.indentate(level) + "<" + key + attrStr + this.closeTag(key) + this.tagEndChar;
        }
      } else {
        let tagEndExp = "</" + key + this.tagEndChar;
        let piClosingChar = "";
        if (key[0] === "?") {
          piClosingChar = "?";
          tagEndExp = "";
        }
        if (attrStr && val.indexOf("<") === -1) {
          return this.indentate(level) + "<" + key + attrStr + piClosingChar + ">" + val + tagEndExp;
        } else if (this.options.commentPropName !== false && key === this.options.commentPropName && piClosingChar.length === 0) {
          return this.indentate(level) + `<!--${val}-->` + this.newLine;
        } else {
          return this.indentate(level) + "<" + key + attrStr + piClosingChar + this.tagEndChar + val + this.indentate(level) + tagEndExp;
        }
      }
    };
    Builder.prototype.closeTag = function(key) {
      let closeTag = "";
      if (this.options.unpairedTags.indexOf(key) !== -1) {
        if (!this.options.suppressUnpairedNode)
          closeTag = "/";
      } else if (this.options.suppressEmptyNode) {
        closeTag = "/";
      } else {
        closeTag = `></${key}`;
      }
      return closeTag;
    };
    Builder.prototype.buildTextValNode = function(val, key, attrStr, level) {
      if (this.options.cdataPropName !== false && key === this.options.cdataPropName) {
        return this.indentate(level) + `<![CDATA[${val}]]>` + this.newLine;
      } else if (this.options.commentPropName !== false && key === this.options.commentPropName) {
        return this.indentate(level) + `<!--${val}-->` + this.newLine;
      } else if (key[0] === "?") {
        return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
      } else {
        let textValue = this.options.tagValueProcessor(key, val);
        textValue = this.replaceEntitiesValue(textValue);
        if (textValue === "") {
          return this.indentate(level) + "<" + key + attrStr + this.closeTag(key) + this.tagEndChar;
        } else {
          return this.indentate(level) + "<" + key + attrStr + ">" + textValue + "</" + key + this.tagEndChar;
        }
      }
    };
    Builder.prototype.replaceEntitiesValue = function(textValue) {
      if (textValue && textValue.length > 0 && this.options.processEntities) {
        for (let i3 = 0; i3 < this.options.entities.length; i3++) {
          const entity = this.options.entities[i3];
          textValue = textValue.replace(entity.regex, entity.val);
        }
      }
      return textValue;
    };
    function indentate(level) {
      return this.options.indentBy.repeat(level);
    }
    function isAttribute(name) {
      if (name.startsWith(this.options.attributeNamePrefix)) {
        return name.substr(this.attrPrefixLen);
      } else {
        return false;
      }
    }
    module2.exports = Builder;
  }
});

// node_modules/fast-xml-parser/src/fxp.js
var require_fxp = __commonJS({
  "node_modules/fast-xml-parser/src/fxp.js"(exports, module2) {
    "use strict";
    var validator = require_validator();
    var XMLParser2 = require_XMLParser();
    var XMLBuilder = require_json2xml();
    module2.exports = {
      XMLParser: XMLParser2,
      XMLValidator: validator,
      XMLBuilder
    };
  }
});

// node_modules/@aws-crypto/crc32/node_modules/tslib/tslib.js
var require_tslib = __commonJS({
  "node_modules/@aws-crypto/crc32/node_modules/tslib/tslib.js"(exports, module2) {
    var __extends;
    var __assign;
    var __rest;
    var __decorate;
    var __param;
    var __metadata;
    var __awaiter;
    var __generator;
    var __exportStar;
    var __values;
    var __read;
    var __spread;
    var __spreadArrays;
    var __await;
    var __asyncGenerator;
    var __asyncDelegator;
    var __asyncValues;
    var __makeTemplateObject;
    var __importStar;
    var __importDefault;
    var __classPrivateFieldGet;
    var __classPrivateFieldSet;
    var __createBinding;
    (function(factory) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports2) {
          factory(createExporter(root, createExporter(exports2)));
        });
      } else if (typeof module2 === "object" && typeof module2.exports === "object") {
        factory(createExporter(root, createExporter(module2.exports)));
      } else {
        factory(createExporter(root));
      }
      function createExporter(exports2, previous) {
        if (exports2 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports2, "__esModule", { value: true });
          } else {
            exports2.__esModule = true;
          }
        }
        return function(id, v2) {
          return exports2[id] = previous ? previous(id, v2) : v2;
        };
      }
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p2 in b2)
          if (b2.hasOwnProperty(p2))
            d2[p2] = b2[p2];
      };
      __extends = function(d2, b2) {
        extendStatics(d2, b2);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
      __assign = Object.assign || function(t3) {
        for (var s3, i3 = 1, n2 = arguments.length; i3 < n2; i3++) {
          s3 = arguments[i3];
          for (var p2 in s3)
            if (Object.prototype.hasOwnProperty.call(s3, p2))
              t3[p2] = s3[p2];
        }
        return t3;
      };
      __rest = function(s3, e3) {
        var t3 = {};
        for (var p2 in s3)
          if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
            t3[p2] = s3[p2];
        if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i3 = 0, p2 = Object.getOwnPropertySymbols(s3); i3 < p2.length; i3++) {
            if (e3.indexOf(p2[i3]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i3]))
              t3[p2[i3]] = s3[p2[i3]];
          }
        return t3;
      };
      __decorate = function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r3 = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i3 = decorators.length - 1; i3 >= 0; i3--)
            if (d2 = decorators[i3])
              r3 = (c3 < 3 ? d2(r3) : c3 > 3 ? d2(target, key, r3) : d2(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      __param = function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      __metadata = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter = function(thisArg, _arguments, P2, generator) {
        function adopt(value) {
          return value instanceof P2 ? value : new P2(function(resolve) {
            resolve(value);
          });
        }
        return new (P2 || (P2 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e3) {
              reject(e3);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e3) {
              reject(e3);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator = function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t3[0] & 1)
            throw t3[1];
          return t3[1];
        }, trys: [], ops: [] }, f3, y2, t3, g2;
        return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
          return this;
        }), g2;
        function verb(n2) {
          return function(v2) {
            return step([n2, v2]);
          };
        }
        function step(op) {
          if (f3)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f3 = 1, y2 && (t3 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t3 = y2["return"]) && t3.call(y2), 0) : y2.next) && !(t3 = t3.call(y2, op[1])).done)
                return t3;
              if (y2 = 0, t3)
                op = [op[0] & 2, t3.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t3 = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y2 = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t3 = _.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t3[1]) {
                    _.label = t3[1];
                    t3 = op;
                    break;
                  }
                  if (t3 && _.label < t3[2]) {
                    _.label = t3[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t3[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e3) {
              op = [6, e3];
              y2 = 0;
            } finally {
              f3 = t3 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __createBinding = function(o3, m2, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        o3[k22] = m2[k2];
      };
      __exportStar = function(m2, exports2) {
        for (var p2 in m2)
          if (p2 !== "default" && !exports2.hasOwnProperty(p2))
            exports2[p2] = m2[p2];
      };
      __values = function(o3) {
        var s3 = typeof Symbol === "function" && Symbol.iterator, m2 = s3 && o3[s3], i3 = 0;
        if (m2)
          return m2.call(o3);
        if (o3 && typeof o3.length === "number")
          return {
            next: function() {
              if (o3 && i3 >= o3.length)
                o3 = void 0;
              return { value: o3 && o3[i3++], done: !o3 };
            }
          };
        throw new TypeError(s3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read = function(o3, n2) {
        var m2 = typeof Symbol === "function" && o3[Symbol.iterator];
        if (!m2)
          return o3;
        var i3 = m2.call(o3), r3, ar2 = [], e3;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r3 = i3.next()).done)
            ar2.push(r3.value);
        } catch (error) {
          e3 = { error };
        } finally {
          try {
            if (r3 && !r3.done && (m2 = i3["return"]))
              m2.call(i3);
          } finally {
            if (e3)
              throw e3.error;
          }
        }
        return ar2;
      };
      __spread = function() {
        for (var ar2 = [], i3 = 0; i3 < arguments.length; i3++)
          ar2 = ar2.concat(__read(arguments[i3]));
        return ar2;
      };
      __spreadArrays = function() {
        for (var s3 = 0, i3 = 0, il = arguments.length; i3 < il; i3++)
          s3 += arguments[i3].length;
        for (var r3 = Array(s3), k2 = 0, i3 = 0; i3 < il; i3++)
          for (var a3 = arguments[i3], j2 = 0, jl = a3.length; j2 < jl; j2++, k2++)
            r3[k2] = a3[j2];
        return r3;
      };
      __await = function(v2) {
        return this instanceof __await ? (this.v = v2, this) : new __await(v2);
      };
      __asyncGenerator = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g2 = generator.apply(thisArg, _arguments || []), i3, q2 = [];
        return i3 = {}, verb("next"), verb("throw"), verb("return"), i3[Symbol.asyncIterator] = function() {
          return this;
        }, i3;
        function verb(n2) {
          if (g2[n2])
            i3[n2] = function(v2) {
              return new Promise(function(a3, b2) {
                q2.push([n2, v2, a3, b2]) > 1 || resume(n2, v2);
              });
            };
        }
        function resume(n2, v2) {
          try {
            step(g2[n2](v2));
          } catch (e3) {
            settle(q2[0][3], e3);
          }
        }
        function step(r3) {
          r3.value instanceof __await ? Promise.resolve(r3.value.v).then(fulfill, reject) : settle(q2[0][2], r3);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f3, v2) {
          if (f3(v2), q2.shift(), q2.length)
            resume(q2[0][0], q2[0][1]);
        }
      };
      __asyncDelegator = function(o3) {
        var i3, p2;
        return i3 = {}, verb("next"), verb("throw", function(e3) {
          throw e3;
        }), verb("return"), i3[Symbol.iterator] = function() {
          return this;
        }, i3;
        function verb(n2, f3) {
          i3[n2] = o3[n2] ? function(v2) {
            return (p2 = !p2) ? { value: __await(o3[n2](v2)), done: n2 === "return" } : f3 ? f3(v2) : v2;
          } : f3;
        }
      };
      __asyncValues = function(o3) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m2 = o3[Symbol.asyncIterator], i3;
        return m2 ? m2.call(o3) : (o3 = typeof __values === "function" ? __values(o3) : o3[Symbol.iterator](), i3 = {}, verb("next"), verb("throw"), verb("return"), i3[Symbol.asyncIterator] = function() {
          return this;
        }, i3);
        function verb(n2) {
          i3[n2] = o3[n2] && function(v2) {
            return new Promise(function(resolve, reject) {
              v2 = o3[n2](v2), settle(resolve, reject, v2.done, v2.value);
            });
          };
        }
        function settle(resolve, reject, d2, v2) {
          Promise.resolve(v2).then(function(v3) {
            resolve({ value: v3, done: d2 });
          }, reject);
        }
      };
      __makeTemplateObject = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      __importStar = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k2 in mod)
            if (Object.hasOwnProperty.call(mod, k2))
              result[k2] = mod[k2];
        }
        result["default"] = mod;
        return result;
      };
      __importDefault = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet = function(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
      };
      __classPrivateFieldSet = function(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
      };
      exporter("__extends", __extends);
      exporter("__assign", __assign);
      exporter("__rest", __rest);
      exporter("__decorate", __decorate);
      exporter("__param", __param);
      exporter("__metadata", __metadata);
      exporter("__awaiter", __awaiter);
      exporter("__generator", __generator);
      exporter("__exportStar", __exportStar);
      exporter("__createBinding", __createBinding);
      exporter("__values", __values);
      exporter("__read", __read);
      exporter("__spread", __spread);
      exporter("__spreadArrays", __spreadArrays);
      exporter("__await", __await);
      exporter("__asyncGenerator", __asyncGenerator);
      exporter("__asyncDelegator", __asyncDelegator);
      exporter("__asyncValues", __asyncValues);
      exporter("__makeTemplateObject", __makeTemplateObject);
      exporter("__importStar", __importStar);
      exporter("__importDefault", __importDefault);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    });
  }
});

// node_modules/@aws-sdk/util-utf8-browser/dist-cjs/pureJs.js
var require_pureJs = __commonJS({
  "node_modules/@aws-sdk/util-utf8-browser/dist-cjs/pureJs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toUtf8 = exports.fromUtf8 = void 0;
    var fromUtf82 = (input) => {
      const bytes = [];
      for (let i3 = 0, len = input.length; i3 < len; i3++) {
        const value = input.charCodeAt(i3);
        if (value < 128) {
          bytes.push(value);
        } else if (value < 2048) {
          bytes.push(value >> 6 | 192, value & 63 | 128);
        } else if (i3 + 1 < input.length && (value & 64512) === 55296 && (input.charCodeAt(i3 + 1) & 64512) === 56320) {
          const surrogatePair = 65536 + ((value & 1023) << 10) + (input.charCodeAt(++i3) & 1023);
          bytes.push(surrogatePair >> 18 | 240, surrogatePair >> 12 & 63 | 128, surrogatePair >> 6 & 63 | 128, surrogatePair & 63 | 128);
        } else {
          bytes.push(value >> 12 | 224, value >> 6 & 63 | 128, value & 63 | 128);
        }
      }
      return Uint8Array.from(bytes);
    };
    exports.fromUtf8 = fromUtf82;
    var toUtf82 = (input) => {
      let decoded = "";
      for (let i3 = 0, len = input.length; i3 < len; i3++) {
        const byte = input[i3];
        if (byte < 128) {
          decoded += String.fromCharCode(byte);
        } else if (192 <= byte && byte < 224) {
          const nextByte = input[++i3];
          decoded += String.fromCharCode((byte & 31) << 6 | nextByte & 63);
        } else if (240 <= byte && byte < 365) {
          const surrogatePair = [byte, input[++i3], input[++i3], input[++i3]];
          const encoded = "%" + surrogatePair.map((byteValue) => byteValue.toString(16)).join("%");
          decoded += decodeURIComponent(encoded);
        } else {
          decoded += String.fromCharCode((byte & 15) << 12 | (input[++i3] & 63) << 6 | input[++i3] & 63);
        }
      }
      return decoded;
    };
    exports.toUtf8 = toUtf82;
  }
});

// node_modules/@aws-sdk/util-utf8-browser/dist-cjs/whatwgEncodingApi.js
var require_whatwgEncodingApi = __commonJS({
  "node_modules/@aws-sdk/util-utf8-browser/dist-cjs/whatwgEncodingApi.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toUtf8 = exports.fromUtf8 = void 0;
    function fromUtf82(input) {
      return new TextEncoder().encode(input);
    }
    exports.fromUtf8 = fromUtf82;
    function toUtf82(input) {
      return new TextDecoder("utf-8").decode(input);
    }
    exports.toUtf8 = toUtf82;
  }
});

// node_modules/@aws-sdk/util-utf8-browser/dist-cjs/index.js
var require_dist_cjs = __commonJS({
  "node_modules/@aws-sdk/util-utf8-browser/dist-cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toUtf8 = exports.fromUtf8 = void 0;
    var pureJs_1 = require_pureJs();
    var whatwgEncodingApi_1 = require_whatwgEncodingApi();
    var fromUtf82 = (input) => typeof TextEncoder === "function" ? (0, whatwgEncodingApi_1.fromUtf8)(input) : (0, pureJs_1.fromUtf8)(input);
    exports.fromUtf8 = fromUtf82;
    var toUtf82 = (input) => typeof TextDecoder === "function" ? (0, whatwgEncodingApi_1.toUtf8)(input) : (0, pureJs_1.toUtf8)(input);
    exports.toUtf8 = toUtf82;
  }
});

// node_modules/@aws-crypto/util/build/convertToBuffer.js
var require_convertToBuffer = __commonJS({
  "node_modules/@aws-crypto/util/build/convertToBuffer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.convertToBuffer = void 0;
    var util_utf8_browser_1 = require_dist_cjs();
    var fromUtf82 = typeof Buffer !== "undefined" && Buffer.from ? function(input) {
      return Buffer.from(input, "utf8");
    } : util_utf8_browser_1.fromUtf8;
    function convertToBuffer2(data) {
      if (data instanceof Uint8Array)
        return data;
      if (typeof data === "string") {
        return fromUtf82(data);
      }
      if (ArrayBuffer.isView(data)) {
        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
      }
      return new Uint8Array(data);
    }
    exports.convertToBuffer = convertToBuffer2;
  }
});

// node_modules/@aws-crypto/util/build/isEmptyData.js
var require_isEmptyData = __commonJS({
  "node_modules/@aws-crypto/util/build/isEmptyData.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isEmptyData = void 0;
    function isEmptyData2(data) {
      if (typeof data === "string") {
        return data.length === 0;
      }
      return data.byteLength === 0;
    }
    exports.isEmptyData = isEmptyData2;
  }
});

// node_modules/@aws-crypto/util/build/numToUint8.js
var require_numToUint8 = __commonJS({
  "node_modules/@aws-crypto/util/build/numToUint8.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.numToUint8 = void 0;
    function numToUint8(num) {
      return new Uint8Array([
        (num & 4278190080) >> 24,
        (num & 16711680) >> 16,
        (num & 65280) >> 8,
        num & 255
      ]);
    }
    exports.numToUint8 = numToUint8;
  }
});

// node_modules/@aws-crypto/util/build/uint32ArrayFrom.js
var require_uint32ArrayFrom = __commonJS({
  "node_modules/@aws-crypto/util/build/uint32ArrayFrom.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.uint32ArrayFrom = void 0;
    function uint32ArrayFrom(a_lookUpTable) {
      if (!Uint32Array.from) {
        var return_array = new Uint32Array(a_lookUpTable.length);
        var a_index = 0;
        while (a_index < a_lookUpTable.length) {
          return_array[a_index] = a_lookUpTable[a_index];
          a_index += 1;
        }
        return return_array;
      }
      return Uint32Array.from(a_lookUpTable);
    }
    exports.uint32ArrayFrom = uint32ArrayFrom;
  }
});

// node_modules/@aws-crypto/util/build/index.js
var require_build = __commonJS({
  "node_modules/@aws-crypto/util/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.uint32ArrayFrom = exports.numToUint8 = exports.isEmptyData = exports.convertToBuffer = void 0;
    var convertToBuffer_1 = require_convertToBuffer();
    Object.defineProperty(exports, "convertToBuffer", { enumerable: true, get: function() {
      return convertToBuffer_1.convertToBuffer;
    } });
    var isEmptyData_1 = require_isEmptyData();
    Object.defineProperty(exports, "isEmptyData", { enumerable: true, get: function() {
      return isEmptyData_1.isEmptyData;
    } });
    var numToUint8_1 = require_numToUint8();
    Object.defineProperty(exports, "numToUint8", { enumerable: true, get: function() {
      return numToUint8_1.numToUint8;
    } });
    var uint32ArrayFrom_1 = require_uint32ArrayFrom();
    Object.defineProperty(exports, "uint32ArrayFrom", { enumerable: true, get: function() {
      return uint32ArrayFrom_1.uint32ArrayFrom;
    } });
  }
});

// node_modules/@aws-crypto/crc32/build/aws_crc32.js
var require_aws_crc32 = __commonJS({
  "node_modules/@aws-crypto/crc32/build/aws_crc32.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AwsCrc32 = void 0;
    var tslib_1 = require_tslib();
    var util_1 = require_build();
    var index_1 = require_build2();
    var AwsCrc322 = function() {
      function AwsCrc323() {
        this.crc32 = new index_1.Crc32();
      }
      AwsCrc323.prototype.update = function(toHash) {
        if ((0, util_1.isEmptyData)(toHash))
          return;
        this.crc32.update((0, util_1.convertToBuffer)(toHash));
      };
      AwsCrc323.prototype.digest = function() {
        return tslib_1.__awaiter(this, void 0, void 0, function() {
          return tslib_1.__generator(this, function(_a) {
            return [2, (0, util_1.numToUint8)(this.crc32.digest())];
          });
        });
      };
      AwsCrc323.prototype.reset = function() {
        this.crc32 = new index_1.Crc32();
      };
      return AwsCrc323;
    }();
    exports.AwsCrc32 = AwsCrc322;
  }
});

// node_modules/@aws-crypto/crc32/build/index.js
var require_build2 = __commonJS({
  "node_modules/@aws-crypto/crc32/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AwsCrc32 = exports.Crc32 = exports.crc32 = void 0;
    var tslib_1 = require_tslib();
    var util_1 = require_build();
    function crc32(data) {
      return new Crc323().update(data).digest();
    }
    exports.crc32 = crc32;
    var Crc323 = function() {
      function Crc324() {
        this.checksum = 4294967295;
      }
      Crc324.prototype.update = function(data) {
        var e_1, _a;
        try {
          for (var data_1 = tslib_1.__values(data), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {
            var byte = data_1_1.value;
            this.checksum = this.checksum >>> 8 ^ lookupTable[(this.checksum ^ byte) & 255];
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (data_1_1 && !data_1_1.done && (_a = data_1.return))
              _a.call(data_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        return this;
      };
      Crc324.prototype.digest = function() {
        return (this.checksum ^ 4294967295) >>> 0;
      };
      return Crc324;
    }();
    exports.Crc32 = Crc323;
    var a_lookUpTable = [
      0,
      1996959894,
      3993919788,
      2567524794,
      124634137,
      1886057615,
      3915621685,
      2657392035,
      249268274,
      2044508324,
      3772115230,
      2547177864,
      162941995,
      2125561021,
      3887607047,
      2428444049,
      498536548,
      1789927666,
      4089016648,
      2227061214,
      450548861,
      1843258603,
      4107580753,
      2211677639,
      325883990,
      1684777152,
      4251122042,
      2321926636,
      335633487,
      1661365465,
      4195302755,
      2366115317,
      997073096,
      1281953886,
      3579855332,
      2724688242,
      1006888145,
      1258607687,
      3524101629,
      2768942443,
      901097722,
      1119000684,
      3686517206,
      2898065728,
      853044451,
      1172266101,
      3705015759,
      2882616665,
      651767980,
      1373503546,
      3369554304,
      3218104598,
      565507253,
      1454621731,
      3485111705,
      3099436303,
      671266974,
      1594198024,
      3322730930,
      2970347812,
      795835527,
      1483230225,
      3244367275,
      3060149565,
      1994146192,
      31158534,
      2563907772,
      4023717930,
      1907459465,
      112637215,
      2680153253,
      3904427059,
      2013776290,
      251722036,
      2517215374,
      3775830040,
      2137656763,
      141376813,
      2439277719,
      3865271297,
      1802195444,
      476864866,
      2238001368,
      4066508878,
      1812370925,
      453092731,
      2181625025,
      4111451223,
      1706088902,
      314042704,
      2344532202,
      4240017532,
      1658658271,
      366619977,
      2362670323,
      4224994405,
      1303535960,
      984961486,
      2747007092,
      3569037538,
      1256170817,
      1037604311,
      2765210733,
      3554079995,
      1131014506,
      879679996,
      2909243462,
      3663771856,
      1141124467,
      855842277,
      2852801631,
      3708648649,
      1342533948,
      654459306,
      3188396048,
      3373015174,
      1466479909,
      544179635,
      3110523913,
      3462522015,
      1591671054,
      702138776,
      2966460450,
      3352799412,
      1504918807,
      783551873,
      3082640443,
      3233442989,
      3988292384,
      2596254646,
      62317068,
      1957810842,
      3939845945,
      2647816111,
      81470997,
      1943803523,
      3814918930,
      2489596804,
      225274430,
      2053790376,
      3826175755,
      2466906013,
      167816743,
      2097651377,
      4027552580,
      2265490386,
      503444072,
      1762050814,
      4150417245,
      2154129355,
      426522225,
      1852507879,
      4275313526,
      2312317920,
      282753626,
      1742555852,
      4189708143,
      2394877945,
      397917763,
      1622183637,
      3604390888,
      2714866558,
      953729732,
      1340076626,
      3518719985,
      2797360999,
      1068828381,
      1219638859,
      3624741850,
      2936675148,
      906185462,
      1090812512,
      3747672003,
      2825379669,
      829329135,
      1181335161,
      3412177804,
      3160834842,
      628085408,
      1382605366,
      3423369109,
      3138078467,
      570562233,
      1426400815,
      3317316542,
      2998733608,
      733239954,
      1555261956,
      3268935591,
      3050360625,
      752459403,
      1541320221,
      2607071920,
      3965973030,
      1969922972,
      40735498,
      2617837225,
      3943577151,
      1913087877,
      83908371,
      2512341634,
      3803740692,
      2075208622,
      213261112,
      2463272603,
      3855990285,
      2094854071,
      198958881,
      2262029012,
      4057260610,
      1759359992,
      534414190,
      2176718541,
      4139329115,
      1873836001,
      414664567,
      2282248934,
      4279200368,
      1711684554,
      285281116,
      2405801727,
      4167216745,
      1634467795,
      376229701,
      2685067896,
      3608007406,
      1308918612,
      956543938,
      2808555105,
      3495958263,
      1231636301,
      1047427035,
      2932959818,
      3654703836,
      1088359270,
      936918e3,
      2847714899,
      3736837829,
      1202900863,
      817233897,
      3183342108,
      3401237130,
      1404277552,
      615818150,
      3134207493,
      3453421203,
      1423857449,
      601450431,
      3009837614,
      3294710456,
      1567103746,
      711928724,
      3020668471,
      3272380065,
      1510334235,
      755167117
    ];
    var lookupTable = (0, util_1.uint32ArrayFrom)(a_lookUpTable);
    var aws_crc32_1 = require_aws_crc32();
    Object.defineProperty(exports, "AwsCrc32", { enumerable: true, get: function() {
      return aws_crc32_1.AwsCrc32;
    } });
  }
});

// node_modules/@aws-crypto/crc32c/node_modules/tslib/tslib.js
var require_tslib2 = __commonJS({
  "node_modules/@aws-crypto/crc32c/node_modules/tslib/tslib.js"(exports, module2) {
    var __extends;
    var __assign;
    var __rest;
    var __decorate;
    var __param;
    var __metadata;
    var __awaiter;
    var __generator;
    var __exportStar;
    var __values;
    var __read;
    var __spread;
    var __spreadArrays;
    var __await;
    var __asyncGenerator;
    var __asyncDelegator;
    var __asyncValues;
    var __makeTemplateObject;
    var __importStar;
    var __importDefault;
    var __classPrivateFieldGet;
    var __classPrivateFieldSet;
    var __createBinding;
    (function(factory) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports2) {
          factory(createExporter(root, createExporter(exports2)));
        });
      } else if (typeof module2 === "object" && typeof module2.exports === "object") {
        factory(createExporter(root, createExporter(module2.exports)));
      } else {
        factory(createExporter(root));
      }
      function createExporter(exports2, previous) {
        if (exports2 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports2, "__esModule", { value: true });
          } else {
            exports2.__esModule = true;
          }
        }
        return function(id, v2) {
          return exports2[id] = previous ? previous(id, v2) : v2;
        };
      }
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p2 in b2)
          if (b2.hasOwnProperty(p2))
            d2[p2] = b2[p2];
      };
      __extends = function(d2, b2) {
        extendStatics(d2, b2);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
      __assign = Object.assign || function(t3) {
        for (var s3, i3 = 1, n2 = arguments.length; i3 < n2; i3++) {
          s3 = arguments[i3];
          for (var p2 in s3)
            if (Object.prototype.hasOwnProperty.call(s3, p2))
              t3[p2] = s3[p2];
        }
        return t3;
      };
      __rest = function(s3, e3) {
        var t3 = {};
        for (var p2 in s3)
          if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
            t3[p2] = s3[p2];
        if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i3 = 0, p2 = Object.getOwnPropertySymbols(s3); i3 < p2.length; i3++) {
            if (e3.indexOf(p2[i3]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i3]))
              t3[p2[i3]] = s3[p2[i3]];
          }
        return t3;
      };
      __decorate = function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r3 = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i3 = decorators.length - 1; i3 >= 0; i3--)
            if (d2 = decorators[i3])
              r3 = (c3 < 3 ? d2(r3) : c3 > 3 ? d2(target, key, r3) : d2(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      __param = function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      __metadata = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter = function(thisArg, _arguments, P2, generator) {
        function adopt(value) {
          return value instanceof P2 ? value : new P2(function(resolve) {
            resolve(value);
          });
        }
        return new (P2 || (P2 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e3) {
              reject(e3);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e3) {
              reject(e3);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator = function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t3[0] & 1)
            throw t3[1];
          return t3[1];
        }, trys: [], ops: [] }, f3, y2, t3, g2;
        return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
          return this;
        }), g2;
        function verb(n2) {
          return function(v2) {
            return step([n2, v2]);
          };
        }
        function step(op) {
          if (f3)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f3 = 1, y2 && (t3 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t3 = y2["return"]) && t3.call(y2), 0) : y2.next) && !(t3 = t3.call(y2, op[1])).done)
                return t3;
              if (y2 = 0, t3)
                op = [op[0] & 2, t3.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t3 = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y2 = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t3 = _.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t3[1]) {
                    _.label = t3[1];
                    t3 = op;
                    break;
                  }
                  if (t3 && _.label < t3[2]) {
                    _.label = t3[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t3[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e3) {
              op = [6, e3];
              y2 = 0;
            } finally {
              f3 = t3 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __createBinding = function(o3, m2, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        o3[k22] = m2[k2];
      };
      __exportStar = function(m2, exports2) {
        for (var p2 in m2)
          if (p2 !== "default" && !exports2.hasOwnProperty(p2))
            exports2[p2] = m2[p2];
      };
      __values = function(o3) {
        var s3 = typeof Symbol === "function" && Symbol.iterator, m2 = s3 && o3[s3], i3 = 0;
        if (m2)
          return m2.call(o3);
        if (o3 && typeof o3.length === "number")
          return {
            next: function() {
              if (o3 && i3 >= o3.length)
                o3 = void 0;
              return { value: o3 && o3[i3++], done: !o3 };
            }
          };
        throw new TypeError(s3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read = function(o3, n2) {
        var m2 = typeof Symbol === "function" && o3[Symbol.iterator];
        if (!m2)
          return o3;
        var i3 = m2.call(o3), r3, ar2 = [], e3;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r3 = i3.next()).done)
            ar2.push(r3.value);
        } catch (error) {
          e3 = { error };
        } finally {
          try {
            if (r3 && !r3.done && (m2 = i3["return"]))
              m2.call(i3);
          } finally {
            if (e3)
              throw e3.error;
          }
        }
        return ar2;
      };
      __spread = function() {
        for (var ar2 = [], i3 = 0; i3 < arguments.length; i3++)
          ar2 = ar2.concat(__read(arguments[i3]));
        return ar2;
      };
      __spreadArrays = function() {
        for (var s3 = 0, i3 = 0, il = arguments.length; i3 < il; i3++)
          s3 += arguments[i3].length;
        for (var r3 = Array(s3), k2 = 0, i3 = 0; i3 < il; i3++)
          for (var a3 = arguments[i3], j2 = 0, jl = a3.length; j2 < jl; j2++, k2++)
            r3[k2] = a3[j2];
        return r3;
      };
      __await = function(v2) {
        return this instanceof __await ? (this.v = v2, this) : new __await(v2);
      };
      __asyncGenerator = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g2 = generator.apply(thisArg, _arguments || []), i3, q2 = [];
        return i3 = {}, verb("next"), verb("throw"), verb("return"), i3[Symbol.asyncIterator] = function() {
          return this;
        }, i3;
        function verb(n2) {
          if (g2[n2])
            i3[n2] = function(v2) {
              return new Promise(function(a3, b2) {
                q2.push([n2, v2, a3, b2]) > 1 || resume(n2, v2);
              });
            };
        }
        function resume(n2, v2) {
          try {
            step(g2[n2](v2));
          } catch (e3) {
            settle(q2[0][3], e3);
          }
        }
        function step(r3) {
          r3.value instanceof __await ? Promise.resolve(r3.value.v).then(fulfill, reject) : settle(q2[0][2], r3);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f3, v2) {
          if (f3(v2), q2.shift(), q2.length)
            resume(q2[0][0], q2[0][1]);
        }
      };
      __asyncDelegator = function(o3) {
        var i3, p2;
        return i3 = {}, verb("next"), verb("throw", function(e3) {
          throw e3;
        }), verb("return"), i3[Symbol.iterator] = function() {
          return this;
        }, i3;
        function verb(n2, f3) {
          i3[n2] = o3[n2] ? function(v2) {
            return (p2 = !p2) ? { value: __await(o3[n2](v2)), done: n2 === "return" } : f3 ? f3(v2) : v2;
          } : f3;
        }
      };
      __asyncValues = function(o3) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m2 = o3[Symbol.asyncIterator], i3;
        return m2 ? m2.call(o3) : (o3 = typeof __values === "function" ? __values(o3) : o3[Symbol.iterator](), i3 = {}, verb("next"), verb("throw"), verb("return"), i3[Symbol.asyncIterator] = function() {
          return this;
        }, i3);
        function verb(n2) {
          i3[n2] = o3[n2] && function(v2) {
            return new Promise(function(resolve, reject) {
              v2 = o3[n2](v2), settle(resolve, reject, v2.done, v2.value);
            });
          };
        }
        function settle(resolve, reject, d2, v2) {
          Promise.resolve(v2).then(function(v3) {
            resolve({ value: v3, done: d2 });
          }, reject);
        }
      };
      __makeTemplateObject = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      __importStar = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k2 in mod)
            if (Object.hasOwnProperty.call(mod, k2))
              result[k2] = mod[k2];
        }
        result["default"] = mod;
        return result;
      };
      __importDefault = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet = function(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
      };
      __classPrivateFieldSet = function(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
      };
      exporter("__extends", __extends);
      exporter("__assign", __assign);
      exporter("__rest", __rest);
      exporter("__decorate", __decorate);
      exporter("__param", __param);
      exporter("__metadata", __metadata);
      exporter("__awaiter", __awaiter);
      exporter("__generator", __generator);
      exporter("__exportStar", __exportStar);
      exporter("__createBinding", __createBinding);
      exporter("__values", __values);
      exporter("__read", __read);
      exporter("__spread", __spread);
      exporter("__spreadArrays", __spreadArrays);
      exporter("__await", __await);
      exporter("__asyncGenerator", __asyncGenerator);
      exporter("__asyncDelegator", __asyncDelegator);
      exporter("__asyncValues", __asyncValues);
      exporter("__makeTemplateObject", __makeTemplateObject);
      exporter("__importStar", __importStar);
      exporter("__importDefault", __importDefault);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    });
  }
});

// node_modules/@aws-crypto/crc32c/build/aws_crc32c.js
var require_aws_crc32c = __commonJS({
  "node_modules/@aws-crypto/crc32c/build/aws_crc32c.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AwsCrc32c = void 0;
    var tslib_1 = require_tslib2();
    var util_1 = require_build();
    var index_1 = require_build3();
    var AwsCrc32c2 = function() {
      function AwsCrc32c3() {
        this.crc32c = new index_1.Crc32c();
      }
      AwsCrc32c3.prototype.update = function(toHash) {
        if ((0, util_1.isEmptyData)(toHash))
          return;
        this.crc32c.update((0, util_1.convertToBuffer)(toHash));
      };
      AwsCrc32c3.prototype.digest = function() {
        return tslib_1.__awaiter(this, void 0, void 0, function() {
          return tslib_1.__generator(this, function(_a) {
            return [2, (0, util_1.numToUint8)(this.crc32c.digest())];
          });
        });
      };
      AwsCrc32c3.prototype.reset = function() {
        this.crc32c = new index_1.Crc32c();
      };
      return AwsCrc32c3;
    }();
    exports.AwsCrc32c = AwsCrc32c2;
  }
});

// node_modules/@aws-crypto/crc32c/build/index.js
var require_build3 = __commonJS({
  "node_modules/@aws-crypto/crc32c/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AwsCrc32c = exports.Crc32c = exports.crc32c = void 0;
    var tslib_1 = require_tslib2();
    var util_1 = require_build();
    function crc32c(data) {
      return new Crc32c().update(data).digest();
    }
    exports.crc32c = crc32c;
    var Crc32c = function() {
      function Crc32c2() {
        this.checksum = 4294967295;
      }
      Crc32c2.prototype.update = function(data) {
        var e_1, _a;
        try {
          for (var data_1 = tslib_1.__values(data), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {
            var byte = data_1_1.value;
            this.checksum = this.checksum >>> 8 ^ lookupTable[(this.checksum ^ byte) & 255];
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (data_1_1 && !data_1_1.done && (_a = data_1.return))
              _a.call(data_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        return this;
      };
      Crc32c2.prototype.digest = function() {
        return (this.checksum ^ 4294967295) >>> 0;
      };
      return Crc32c2;
    }();
    exports.Crc32c = Crc32c;
    var a_lookupTable = [
      0,
      4067132163,
      3778769143,
      324072436,
      3348797215,
      904991772,
      648144872,
      3570033899,
      2329499855,
      2024987596,
      1809983544,
      2575936315,
      1296289744,
      3207089363,
      2893594407,
      1578318884,
      274646895,
      3795141740,
      4049975192,
      51262619,
      3619967088,
      632279923,
      922689671,
      3298075524,
      2592579488,
      1760304291,
      2075979607,
      2312596564,
      1562183871,
      2943781820,
      3156637768,
      1313733451,
      549293790,
      3537243613,
      3246849577,
      871202090,
      3878099393,
      357341890,
      102525238,
      4101499445,
      2858735121,
      1477399826,
      1264559846,
      3107202533,
      1845379342,
      2677391885,
      2361733625,
      2125378298,
      820201905,
      3263744690,
      3520608582,
      598981189,
      4151959214,
      85089709,
      373468761,
      3827903834,
      3124367742,
      1213305469,
      1526817161,
      2842354314,
      2107672161,
      2412447074,
      2627466902,
      1861252501,
      1098587580,
      3004210879,
      2688576843,
      1378610760,
      2262928035,
      1955203488,
      1742404180,
      2511436119,
      3416409459,
      969524848,
      714683780,
      3639785095,
      205050476,
      4266873199,
      3976438427,
      526918040,
      1361435347,
      2739821008,
      2954799652,
      1114974503,
      2529119692,
      1691668175,
      2005155131,
      2247081528,
      3690758684,
      697762079,
      986182379,
      3366744552,
      476452099,
      3993867776,
      4250756596,
      255256311,
      1640403810,
      2477592673,
      2164122517,
      1922457750,
      2791048317,
      1412925310,
      1197962378,
      3037525897,
      3944729517,
      427051182,
      170179418,
      4165941337,
      746937522,
      3740196785,
      3451792453,
      1070968646,
      1905808397,
      2213795598,
      2426610938,
      1657317369,
      3053634322,
      1147748369,
      1463399397,
      2773627110,
      4215344322,
      153784257,
      444234805,
      3893493558,
      1021025245,
      3467647198,
      3722505002,
      797665321,
      2197175160,
      1889384571,
      1674398607,
      2443626636,
      1164749927,
      3070701412,
      2757221520,
      1446797203,
      137323447,
      4198817972,
      3910406976,
      461344835,
      3484808360,
      1037989803,
      781091935,
      3705997148,
      2460548119,
      1623424788,
      1939049696,
      2180517859,
      1429367560,
      2807687179,
      3020495871,
      1180866812,
      410100952,
      3927582683,
      4182430767,
      186734380,
      3756733383,
      763408580,
      1053836080,
      3434856499,
      2722870694,
      1344288421,
      1131464017,
      2971354706,
      1708204729,
      2545590714,
      2229949006,
      1988219213,
      680717673,
      3673779818,
      3383336350,
      1002577565,
      4010310262,
      493091189,
      238226049,
      4233660802,
      2987750089,
      1082061258,
      1395524158,
      2705686845,
      1972364758,
      2279892693,
      2494862625,
      1725896226,
      952904198,
      3399985413,
      3656866545,
      731699698,
      4283874585,
      222117402,
      510512622,
      3959836397,
      3280807620,
      837199303,
      582374963,
      3504198960,
      68661723,
      4135334616,
      3844915500,
      390545967,
      1230274059,
      3141532936,
      2825850620,
      1510247935,
      2395924756,
      2091215383,
      1878366691,
      2644384480,
      3553878443,
      565732008,
      854102364,
      3229815391,
      340358836,
      3861050807,
      4117890627,
      119113024,
      1493875044,
      2875275879,
      3090270611,
      1247431312,
      2660249211,
      1828433272,
      2141937292,
      2378227087,
      3811616794,
      291187481,
      34330861,
      4032846830,
      615137029,
      3603020806,
      3314634738,
      939183345,
      1776939221,
      2609017814,
      2295496738,
      2058945313,
      2926798794,
      1545135305,
      1330124605,
      3173225534,
      4084100981,
      17165430,
      307568514,
      3762199681,
      888469610,
      3332340585,
      3587147933,
      665062302,
      2042050490,
      2346497209,
      2559330125,
      1793573966,
      3190661285,
      1279665062,
      1595330642,
      2910671697
    ];
    var lookupTable = (0, util_1.uint32ArrayFrom)(a_lookupTable);
    var aws_crc32c_1 = require_aws_crc32c();
    Object.defineProperty(exports, "AwsCrc32c", { enumerable: true, get: function() {
      return aws_crc32c_1.AwsCrc32c;
    } });
  }
});

// node_modules/@aws-crypto/sha1-browser/node_modules/tslib/tslib.js
var require_tslib3 = __commonJS({
  "node_modules/@aws-crypto/sha1-browser/node_modules/tslib/tslib.js"(exports, module2) {
    var __extends;
    var __assign;
    var __rest;
    var __decorate;
    var __param;
    var __metadata;
    var __awaiter;
    var __generator;
    var __exportStar;
    var __values;
    var __read;
    var __spread;
    var __spreadArrays;
    var __await;
    var __asyncGenerator;
    var __asyncDelegator;
    var __asyncValues;
    var __makeTemplateObject;
    var __importStar;
    var __importDefault;
    var __classPrivateFieldGet;
    var __classPrivateFieldSet;
    var __createBinding;
    (function(factory) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports2) {
          factory(createExporter(root, createExporter(exports2)));
        });
      } else if (typeof module2 === "object" && typeof module2.exports === "object") {
        factory(createExporter(root, createExporter(module2.exports)));
      } else {
        factory(createExporter(root));
      }
      function createExporter(exports2, previous) {
        if (exports2 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports2, "__esModule", { value: true });
          } else {
            exports2.__esModule = true;
          }
        }
        return function(id, v2) {
          return exports2[id] = previous ? previous(id, v2) : v2;
        };
      }
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p2 in b2)
          if (b2.hasOwnProperty(p2))
            d2[p2] = b2[p2];
      };
      __extends = function(d2, b2) {
        extendStatics(d2, b2);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
      __assign = Object.assign || function(t3) {
        for (var s3, i3 = 1, n2 = arguments.length; i3 < n2; i3++) {
          s3 = arguments[i3];
          for (var p2 in s3)
            if (Object.prototype.hasOwnProperty.call(s3, p2))
              t3[p2] = s3[p2];
        }
        return t3;
      };
      __rest = function(s3, e3) {
        var t3 = {};
        for (var p2 in s3)
          if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
            t3[p2] = s3[p2];
        if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i3 = 0, p2 = Object.getOwnPropertySymbols(s3); i3 < p2.length; i3++) {
            if (e3.indexOf(p2[i3]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i3]))
              t3[p2[i3]] = s3[p2[i3]];
          }
        return t3;
      };
      __decorate = function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r3 = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i3 = decorators.length - 1; i3 >= 0; i3--)
            if (d2 = decorators[i3])
              r3 = (c3 < 3 ? d2(r3) : c3 > 3 ? d2(target, key, r3) : d2(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      __param = function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      __metadata = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter = function(thisArg, _arguments, P2, generator) {
        function adopt(value) {
          return value instanceof P2 ? value : new P2(function(resolve) {
            resolve(value);
          });
        }
        return new (P2 || (P2 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e3) {
              reject(e3);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e3) {
              reject(e3);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator = function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t3[0] & 1)
            throw t3[1];
          return t3[1];
        }, trys: [], ops: [] }, f3, y2, t3, g2;
        return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
          return this;
        }), g2;
        function verb(n2) {
          return function(v2) {
            return step([n2, v2]);
          };
        }
        function step(op) {
          if (f3)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f3 = 1, y2 && (t3 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t3 = y2["return"]) && t3.call(y2), 0) : y2.next) && !(t3 = t3.call(y2, op[1])).done)
                return t3;
              if (y2 = 0, t3)
                op = [op[0] & 2, t3.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t3 = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y2 = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t3 = _.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t3[1]) {
                    _.label = t3[1];
                    t3 = op;
                    break;
                  }
                  if (t3 && _.label < t3[2]) {
                    _.label = t3[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t3[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e3) {
              op = [6, e3];
              y2 = 0;
            } finally {
              f3 = t3 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __createBinding = function(o3, m2, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        o3[k22] = m2[k2];
      };
      __exportStar = function(m2, exports2) {
        for (var p2 in m2)
          if (p2 !== "default" && !exports2.hasOwnProperty(p2))
            exports2[p2] = m2[p2];
      };
      __values = function(o3) {
        var s3 = typeof Symbol === "function" && Symbol.iterator, m2 = s3 && o3[s3], i3 = 0;
        if (m2)
          return m2.call(o3);
        if (o3 && typeof o3.length === "number")
          return {
            next: function() {
              if (o3 && i3 >= o3.length)
                o3 = void 0;
              return { value: o3 && o3[i3++], done: !o3 };
            }
          };
        throw new TypeError(s3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read = function(o3, n2) {
        var m2 = typeof Symbol === "function" && o3[Symbol.iterator];
        if (!m2)
          return o3;
        var i3 = m2.call(o3), r3, ar2 = [], e3;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r3 = i3.next()).done)
            ar2.push(r3.value);
        } catch (error) {
          e3 = { error };
        } finally {
          try {
            if (r3 && !r3.done && (m2 = i3["return"]))
              m2.call(i3);
          } finally {
            if (e3)
              throw e3.error;
          }
        }
        return ar2;
      };
      __spread = function() {
        for (var ar2 = [], i3 = 0; i3 < arguments.length; i3++)
          ar2 = ar2.concat(__read(arguments[i3]));
        return ar2;
      };
      __spreadArrays = function() {
        for (var s3 = 0, i3 = 0, il = arguments.length; i3 < il; i3++)
          s3 += arguments[i3].length;
        for (var r3 = Array(s3), k2 = 0, i3 = 0; i3 < il; i3++)
          for (var a3 = arguments[i3], j2 = 0, jl = a3.length; j2 < jl; j2++, k2++)
            r3[k2] = a3[j2];
        return r3;
      };
      __await = function(v2) {
        return this instanceof __await ? (this.v = v2, this) : new __await(v2);
      };
      __asyncGenerator = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g2 = generator.apply(thisArg, _arguments || []), i3, q2 = [];
        return i3 = {}, verb("next"), verb("throw"), verb("return"), i3[Symbol.asyncIterator] = function() {
          return this;
        }, i3;
        function verb(n2) {
          if (g2[n2])
            i3[n2] = function(v2) {
              return new Promise(function(a3, b2) {
                q2.push([n2, v2, a3, b2]) > 1 || resume(n2, v2);
              });
            };
        }
        function resume(n2, v2) {
          try {
            step(g2[n2](v2));
          } catch (e3) {
            settle(q2[0][3], e3);
          }
        }
        function step(r3) {
          r3.value instanceof __await ? Promise.resolve(r3.value.v).then(fulfill, reject) : settle(q2[0][2], r3);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f3, v2) {
          if (f3(v2), q2.shift(), q2.length)
            resume(q2[0][0], q2[0][1]);
        }
      };
      __asyncDelegator = function(o3) {
        var i3, p2;
        return i3 = {}, verb("next"), verb("throw", function(e3) {
          throw e3;
        }), verb("return"), i3[Symbol.iterator] = function() {
          return this;
        }, i3;
        function verb(n2, f3) {
          i3[n2] = o3[n2] ? function(v2) {
            return (p2 = !p2) ? { value: __await(o3[n2](v2)), done: n2 === "return" } : f3 ? f3(v2) : v2;
          } : f3;
        }
      };
      __asyncValues = function(o3) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m2 = o3[Symbol.asyncIterator], i3;
        return m2 ? m2.call(o3) : (o3 = typeof __values === "function" ? __values(o3) : o3[Symbol.iterator](), i3 = {}, verb("next"), verb("throw"), verb("return"), i3[Symbol.asyncIterator] = function() {
          return this;
        }, i3);
        function verb(n2) {
          i3[n2] = o3[n2] && function(v2) {
            return new Promise(function(resolve, reject) {
              v2 = o3[n2](v2), settle(resolve, reject, v2.done, v2.value);
            });
          };
        }
        function settle(resolve, reject, d2, v2) {
          Promise.resolve(v2).then(function(v3) {
            resolve({ value: v3, done: d2 });
          }, reject);
        }
      };
      __makeTemplateObject = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      __importStar = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k2 in mod)
            if (Object.hasOwnProperty.call(mod, k2))
              result[k2] = mod[k2];
        }
        result["default"] = mod;
        return result;
      };
      __importDefault = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet = function(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
      };
      __classPrivateFieldSet = function(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
      };
      exporter("__extends", __extends);
      exporter("__assign", __assign);
      exporter("__rest", __rest);
      exporter("__decorate", __decorate);
      exporter("__param", __param);
      exporter("__metadata", __metadata);
      exporter("__awaiter", __awaiter);
      exporter("__generator", __generator);
      exporter("__exportStar", __exportStar);
      exporter("__createBinding", __createBinding);
      exporter("__values", __values);
      exporter("__read", __read);
      exporter("__spread", __spread);
      exporter("__spreadArrays", __spreadArrays);
      exporter("__await", __await);
      exporter("__asyncGenerator", __asyncGenerator);
      exporter("__asyncDelegator", __asyncDelegator);
      exporter("__asyncValues", __asyncValues);
      exporter("__makeTemplateObject", __makeTemplateObject);
      exporter("__importStar", __importStar);
      exporter("__importDefault", __importDefault);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    });
  }
});

// node_modules/@aws-crypto/sha1-browser/build/isEmptyData.js
var require_isEmptyData2 = __commonJS({
  "node_modules/@aws-crypto/sha1-browser/build/isEmptyData.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isEmptyData = void 0;
    function isEmptyData2(data) {
      if (typeof data === "string") {
        return data.length === 0;
      }
      return data.byteLength === 0;
    }
    exports.isEmptyData = isEmptyData2;
  }
});

// node_modules/@aws-crypto/sha1-browser/build/constants.js
var require_constants = __commonJS({
  "node_modules/@aws-crypto/sha1-browser/build/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EMPTY_DATA_SHA_1 = exports.SHA_1_HMAC_ALGO = exports.SHA_1_HASH = void 0;
    exports.SHA_1_HASH = { name: "SHA-1" };
    exports.SHA_1_HMAC_ALGO = {
      name: "HMAC",
      hash: exports.SHA_1_HASH
    };
    exports.EMPTY_DATA_SHA_1 = new Uint8Array([
      218,
      57,
      163,
      238,
      94,
      107,
      75,
      13,
      50,
      85,
      191,
      239,
      149,
      96,
      24,
      144,
      175,
      216,
      7,
      9
    ]);
  }
});

// node_modules/@aws-sdk/util-locate-window/dist-cjs/index.js
var require_dist_cjs2 = __commonJS({
  "node_modules/@aws-sdk/util-locate-window/dist-cjs/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.locateWindow = void 0;
    var fallbackWindow = {};
    function locateWindow() {
      if (typeof window !== "undefined") {
        return window;
      } else if (typeof self !== "undefined") {
        return self;
      }
      return fallbackWindow;
    }
    exports.locateWindow = locateWindow;
  }
});

// node_modules/@aws-crypto/sha1-browser/build/ie11Sha1.js
var require_ie11Sha1 = __commonJS({
  "node_modules/@aws-crypto/sha1-browser/build/ie11Sha1.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Sha1 = void 0;
    var isEmptyData_1 = require_isEmptyData2();
    var constants_1 = require_constants();
    var util_utf8_browser_1 = require_dist_cjs();
    var util_locate_window_1 = require_dist_cjs2();
    var Sha12 = function() {
      function Sha13(secret) {
        this.secret = secret;
        this.reset();
      }
      Sha13.prototype.update = function(toHash) {
        var _this = this;
        if ((0, isEmptyData_1.isEmptyData)(toHash)) {
          return;
        }
        this.operation = this.operation.then(function(operation) {
          operation.onerror = function() {
            _this.operation = Promise.reject(new Error("Error encountered updating hash"));
          };
          operation.process(toArrayBufferView(toHash));
          return operation;
        });
        this.operation.catch(function() {
        });
      };
      Sha13.prototype.digest = function() {
        return this.operation.then(function(operation) {
          return new Promise(function(resolve, reject) {
            operation.onerror = function() {
              reject(new Error("Error encountered finalizing hash"));
            };
            operation.oncomplete = function() {
              if (operation.result) {
                resolve(new Uint8Array(operation.result));
              }
              reject(new Error("Error encountered finalizing hash"));
            };
            operation.finish();
          });
        });
      };
      Sha13.prototype.reset = function() {
        if (this.secret) {
          this.operation = getKeyPromise(this.secret).then(function(keyData) {
            return (0, util_locate_window_1.locateWindow)().msCrypto.subtle.sign(constants_1.SHA_1_HMAC_ALGO, keyData);
          });
          this.operation.catch(function() {
          });
        } else {
          this.operation = Promise.resolve((0, util_locate_window_1.locateWindow)().msCrypto.subtle.digest("SHA-1"));
        }
      };
      return Sha13;
    }();
    exports.Sha1 = Sha12;
    function getKeyPromise(secret) {
      return new Promise(function(resolve, reject) {
        var keyOperation = (0, util_locate_window_1.locateWindow)().msCrypto.subtle.importKey("raw", toArrayBufferView(secret), constants_1.SHA_1_HMAC_ALGO, false, ["sign"]);
        keyOperation.oncomplete = function() {
          if (keyOperation.result) {
            resolve(keyOperation.result);
          }
          reject(new Error("ImportKey completed without importing key."));
        };
        keyOperation.onerror = function() {
          reject(new Error("ImportKey failed to import key."));
        };
      });
    }
    function toArrayBufferView(data) {
      if (typeof data === "string") {
        return (0, util_utf8_browser_1.fromUtf8)(data);
      }
      if (ArrayBuffer.isView(data)) {
        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
      }
      return new Uint8Array(data);
    }
  }
});

// node_modules/@aws-crypto/sha1-browser/build/webCryptoSha1.js
var require_webCryptoSha1 = __commonJS({
  "node_modules/@aws-crypto/sha1-browser/build/webCryptoSha1.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Sha1 = void 0;
    var util_utf8_browser_1 = require_dist_cjs();
    var isEmptyData_1 = require_isEmptyData2();
    var constants_1 = require_constants();
    var util_locate_window_1 = require_dist_cjs2();
    var Sha12 = function() {
      function Sha13(secret) {
        this.toHash = new Uint8Array(0);
        if (secret !== void 0) {
          this.key = new Promise(function(resolve, reject) {
            (0, util_locate_window_1.locateWindow)().crypto.subtle.importKey("raw", convertToBuffer2(secret), constants_1.SHA_1_HMAC_ALGO, false, ["sign"]).then(resolve, reject);
          });
          this.key.catch(function() {
          });
        }
      }
      Sha13.prototype.update = function(data) {
        if ((0, isEmptyData_1.isEmptyData)(data)) {
          return;
        }
        var update = convertToBuffer2(data);
        var typedArray = new Uint8Array(this.toHash.byteLength + update.byteLength);
        typedArray.set(this.toHash, 0);
        typedArray.set(update, this.toHash.byteLength);
        this.toHash = typedArray;
      };
      Sha13.prototype.digest = function() {
        var _this = this;
        if (this.key) {
          return this.key.then(function(key) {
            return (0, util_locate_window_1.locateWindow)().crypto.subtle.sign(constants_1.SHA_1_HMAC_ALGO, key, _this.toHash).then(function(data) {
              return new Uint8Array(data);
            });
          });
        }
        if ((0, isEmptyData_1.isEmptyData)(this.toHash)) {
          return Promise.resolve(constants_1.EMPTY_DATA_SHA_1);
        }
        return Promise.resolve().then(function() {
          return (0, util_locate_window_1.locateWindow)().crypto.subtle.digest(constants_1.SHA_1_HASH, _this.toHash);
        }).then(function(data) {
          return Promise.resolve(new Uint8Array(data));
        });
      };
      Sha13.prototype.reset = function() {
        this.toHash = new Uint8Array(0);
      };
      return Sha13;
    }();
    exports.Sha1 = Sha12;
    function convertToBuffer2(data) {
      if (typeof data === "string") {
        return (0, util_utf8_browser_1.fromUtf8)(data);
      }
      if (ArrayBuffer.isView(data)) {
        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
      }
      return new Uint8Array(data);
    }
  }
});

// node_modules/@aws-crypto/supports-web-crypto/node_modules/tslib/tslib.js
var require_tslib4 = __commonJS({
  "node_modules/@aws-crypto/supports-web-crypto/node_modules/tslib/tslib.js"(exports, module2) {
    var __extends;
    var __assign;
    var __rest;
    var __decorate;
    var __param;
    var __metadata;
    var __awaiter;
    var __generator;
    var __exportStar;
    var __values;
    var __read;
    var __spread;
    var __spreadArrays;
    var __await;
    var __asyncGenerator;
    var __asyncDelegator;
    var __asyncValues;
    var __makeTemplateObject;
    var __importStar;
    var __importDefault;
    var __classPrivateFieldGet;
    var __classPrivateFieldSet;
    var __createBinding;
    (function(factory) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports2) {
          factory(createExporter(root, createExporter(exports2)));
        });
      } else if (typeof module2 === "object" && typeof module2.exports === "object") {
        factory(createExporter(root, createExporter(module2.exports)));
      } else {
        factory(createExporter(root));
      }
      function createExporter(exports2, previous) {
        if (exports2 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports2, "__esModule", { value: true });
          } else {
            exports2.__esModule = true;
          }
        }
        return function(id, v2) {
          return exports2[id] = previous ? previous(id, v2) : v2;
        };
      }
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p2 in b2)
          if (b2.hasOwnProperty(p2))
            d2[p2] = b2[p2];
      };
      __extends = function(d2, b2) {
        extendStatics(d2, b2);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
      __assign = Object.assign || function(t3) {
        for (var s3, i3 = 1, n2 = arguments.length; i3 < n2; i3++) {
          s3 = arguments[i3];
          for (var p2 in s3)
            if (Object.prototype.hasOwnProperty.call(s3, p2))
              t3[p2] = s3[p2];
        }
        return t3;
      };
      __rest = function(s3, e3) {
        var t3 = {};
        for (var p2 in s3)
          if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
            t3[p2] = s3[p2];
        if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i3 = 0, p2 = Object.getOwnPropertySymbols(s3); i3 < p2.length; i3++) {
            if (e3.indexOf(p2[i3]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i3]))
              t3[p2[i3]] = s3[p2[i3]];
          }
        return t3;
      };
      __decorate = function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r3 = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i3 = decorators.length - 1; i3 >= 0; i3--)
            if (d2 = decorators[i3])
              r3 = (c3 < 3 ? d2(r3) : c3 > 3 ? d2(target, key, r3) : d2(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      __param = function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      __metadata = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter = function(thisArg, _arguments, P2, generator) {
        function adopt(value) {
          return value instanceof P2 ? value : new P2(function(resolve) {
            resolve(value);
          });
        }
        return new (P2 || (P2 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e3) {
              reject(e3);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e3) {
              reject(e3);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator = function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t3[0] & 1)
            throw t3[1];
          return t3[1];
        }, trys: [], ops: [] }, f3, y2, t3, g2;
        return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
          return this;
        }), g2;
        function verb(n2) {
          return function(v2) {
            return step([n2, v2]);
          };
        }
        function step(op) {
          if (f3)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f3 = 1, y2 && (t3 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t3 = y2["return"]) && t3.call(y2), 0) : y2.next) && !(t3 = t3.call(y2, op[1])).done)
                return t3;
              if (y2 = 0, t3)
                op = [op[0] & 2, t3.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t3 = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y2 = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t3 = _.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t3[1]) {
                    _.label = t3[1];
                    t3 = op;
                    break;
                  }
                  if (t3 && _.label < t3[2]) {
                    _.label = t3[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t3[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e3) {
              op = [6, e3];
              y2 = 0;
            } finally {
              f3 = t3 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __createBinding = function(o3, m2, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        o3[k22] = m2[k2];
      };
      __exportStar = function(m2, exports2) {
        for (var p2 in m2)
          if (p2 !== "default" && !exports2.hasOwnProperty(p2))
            exports2[p2] = m2[p2];
      };
      __values = function(o3) {
        var s3 = typeof Symbol === "function" && Symbol.iterator, m2 = s3 && o3[s3], i3 = 0;
        if (m2)
          return m2.call(o3);
        if (o3 && typeof o3.length === "number")
          return {
            next: function() {
              if (o3 && i3 >= o3.length)
                o3 = void 0;
              return { value: o3 && o3[i3++], done: !o3 };
            }
          };
        throw new TypeError(s3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read = function(o3, n2) {
        var m2 = typeof Symbol === "function" && o3[Symbol.iterator];
        if (!m2)
          return o3;
        var i3 = m2.call(o3), r3, ar2 = [], e3;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r3 = i3.next()).done)
            ar2.push(r3.value);
        } catch (error) {
          e3 = { error };
        } finally {
          try {
            if (r3 && !r3.done && (m2 = i3["return"]))
              m2.call(i3);
          } finally {
            if (e3)
              throw e3.error;
          }
        }
        return ar2;
      };
      __spread = function() {
        for (var ar2 = [], i3 = 0; i3 < arguments.length; i3++)
          ar2 = ar2.concat(__read(arguments[i3]));
        return ar2;
      };
      __spreadArrays = function() {
        for (var s3 = 0, i3 = 0, il = arguments.length; i3 < il; i3++)
          s3 += arguments[i3].length;
        for (var r3 = Array(s3), k2 = 0, i3 = 0; i3 < il; i3++)
          for (var a3 = arguments[i3], j2 = 0, jl = a3.length; j2 < jl; j2++, k2++)
            r3[k2] = a3[j2];
        return r3;
      };
      __await = function(v2) {
        return this instanceof __await ? (this.v = v2, this) : new __await(v2);
      };
      __asyncGenerator = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g2 = generator.apply(thisArg, _arguments || []), i3, q2 = [];
        return i3 = {}, verb("next"), verb("throw"), verb("return"), i3[Symbol.asyncIterator] = function() {
          return this;
        }, i3;
        function verb(n2) {
          if (g2[n2])
            i3[n2] = function(v2) {
              return new Promise(function(a3, b2) {
                q2.push([n2, v2, a3, b2]) > 1 || resume(n2, v2);
              });
            };
        }
        function resume(n2, v2) {
          try {
            step(g2[n2](v2));
          } catch (e3) {
            settle(q2[0][3], e3);
          }
        }
        function step(r3) {
          r3.value instanceof __await ? Promise.resolve(r3.value.v).then(fulfill, reject) : settle(q2[0][2], r3);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f3, v2) {
          if (f3(v2), q2.shift(), q2.length)
            resume(q2[0][0], q2[0][1]);
        }
      };
      __asyncDelegator = function(o3) {
        var i3, p2;
        return i3 = {}, verb("next"), verb("throw", function(e3) {
          throw e3;
        }), verb("return"), i3[Symbol.iterator] = function() {
          return this;
        }, i3;
        function verb(n2, f3) {
          i3[n2] = o3[n2] ? function(v2) {
            return (p2 = !p2) ? { value: __await(o3[n2](v2)), done: n2 === "return" } : f3 ? f3(v2) : v2;
          } : f3;
        }
      };
      __asyncValues = function(o3) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m2 = o3[Symbol.asyncIterator], i3;
        return m2 ? m2.call(o3) : (o3 = typeof __values === "function" ? __values(o3) : o3[Symbol.iterator](), i3 = {}, verb("next"), verb("throw"), verb("return"), i3[Symbol.asyncIterator] = function() {
          return this;
        }, i3);
        function verb(n2) {
          i3[n2] = o3[n2] && function(v2) {
            return new Promise(function(resolve, reject) {
              v2 = o3[n2](v2), settle(resolve, reject, v2.done, v2.value);
            });
          };
        }
        function settle(resolve, reject, d2, v2) {
          Promise.resolve(v2).then(function(v3) {
            resolve({ value: v3, done: d2 });
          }, reject);
        }
      };
      __makeTemplateObject = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      __importStar = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k2 in mod)
            if (Object.hasOwnProperty.call(mod, k2))
              result[k2] = mod[k2];
        }
        result["default"] = mod;
        return result;
      };
      __importDefault = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet = function(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
      };
      __classPrivateFieldSet = function(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
      };
      exporter("__extends", __extends);
      exporter("__assign", __assign);
      exporter("__rest", __rest);
      exporter("__decorate", __decorate);
      exporter("__param", __param);
      exporter("__metadata", __metadata);
      exporter("__awaiter", __awaiter);
      exporter("__generator", __generator);
      exporter("__exportStar", __exportStar);
      exporter("__createBinding", __createBinding);
      exporter("__values", __values);
      exporter("__read", __read);
      exporter("__spread", __spread);
      exporter("__spreadArrays", __spreadArrays);
      exporter("__await", __await);
      exporter("__asyncGenerator", __asyncGenerator);
      exporter("__asyncDelegator", __asyncDelegator);
      exporter("__asyncValues", __asyncValues);
      exporter("__makeTemplateObject", __makeTemplateObject);
      exporter("__importStar", __importStar);
      exporter("__importDefault", __importDefault);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    });
  }
});

// node_modules/@aws-crypto/supports-web-crypto/build/supportsWebCrypto.js
var require_supportsWebCrypto = __commonJS({
  "node_modules/@aws-crypto/supports-web-crypto/build/supportsWebCrypto.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.supportsZeroByteGCM = exports.supportsSubtleCrypto = exports.supportsSecureRandom = exports.supportsWebCrypto = void 0;
    var tslib_1 = require_tslib4();
    var subtleCryptoMethods = [
      "decrypt",
      "digest",
      "encrypt",
      "exportKey",
      "generateKey",
      "importKey",
      "sign",
      "verify"
    ];
    function supportsWebCrypto(window2) {
      if (supportsSecureRandom(window2) && typeof window2.crypto.subtle === "object") {
        var subtle = window2.crypto.subtle;
        return supportsSubtleCrypto(subtle);
      }
      return false;
    }
    exports.supportsWebCrypto = supportsWebCrypto;
    function supportsSecureRandom(window2) {
      if (typeof window2 === "object" && typeof window2.crypto === "object") {
        var getRandomValues2 = window2.crypto.getRandomValues;
        return typeof getRandomValues2 === "function";
      }
      return false;
    }
    exports.supportsSecureRandom = supportsSecureRandom;
    function supportsSubtleCrypto(subtle) {
      return subtle && subtleCryptoMethods.every(function(methodName) {
        return typeof subtle[methodName] === "function";
      });
    }
    exports.supportsSubtleCrypto = supportsSubtleCrypto;
    function supportsZeroByteGCM(subtle) {
      return tslib_1.__awaiter(this, void 0, void 0, function() {
        var key, zeroByteAuthTag, _a;
        return tslib_1.__generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              if (!supportsSubtleCrypto(subtle))
                return [2, false];
              _b.label = 1;
            case 1:
              _b.trys.push([1, 4, , 5]);
              return [4, subtle.generateKey({ name: "AES-GCM", length: 128 }, false, ["encrypt"])];
            case 2:
              key = _b.sent();
              return [4, subtle.encrypt({
                name: "AES-GCM",
                iv: new Uint8Array(Array(12)),
                additionalData: new Uint8Array(Array(16)),
                tagLength: 128
              }, key, new Uint8Array(0))];
            case 3:
              zeroByteAuthTag = _b.sent();
              return [2, zeroByteAuthTag.byteLength === 16];
            case 4:
              _a = _b.sent();
              return [2, false];
            case 5:
              return [2];
          }
        });
      });
    }
    exports.supportsZeroByteGCM = supportsZeroByteGCM;
  }
});

// node_modules/@aws-crypto/supports-web-crypto/build/index.js
var require_build4 = __commonJS({
  "node_modules/@aws-crypto/supports-web-crypto/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib4();
    tslib_1.__exportStar(require_supportsWebCrypto(), exports);
  }
});

// node_modules/@aws-crypto/ie11-detection/node_modules/tslib/tslib.js
var require_tslib5 = __commonJS({
  "node_modules/@aws-crypto/ie11-detection/node_modules/tslib/tslib.js"(exports, module2) {
    var __extends;
    var __assign;
    var __rest;
    var __decorate;
    var __param;
    var __metadata;
    var __awaiter;
    var __generator;
    var __exportStar;
    var __values;
    var __read;
    var __spread;
    var __spreadArrays;
    var __await;
    var __asyncGenerator;
    var __asyncDelegator;
    var __asyncValues;
    var __makeTemplateObject;
    var __importStar;
    var __importDefault;
    var __classPrivateFieldGet;
    var __classPrivateFieldSet;
    var __createBinding;
    (function(factory) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports2) {
          factory(createExporter(root, createExporter(exports2)));
        });
      } else if (typeof module2 === "object" && typeof module2.exports === "object") {
        factory(createExporter(root, createExporter(module2.exports)));
      } else {
        factory(createExporter(root));
      }
      function createExporter(exports2, previous) {
        if (exports2 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports2, "__esModule", { value: true });
          } else {
            exports2.__esModule = true;
          }
        }
        return function(id, v2) {
          return exports2[id] = previous ? previous(id, v2) : v2;
        };
      }
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p2 in b2)
          if (b2.hasOwnProperty(p2))
            d2[p2] = b2[p2];
      };
      __extends = function(d2, b2) {
        extendStatics(d2, b2);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
      __assign = Object.assign || function(t3) {
        for (var s3, i3 = 1, n2 = arguments.length; i3 < n2; i3++) {
          s3 = arguments[i3];
          for (var p2 in s3)
            if (Object.prototype.hasOwnProperty.call(s3, p2))
              t3[p2] = s3[p2];
        }
        return t3;
      };
      __rest = function(s3, e3) {
        var t3 = {};
        for (var p2 in s3)
          if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
            t3[p2] = s3[p2];
        if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i3 = 0, p2 = Object.getOwnPropertySymbols(s3); i3 < p2.length; i3++) {
            if (e3.indexOf(p2[i3]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i3]))
              t3[p2[i3]] = s3[p2[i3]];
          }
        return t3;
      };
      __decorate = function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r3 = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i3 = decorators.length - 1; i3 >= 0; i3--)
            if (d2 = decorators[i3])
              r3 = (c3 < 3 ? d2(r3) : c3 > 3 ? d2(target, key, r3) : d2(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      __param = function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      __metadata = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter = function(thisArg, _arguments, P2, generator) {
        function adopt(value) {
          return value instanceof P2 ? value : new P2(function(resolve) {
            resolve(value);
          });
        }
        return new (P2 || (P2 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e3) {
              reject(e3);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e3) {
              reject(e3);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator = function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t3[0] & 1)
            throw t3[1];
          return t3[1];
        }, trys: [], ops: [] }, f3, y2, t3, g2;
        return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
          return this;
        }), g2;
        function verb(n2) {
          return function(v2) {
            return step([n2, v2]);
          };
        }
        function step(op) {
          if (f3)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f3 = 1, y2 && (t3 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t3 = y2["return"]) && t3.call(y2), 0) : y2.next) && !(t3 = t3.call(y2, op[1])).done)
                return t3;
              if (y2 = 0, t3)
                op = [op[0] & 2, t3.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t3 = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y2 = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t3 = _.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t3[1]) {
                    _.label = t3[1];
                    t3 = op;
                    break;
                  }
                  if (t3 && _.label < t3[2]) {
                    _.label = t3[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t3[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e3) {
              op = [6, e3];
              y2 = 0;
            } finally {
              f3 = t3 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __createBinding = function(o3, m2, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        o3[k22] = m2[k2];
      };
      __exportStar = function(m2, exports2) {
        for (var p2 in m2)
          if (p2 !== "default" && !exports2.hasOwnProperty(p2))
            exports2[p2] = m2[p2];
      };
      __values = function(o3) {
        var s3 = typeof Symbol === "function" && Symbol.iterator, m2 = s3 && o3[s3], i3 = 0;
        if (m2)
          return m2.call(o3);
        if (o3 && typeof o3.length === "number")
          return {
            next: function() {
              if (o3 && i3 >= o3.length)
                o3 = void 0;
              return { value: o3 && o3[i3++], done: !o3 };
            }
          };
        throw new TypeError(s3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read = function(o3, n2) {
        var m2 = typeof Symbol === "function" && o3[Symbol.iterator];
        if (!m2)
          return o3;
        var i3 = m2.call(o3), r3, ar2 = [], e3;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r3 = i3.next()).done)
            ar2.push(r3.value);
        } catch (error) {
          e3 = { error };
        } finally {
          try {
            if (r3 && !r3.done && (m2 = i3["return"]))
              m2.call(i3);
          } finally {
            if (e3)
              throw e3.error;
          }
        }
        return ar2;
      };
      __spread = function() {
        for (var ar2 = [], i3 = 0; i3 < arguments.length; i3++)
          ar2 = ar2.concat(__read(arguments[i3]));
        return ar2;
      };
      __spreadArrays = function() {
        for (var s3 = 0, i3 = 0, il = arguments.length; i3 < il; i3++)
          s3 += arguments[i3].length;
        for (var r3 = Array(s3), k2 = 0, i3 = 0; i3 < il; i3++)
          for (var a3 = arguments[i3], j2 = 0, jl = a3.length; j2 < jl; j2++, k2++)
            r3[k2] = a3[j2];
        return r3;
      };
      __await = function(v2) {
        return this instanceof __await ? (this.v = v2, this) : new __await(v2);
      };
      __asyncGenerator = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g2 = generator.apply(thisArg, _arguments || []), i3, q2 = [];
        return i3 = {}, verb("next"), verb("throw"), verb("return"), i3[Symbol.asyncIterator] = function() {
          return this;
        }, i3;
        function verb(n2) {
          if (g2[n2])
            i3[n2] = function(v2) {
              return new Promise(function(a3, b2) {
                q2.push([n2, v2, a3, b2]) > 1 || resume(n2, v2);
              });
            };
        }
        function resume(n2, v2) {
          try {
            step(g2[n2](v2));
          } catch (e3) {
            settle(q2[0][3], e3);
          }
        }
        function step(r3) {
          r3.value instanceof __await ? Promise.resolve(r3.value.v).then(fulfill, reject) : settle(q2[0][2], r3);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f3, v2) {
          if (f3(v2), q2.shift(), q2.length)
            resume(q2[0][0], q2[0][1]);
        }
      };
      __asyncDelegator = function(o3) {
        var i3, p2;
        return i3 = {}, verb("next"), verb("throw", function(e3) {
          throw e3;
        }), verb("return"), i3[Symbol.iterator] = function() {
          return this;
        }, i3;
        function verb(n2, f3) {
          i3[n2] = o3[n2] ? function(v2) {
            return (p2 = !p2) ? { value: __await(o3[n2](v2)), done: n2 === "return" } : f3 ? f3(v2) : v2;
          } : f3;
        }
      };
      __asyncValues = function(o3) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m2 = o3[Symbol.asyncIterator], i3;
        return m2 ? m2.call(o3) : (o3 = typeof __values === "function" ? __values(o3) : o3[Symbol.iterator](), i3 = {}, verb("next"), verb("throw"), verb("return"), i3[Symbol.asyncIterator] = function() {
          return this;
        }, i3);
        function verb(n2) {
          i3[n2] = o3[n2] && function(v2) {
            return new Promise(function(resolve, reject) {
              v2 = o3[n2](v2), settle(resolve, reject, v2.done, v2.value);
            });
          };
        }
        function settle(resolve, reject, d2, v2) {
          Promise.resolve(v2).then(function(v3) {
            resolve({ value: v3, done: d2 });
          }, reject);
        }
      };
      __makeTemplateObject = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      __importStar = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k2 in mod)
            if (Object.hasOwnProperty.call(mod, k2))
              result[k2] = mod[k2];
        }
        result["default"] = mod;
        return result;
      };
      __importDefault = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet = function(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
      };
      __classPrivateFieldSet = function(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
      };
      exporter("__extends", __extends);
      exporter("__assign", __assign);
      exporter("__rest", __rest);
      exporter("__decorate", __decorate);
      exporter("__param", __param);
      exporter("__metadata", __metadata);
      exporter("__awaiter", __awaiter);
      exporter("__generator", __generator);
      exporter("__exportStar", __exportStar);
      exporter("__createBinding", __createBinding);
      exporter("__values", __values);
      exporter("__read", __read);
      exporter("__spread", __spread);
      exporter("__spreadArrays", __spreadArrays);
      exporter("__await", __await);
      exporter("__asyncGenerator", __asyncGenerator);
      exporter("__asyncDelegator", __asyncDelegator);
      exporter("__asyncValues", __asyncValues);
      exporter("__makeTemplateObject", __makeTemplateObject);
      exporter("__importStar", __importStar);
      exporter("__importDefault", __importDefault);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    });
  }
});

// node_modules/@aws-crypto/ie11-detection/build/CryptoOperation.js
var require_CryptoOperation = __commonJS({
  "node_modules/@aws-crypto/ie11-detection/build/CryptoOperation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@aws-crypto/ie11-detection/build/Key.js
var require_Key = __commonJS({
  "node_modules/@aws-crypto/ie11-detection/build/Key.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@aws-crypto/ie11-detection/build/KeyOperation.js
var require_KeyOperation = __commonJS({
  "node_modules/@aws-crypto/ie11-detection/build/KeyOperation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@aws-crypto/ie11-detection/build/MsSubtleCrypto.js
var require_MsSubtleCrypto = __commonJS({
  "node_modules/@aws-crypto/ie11-detection/build/MsSubtleCrypto.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@aws-crypto/ie11-detection/build/MsWindow.js
var require_MsWindow = __commonJS({
  "node_modules/@aws-crypto/ie11-detection/build/MsWindow.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isMsWindow = void 0;
    var msSubtleCryptoMethods = [
      "decrypt",
      "digest",
      "encrypt",
      "exportKey",
      "generateKey",
      "importKey",
      "sign",
      "verify"
    ];
    function quacksLikeAnMsWindow(window2) {
      return "MSInputMethodContext" in window2 && "msCrypto" in window2;
    }
    function isMsWindow(window2) {
      if (quacksLikeAnMsWindow(window2) && window2.msCrypto.subtle !== void 0) {
        var _a = window2.msCrypto, getRandomValues2 = _a.getRandomValues, subtle_1 = _a.subtle;
        return msSubtleCryptoMethods.map(function(methodName) {
          return subtle_1[methodName];
        }).concat(getRandomValues2).every(function(method) {
          return typeof method === "function";
        });
      }
      return false;
    }
    exports.isMsWindow = isMsWindow;
  }
});

// node_modules/@aws-crypto/ie11-detection/build/index.js
var require_build5 = __commonJS({
  "node_modules/@aws-crypto/ie11-detection/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib5();
    tslib_1.__exportStar(require_CryptoOperation(), exports);
    tslib_1.__exportStar(require_Key(), exports);
    tslib_1.__exportStar(require_KeyOperation(), exports);
    tslib_1.__exportStar(require_MsSubtleCrypto(), exports);
    tslib_1.__exportStar(require_MsWindow(), exports);
  }
});

// node_modules/@aws-crypto/sha1-browser/build/crossPlatformSha1.js
var require_crossPlatformSha1 = __commonJS({
  "node_modules/@aws-crypto/sha1-browser/build/crossPlatformSha1.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Sha1 = void 0;
    var ie11Sha1_1 = require_ie11Sha1();
    var webCryptoSha1_1 = require_webCryptoSha1();
    var supports_web_crypto_1 = require_build4();
    var ie11_detection_1 = require_build5();
    var util_locate_window_1 = require_dist_cjs2();
    var util_1 = require_build();
    var Sha12 = function() {
      function Sha13(secret) {
        if ((0, supports_web_crypto_1.supportsWebCrypto)((0, util_locate_window_1.locateWindow)())) {
          this.hash = new webCryptoSha1_1.Sha1(secret);
        } else if ((0, ie11_detection_1.isMsWindow)((0, util_locate_window_1.locateWindow)())) {
          this.hash = new ie11Sha1_1.Sha1(secret);
        } else {
          throw new Error("SHA1 not supported");
        }
      }
      Sha13.prototype.update = function(data, encoding) {
        this.hash.update((0, util_1.convertToBuffer)(data));
      };
      Sha13.prototype.digest = function() {
        return this.hash.digest();
      };
      Sha13.prototype.reset = function() {
        this.hash.reset();
      };
      return Sha13;
    }();
    exports.Sha1 = Sha12;
  }
});

// node_modules/@aws-crypto/sha1-browser/build/index.js
var require_build6 = __commonJS({
  "node_modules/@aws-crypto/sha1-browser/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebCryptoSha1 = exports.Ie11Sha1 = void 0;
    var tslib_1 = require_tslib3();
    tslib_1.__exportStar(require_crossPlatformSha1(), exports);
    var ie11Sha1_1 = require_ie11Sha1();
    Object.defineProperty(exports, "Ie11Sha1", { enumerable: true, get: function() {
      return ie11Sha1_1.Sha1;
    } });
    var webCryptoSha1_1 = require_webCryptoSha1();
    Object.defineProperty(exports, "WebCryptoSha1", { enumerable: true, get: function() {
      return webCryptoSha1_1.Sha1;
    } });
  }
});

// node_modules/@aws-crypto/sha256-browser/node_modules/tslib/tslib.js
var require_tslib6 = __commonJS({
  "node_modules/@aws-crypto/sha256-browser/node_modules/tslib/tslib.js"(exports, module2) {
    var __extends;
    var __assign;
    var __rest;
    var __decorate;
    var __param;
    var __metadata;
    var __awaiter;
    var __generator;
    var __exportStar;
    var __values;
    var __read;
    var __spread;
    var __spreadArrays;
    var __await;
    var __asyncGenerator;
    var __asyncDelegator;
    var __asyncValues;
    var __makeTemplateObject;
    var __importStar;
    var __importDefault;
    var __classPrivateFieldGet;
    var __classPrivateFieldSet;
    var __createBinding;
    (function(factory) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports2) {
          factory(createExporter(root, createExporter(exports2)));
        });
      } else if (typeof module2 === "object" && typeof module2.exports === "object") {
        factory(createExporter(root, createExporter(module2.exports)));
      } else {
        factory(createExporter(root));
      }
      function createExporter(exports2, previous) {
        if (exports2 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports2, "__esModule", { value: true });
          } else {
            exports2.__esModule = true;
          }
        }
        return function(id, v2) {
          return exports2[id] = previous ? previous(id, v2) : v2;
        };
      }
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p2 in b2)
          if (b2.hasOwnProperty(p2))
            d2[p2] = b2[p2];
      };
      __extends = function(d2, b2) {
        extendStatics(d2, b2);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
      __assign = Object.assign || function(t3) {
        for (var s3, i3 = 1, n2 = arguments.length; i3 < n2; i3++) {
          s3 = arguments[i3];
          for (var p2 in s3)
            if (Object.prototype.hasOwnProperty.call(s3, p2))
              t3[p2] = s3[p2];
        }
        return t3;
      };
      __rest = function(s3, e3) {
        var t3 = {};
        for (var p2 in s3)
          if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
            t3[p2] = s3[p2];
        if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i3 = 0, p2 = Object.getOwnPropertySymbols(s3); i3 < p2.length; i3++) {
            if (e3.indexOf(p2[i3]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i3]))
              t3[p2[i3]] = s3[p2[i3]];
          }
        return t3;
      };
      __decorate = function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r3 = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i3 = decorators.length - 1; i3 >= 0; i3--)
            if (d2 = decorators[i3])
              r3 = (c3 < 3 ? d2(r3) : c3 > 3 ? d2(target, key, r3) : d2(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      __param = function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      __metadata = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter = function(thisArg, _arguments, P2, generator) {
        function adopt(value) {
          return value instanceof P2 ? value : new P2(function(resolve) {
            resolve(value);
          });
        }
        return new (P2 || (P2 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e3) {
              reject(e3);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e3) {
              reject(e3);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator = function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t3[0] & 1)
            throw t3[1];
          return t3[1];
        }, trys: [], ops: [] }, f3, y2, t3, g2;
        return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
          return this;
        }), g2;
        function verb(n2) {
          return function(v2) {
            return step([n2, v2]);
          };
        }
        function step(op) {
          if (f3)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f3 = 1, y2 && (t3 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t3 = y2["return"]) && t3.call(y2), 0) : y2.next) && !(t3 = t3.call(y2, op[1])).done)
                return t3;
              if (y2 = 0, t3)
                op = [op[0] & 2, t3.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t3 = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y2 = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t3 = _.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t3[1]) {
                    _.label = t3[1];
                    t3 = op;
                    break;
                  }
                  if (t3 && _.label < t3[2]) {
                    _.label = t3[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t3[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e3) {
              op = [6, e3];
              y2 = 0;
            } finally {
              f3 = t3 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __createBinding = function(o3, m2, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        o3[k22] = m2[k2];
      };
      __exportStar = function(m2, exports2) {
        for (var p2 in m2)
          if (p2 !== "default" && !exports2.hasOwnProperty(p2))
            exports2[p2] = m2[p2];
      };
      __values = function(o3) {
        var s3 = typeof Symbol === "function" && Symbol.iterator, m2 = s3 && o3[s3], i3 = 0;
        if (m2)
          return m2.call(o3);
        if (o3 && typeof o3.length === "number")
          return {
            next: function() {
              if (o3 && i3 >= o3.length)
                o3 = void 0;
              return { value: o3 && o3[i3++], done: !o3 };
            }
          };
        throw new TypeError(s3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read = function(o3, n2) {
        var m2 = typeof Symbol === "function" && o3[Symbol.iterator];
        if (!m2)
          return o3;
        var i3 = m2.call(o3), r3, ar2 = [], e3;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r3 = i3.next()).done)
            ar2.push(r3.value);
        } catch (error) {
          e3 = { error };
        } finally {
          try {
            if (r3 && !r3.done && (m2 = i3["return"]))
              m2.call(i3);
          } finally {
            if (e3)
              throw e3.error;
          }
        }
        return ar2;
      };
      __spread = function() {
        for (var ar2 = [], i3 = 0; i3 < arguments.length; i3++)
          ar2 = ar2.concat(__read(arguments[i3]));
        return ar2;
      };
      __spreadArrays = function() {
        for (var s3 = 0, i3 = 0, il = arguments.length; i3 < il; i3++)
          s3 += arguments[i3].length;
        for (var r3 = Array(s3), k2 = 0, i3 = 0; i3 < il; i3++)
          for (var a3 = arguments[i3], j2 = 0, jl = a3.length; j2 < jl; j2++, k2++)
            r3[k2] = a3[j2];
        return r3;
      };
      __await = function(v2) {
        return this instanceof __await ? (this.v = v2, this) : new __await(v2);
      };
      __asyncGenerator = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g2 = generator.apply(thisArg, _arguments || []), i3, q2 = [];
        return i3 = {}, verb("next"), verb("throw"), verb("return"), i3[Symbol.asyncIterator] = function() {
          return this;
        }, i3;
        function verb(n2) {
          if (g2[n2])
            i3[n2] = function(v2) {
              return new Promise(function(a3, b2) {
                q2.push([n2, v2, a3, b2]) > 1 || resume(n2, v2);
              });
            };
        }
        function resume(n2, v2) {
          try {
            step(g2[n2](v2));
          } catch (e3) {
            settle(q2[0][3], e3);
          }
        }
        function step(r3) {
          r3.value instanceof __await ? Promise.resolve(r3.value.v).then(fulfill, reject) : settle(q2[0][2], r3);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f3, v2) {
          if (f3(v2), q2.shift(), q2.length)
            resume(q2[0][0], q2[0][1]);
        }
      };
      __asyncDelegator = function(o3) {
        var i3, p2;
        return i3 = {}, verb("next"), verb("throw", function(e3) {
          throw e3;
        }), verb("return"), i3[Symbol.iterator] = function() {
          return this;
        }, i3;
        function verb(n2, f3) {
          i3[n2] = o3[n2] ? function(v2) {
            return (p2 = !p2) ? { value: __await(o3[n2](v2)), done: n2 === "return" } : f3 ? f3(v2) : v2;
          } : f3;
        }
      };
      __asyncValues = function(o3) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m2 = o3[Symbol.asyncIterator], i3;
        return m2 ? m2.call(o3) : (o3 = typeof __values === "function" ? __values(o3) : o3[Symbol.iterator](), i3 = {}, verb("next"), verb("throw"), verb("return"), i3[Symbol.asyncIterator] = function() {
          return this;
        }, i3);
        function verb(n2) {
          i3[n2] = o3[n2] && function(v2) {
            return new Promise(function(resolve, reject) {
              v2 = o3[n2](v2), settle(resolve, reject, v2.done, v2.value);
            });
          };
        }
        function settle(resolve, reject, d2, v2) {
          Promise.resolve(v2).then(function(v3) {
            resolve({ value: v3, done: d2 });
          }, reject);
        }
      };
      __makeTemplateObject = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      __importStar = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k2 in mod)
            if (Object.hasOwnProperty.call(mod, k2))
              result[k2] = mod[k2];
        }
        result["default"] = mod;
        return result;
      };
      __importDefault = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet = function(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
      };
      __classPrivateFieldSet = function(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
      };
      exporter("__extends", __extends);
      exporter("__assign", __assign);
      exporter("__rest", __rest);
      exporter("__decorate", __decorate);
      exporter("__param", __param);
      exporter("__metadata", __metadata);
      exporter("__awaiter", __awaiter);
      exporter("__generator", __generator);
      exporter("__exportStar", __exportStar);
      exporter("__createBinding", __createBinding);
      exporter("__values", __values);
      exporter("__read", __read);
      exporter("__spread", __spread);
      exporter("__spreadArrays", __spreadArrays);
      exporter("__await", __await);
      exporter("__asyncGenerator", __asyncGenerator);
      exporter("__asyncDelegator", __asyncDelegator);
      exporter("__asyncValues", __asyncValues);
      exporter("__makeTemplateObject", __makeTemplateObject);
      exporter("__importStar", __importStar);
      exporter("__importDefault", __importDefault);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    });
  }
});

// node_modules/@aws-crypto/sha256-browser/build/isEmptyData.js
var require_isEmptyData3 = __commonJS({
  "node_modules/@aws-crypto/sha256-browser/build/isEmptyData.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isEmptyData = void 0;
    function isEmptyData2(data) {
      if (typeof data === "string") {
        return data.length === 0;
      }
      return data.byteLength === 0;
    }
    exports.isEmptyData = isEmptyData2;
  }
});

// node_modules/@aws-crypto/sha256-browser/build/constants.js
var require_constants2 = __commonJS({
  "node_modules/@aws-crypto/sha256-browser/build/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EMPTY_DATA_SHA_256 = exports.SHA_256_HMAC_ALGO = exports.SHA_256_HASH = void 0;
    exports.SHA_256_HASH = { name: "SHA-256" };
    exports.SHA_256_HMAC_ALGO = {
      name: "HMAC",
      hash: exports.SHA_256_HASH
    };
    exports.EMPTY_DATA_SHA_256 = new Uint8Array([
      227,
      176,
      196,
      66,
      152,
      252,
      28,
      20,
      154,
      251,
      244,
      200,
      153,
      111,
      185,
      36,
      39,
      174,
      65,
      228,
      100,
      155,
      147,
      76,
      164,
      149,
      153,
      27,
      120,
      82,
      184,
      85
    ]);
  }
});

// node_modules/@aws-crypto/sha256-browser/build/ie11Sha256.js
var require_ie11Sha256 = __commonJS({
  "node_modules/@aws-crypto/sha256-browser/build/ie11Sha256.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Sha256 = void 0;
    var isEmptyData_1 = require_isEmptyData3();
    var constants_1 = require_constants2();
    var util_utf8_browser_1 = require_dist_cjs();
    var util_locate_window_1 = require_dist_cjs2();
    var Sha2562 = function() {
      function Sha2563(secret) {
        this.secret = secret;
        this.reset();
      }
      Sha2563.prototype.update = function(toHash) {
        var _this = this;
        if ((0, isEmptyData_1.isEmptyData)(toHash)) {
          return;
        }
        this.operation = this.operation.then(function(operation) {
          operation.onerror = function() {
            _this.operation = Promise.reject(new Error("Error encountered updating hash"));
          };
          operation.process(toArrayBufferView(toHash));
          return operation;
        });
        this.operation.catch(function() {
        });
      };
      Sha2563.prototype.digest = function() {
        return this.operation.then(function(operation) {
          return new Promise(function(resolve, reject) {
            operation.onerror = function() {
              reject(new Error("Error encountered finalizing hash"));
            };
            operation.oncomplete = function() {
              if (operation.result) {
                resolve(new Uint8Array(operation.result));
              }
              reject(new Error("Error encountered finalizing hash"));
            };
            operation.finish();
          });
        });
      };
      Sha2563.prototype.reset = function() {
        if (this.secret) {
          this.operation = getKeyPromise(this.secret).then(function(keyData) {
            return (0, util_locate_window_1.locateWindow)().msCrypto.subtle.sign(constants_1.SHA_256_HMAC_ALGO, keyData);
          });
          this.operation.catch(function() {
          });
        } else {
          this.operation = Promise.resolve((0, util_locate_window_1.locateWindow)().msCrypto.subtle.digest("SHA-256"));
        }
      };
      return Sha2563;
    }();
    exports.Sha256 = Sha2562;
    function getKeyPromise(secret) {
      return new Promise(function(resolve, reject) {
        var keyOperation = (0, util_locate_window_1.locateWindow)().msCrypto.subtle.importKey("raw", toArrayBufferView(secret), constants_1.SHA_256_HMAC_ALGO, false, ["sign"]);
        keyOperation.oncomplete = function() {
          if (keyOperation.result) {
            resolve(keyOperation.result);
          }
          reject(new Error("ImportKey completed without importing key."));
        };
        keyOperation.onerror = function() {
          reject(new Error("ImportKey failed to import key."));
        };
      });
    }
    function toArrayBufferView(data) {
      if (typeof data === "string") {
        return (0, util_utf8_browser_1.fromUtf8)(data);
      }
      if (ArrayBuffer.isView(data)) {
        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
      }
      return new Uint8Array(data);
    }
  }
});

// node_modules/@aws-crypto/sha256-browser/build/webCryptoSha256.js
var require_webCryptoSha256 = __commonJS({
  "node_modules/@aws-crypto/sha256-browser/build/webCryptoSha256.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Sha256 = void 0;
    var util_1 = require_build();
    var constants_1 = require_constants2();
    var util_locate_window_1 = require_dist_cjs2();
    var Sha2562 = function() {
      function Sha2563(secret) {
        this.toHash = new Uint8Array(0);
        this.secret = secret;
        this.reset();
      }
      Sha2563.prototype.update = function(data) {
        if ((0, util_1.isEmptyData)(data)) {
          return;
        }
        var update = (0, util_1.convertToBuffer)(data);
        var typedArray = new Uint8Array(this.toHash.byteLength + update.byteLength);
        typedArray.set(this.toHash, 0);
        typedArray.set(update, this.toHash.byteLength);
        this.toHash = typedArray;
      };
      Sha2563.prototype.digest = function() {
        var _this = this;
        if (this.key) {
          return this.key.then(function(key) {
            return (0, util_locate_window_1.locateWindow)().crypto.subtle.sign(constants_1.SHA_256_HMAC_ALGO, key, _this.toHash).then(function(data) {
              return new Uint8Array(data);
            });
          });
        }
        if ((0, util_1.isEmptyData)(this.toHash)) {
          return Promise.resolve(constants_1.EMPTY_DATA_SHA_256);
        }
        return Promise.resolve().then(function() {
          return (0, util_locate_window_1.locateWindow)().crypto.subtle.digest(constants_1.SHA_256_HASH, _this.toHash);
        }).then(function(data) {
          return Promise.resolve(new Uint8Array(data));
        });
      };
      Sha2563.prototype.reset = function() {
        var _this = this;
        this.toHash = new Uint8Array(0);
        if (this.secret && this.secret !== void 0) {
          this.key = new Promise(function(resolve, reject) {
            (0, util_locate_window_1.locateWindow)().crypto.subtle.importKey("raw", (0, util_1.convertToBuffer)(_this.secret), constants_1.SHA_256_HMAC_ALGO, false, ["sign"]).then(resolve, reject);
          });
          this.key.catch(function() {
          });
        }
      };
      return Sha2563;
    }();
    exports.Sha256 = Sha2562;
  }
});

// node_modules/@aws-crypto/sha256-js/node_modules/tslib/tslib.js
var require_tslib7 = __commonJS({
  "node_modules/@aws-crypto/sha256-js/node_modules/tslib/tslib.js"(exports, module2) {
    var __extends;
    var __assign;
    var __rest;
    var __decorate;
    var __param;
    var __metadata;
    var __awaiter;
    var __generator;
    var __exportStar;
    var __values;
    var __read;
    var __spread;
    var __spreadArrays;
    var __await;
    var __asyncGenerator;
    var __asyncDelegator;
    var __asyncValues;
    var __makeTemplateObject;
    var __importStar;
    var __importDefault;
    var __classPrivateFieldGet;
    var __classPrivateFieldSet;
    var __createBinding;
    (function(factory) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports2) {
          factory(createExporter(root, createExporter(exports2)));
        });
      } else if (typeof module2 === "object" && typeof module2.exports === "object") {
        factory(createExporter(root, createExporter(module2.exports)));
      } else {
        factory(createExporter(root));
      }
      function createExporter(exports2, previous) {
        if (exports2 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports2, "__esModule", { value: true });
          } else {
            exports2.__esModule = true;
          }
        }
        return function(id, v2) {
          return exports2[id] = previous ? previous(id, v2) : v2;
        };
      }
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p2 in b2)
          if (b2.hasOwnProperty(p2))
            d2[p2] = b2[p2];
      };
      __extends = function(d2, b2) {
        extendStatics(d2, b2);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
      __assign = Object.assign || function(t3) {
        for (var s3, i3 = 1, n2 = arguments.length; i3 < n2; i3++) {
          s3 = arguments[i3];
          for (var p2 in s3)
            if (Object.prototype.hasOwnProperty.call(s3, p2))
              t3[p2] = s3[p2];
        }
        return t3;
      };
      __rest = function(s3, e3) {
        var t3 = {};
        for (var p2 in s3)
          if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
            t3[p2] = s3[p2];
        if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i3 = 0, p2 = Object.getOwnPropertySymbols(s3); i3 < p2.length; i3++) {
            if (e3.indexOf(p2[i3]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i3]))
              t3[p2[i3]] = s3[p2[i3]];
          }
        return t3;
      };
      __decorate = function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r3 = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i3 = decorators.length - 1; i3 >= 0; i3--)
            if (d2 = decorators[i3])
              r3 = (c3 < 3 ? d2(r3) : c3 > 3 ? d2(target, key, r3) : d2(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      __param = function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      __metadata = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter = function(thisArg, _arguments, P2, generator) {
        function adopt(value) {
          return value instanceof P2 ? value : new P2(function(resolve) {
            resolve(value);
          });
        }
        return new (P2 || (P2 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e3) {
              reject(e3);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e3) {
              reject(e3);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator = function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t3[0] & 1)
            throw t3[1];
          return t3[1];
        }, trys: [], ops: [] }, f3, y2, t3, g2;
        return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
          return this;
        }), g2;
        function verb(n2) {
          return function(v2) {
            return step([n2, v2]);
          };
        }
        function step(op) {
          if (f3)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f3 = 1, y2 && (t3 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t3 = y2["return"]) && t3.call(y2), 0) : y2.next) && !(t3 = t3.call(y2, op[1])).done)
                return t3;
              if (y2 = 0, t3)
                op = [op[0] & 2, t3.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t3 = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y2 = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t3 = _.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t3[1]) {
                    _.label = t3[1];
                    t3 = op;
                    break;
                  }
                  if (t3 && _.label < t3[2]) {
                    _.label = t3[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t3[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e3) {
              op = [6, e3];
              y2 = 0;
            } finally {
              f3 = t3 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __createBinding = function(o3, m2, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        o3[k22] = m2[k2];
      };
      __exportStar = function(m2, exports2) {
        for (var p2 in m2)
          if (p2 !== "default" && !exports2.hasOwnProperty(p2))
            exports2[p2] = m2[p2];
      };
      __values = function(o3) {
        var s3 = typeof Symbol === "function" && Symbol.iterator, m2 = s3 && o3[s3], i3 = 0;
        if (m2)
          return m2.call(o3);
        if (o3 && typeof o3.length === "number")
          return {
            next: function() {
              if (o3 && i3 >= o3.length)
                o3 = void 0;
              return { value: o3 && o3[i3++], done: !o3 };
            }
          };
        throw new TypeError(s3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read = function(o3, n2) {
        var m2 = typeof Symbol === "function" && o3[Symbol.iterator];
        if (!m2)
          return o3;
        var i3 = m2.call(o3), r3, ar2 = [], e3;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r3 = i3.next()).done)
            ar2.push(r3.value);
        } catch (error) {
          e3 = { error };
        } finally {
          try {
            if (r3 && !r3.done && (m2 = i3["return"]))
              m2.call(i3);
          } finally {
            if (e3)
              throw e3.error;
          }
        }
        return ar2;
      };
      __spread = function() {
        for (var ar2 = [], i3 = 0; i3 < arguments.length; i3++)
          ar2 = ar2.concat(__read(arguments[i3]));
        return ar2;
      };
      __spreadArrays = function() {
        for (var s3 = 0, i3 = 0, il = arguments.length; i3 < il; i3++)
          s3 += arguments[i3].length;
        for (var r3 = Array(s3), k2 = 0, i3 = 0; i3 < il; i3++)
          for (var a3 = arguments[i3], j2 = 0, jl = a3.length; j2 < jl; j2++, k2++)
            r3[k2] = a3[j2];
        return r3;
      };
      __await = function(v2) {
        return this instanceof __await ? (this.v = v2, this) : new __await(v2);
      };
      __asyncGenerator = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g2 = generator.apply(thisArg, _arguments || []), i3, q2 = [];
        return i3 = {}, verb("next"), verb("throw"), verb("return"), i3[Symbol.asyncIterator] = function() {
          return this;
        }, i3;
        function verb(n2) {
          if (g2[n2])
            i3[n2] = function(v2) {
              return new Promise(function(a3, b2) {
                q2.push([n2, v2, a3, b2]) > 1 || resume(n2, v2);
              });
            };
        }
        function resume(n2, v2) {
          try {
            step(g2[n2](v2));
          } catch (e3) {
            settle(q2[0][3], e3);
          }
        }
        function step(r3) {
          r3.value instanceof __await ? Promise.resolve(r3.value.v).then(fulfill, reject) : settle(q2[0][2], r3);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f3, v2) {
          if (f3(v2), q2.shift(), q2.length)
            resume(q2[0][0], q2[0][1]);
        }
      };
      __asyncDelegator = function(o3) {
        var i3, p2;
        return i3 = {}, verb("next"), verb("throw", function(e3) {
          throw e3;
        }), verb("return"), i3[Symbol.iterator] = function() {
          return this;
        }, i3;
        function verb(n2, f3) {
          i3[n2] = o3[n2] ? function(v2) {
            return (p2 = !p2) ? { value: __await(o3[n2](v2)), done: n2 === "return" } : f3 ? f3(v2) : v2;
          } : f3;
        }
      };
      __asyncValues = function(o3) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m2 = o3[Symbol.asyncIterator], i3;
        return m2 ? m2.call(o3) : (o3 = typeof __values === "function" ? __values(o3) : o3[Symbol.iterator](), i3 = {}, verb("next"), verb("throw"), verb("return"), i3[Symbol.asyncIterator] = function() {
          return this;
        }, i3);
        function verb(n2) {
          i3[n2] = o3[n2] && function(v2) {
            return new Promise(function(resolve, reject) {
              v2 = o3[n2](v2), settle(resolve, reject, v2.done, v2.value);
            });
          };
        }
        function settle(resolve, reject, d2, v2) {
          Promise.resolve(v2).then(function(v3) {
            resolve({ value: v3, done: d2 });
          }, reject);
        }
      };
      __makeTemplateObject = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      __importStar = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k2 in mod)
            if (Object.hasOwnProperty.call(mod, k2))
              result[k2] = mod[k2];
        }
        result["default"] = mod;
        return result;
      };
      __importDefault = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet = function(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
      };
      __classPrivateFieldSet = function(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
      };
      exporter("__extends", __extends);
      exporter("__assign", __assign);
      exporter("__rest", __rest);
      exporter("__decorate", __decorate);
      exporter("__param", __param);
      exporter("__metadata", __metadata);
      exporter("__awaiter", __awaiter);
      exporter("__generator", __generator);
      exporter("__exportStar", __exportStar);
      exporter("__createBinding", __createBinding);
      exporter("__values", __values);
      exporter("__read", __read);
      exporter("__spread", __spread);
      exporter("__spreadArrays", __spreadArrays);
      exporter("__await", __await);
      exporter("__asyncGenerator", __asyncGenerator);
      exporter("__asyncDelegator", __asyncDelegator);
      exporter("__asyncValues", __asyncValues);
      exporter("__makeTemplateObject", __makeTemplateObject);
      exporter("__importStar", __importStar);
      exporter("__importDefault", __importDefault);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    });
  }
});

// node_modules/@aws-crypto/sha256-js/build/constants.js
var require_constants3 = __commonJS({
  "node_modules/@aws-crypto/sha256-js/build/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MAX_HASHABLE_LENGTH = exports.INIT = exports.KEY = exports.DIGEST_LENGTH = exports.BLOCK_SIZE = void 0;
    exports.BLOCK_SIZE = 64;
    exports.DIGEST_LENGTH = 32;
    exports.KEY = new Uint32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    exports.INIT = [
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ];
    exports.MAX_HASHABLE_LENGTH = Math.pow(2, 53) - 1;
  }
});

// node_modules/@aws-crypto/sha256-js/build/RawSha256.js
var require_RawSha256 = __commonJS({
  "node_modules/@aws-crypto/sha256-js/build/RawSha256.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RawSha256 = void 0;
    var constants_1 = require_constants3();
    var RawSha256 = function() {
      function RawSha2562() {
        this.state = Int32Array.from(constants_1.INIT);
        this.temp = new Int32Array(64);
        this.buffer = new Uint8Array(64);
        this.bufferLength = 0;
        this.bytesHashed = 0;
        this.finished = false;
      }
      RawSha2562.prototype.update = function(data) {
        if (this.finished) {
          throw new Error("Attempted to update an already finished hash.");
        }
        var position = 0;
        var byteLength = data.byteLength;
        this.bytesHashed += byteLength;
        if (this.bytesHashed * 8 > constants_1.MAX_HASHABLE_LENGTH) {
          throw new Error("Cannot hash more than 2^53 - 1 bits");
        }
        while (byteLength > 0) {
          this.buffer[this.bufferLength++] = data[position++];
          byteLength--;
          if (this.bufferLength === constants_1.BLOCK_SIZE) {
            this.hashBuffer();
            this.bufferLength = 0;
          }
        }
      };
      RawSha2562.prototype.digest = function() {
        if (!this.finished) {
          var bitsHashed = this.bytesHashed * 8;
          var bufferView = new DataView(this.buffer.buffer, this.buffer.byteOffset, this.buffer.byteLength);
          var undecoratedLength = this.bufferLength;
          bufferView.setUint8(this.bufferLength++, 128);
          if (undecoratedLength % constants_1.BLOCK_SIZE >= constants_1.BLOCK_SIZE - 8) {
            for (var i3 = this.bufferLength; i3 < constants_1.BLOCK_SIZE; i3++) {
              bufferView.setUint8(i3, 0);
            }
            this.hashBuffer();
            this.bufferLength = 0;
          }
          for (var i3 = this.bufferLength; i3 < constants_1.BLOCK_SIZE - 8; i3++) {
            bufferView.setUint8(i3, 0);
          }
          bufferView.setUint32(constants_1.BLOCK_SIZE - 8, Math.floor(bitsHashed / 4294967296), true);
          bufferView.setUint32(constants_1.BLOCK_SIZE - 4, bitsHashed);
          this.hashBuffer();
          this.finished = true;
        }
        var out = new Uint8Array(constants_1.DIGEST_LENGTH);
        for (var i3 = 0; i3 < 8; i3++) {
          out[i3 * 4] = this.state[i3] >>> 24 & 255;
          out[i3 * 4 + 1] = this.state[i3] >>> 16 & 255;
          out[i3 * 4 + 2] = this.state[i3] >>> 8 & 255;
          out[i3 * 4 + 3] = this.state[i3] >>> 0 & 255;
        }
        return out;
      };
      RawSha2562.prototype.hashBuffer = function() {
        var _a = this, buffer = _a.buffer, state = _a.state;
        var state0 = state[0], state1 = state[1], state2 = state[2], state3 = state[3], state4 = state[4], state5 = state[5], state6 = state[6], state7 = state[7];
        for (var i3 = 0; i3 < constants_1.BLOCK_SIZE; i3++) {
          if (i3 < 16) {
            this.temp[i3] = (buffer[i3 * 4] & 255) << 24 | (buffer[i3 * 4 + 1] & 255) << 16 | (buffer[i3 * 4 + 2] & 255) << 8 | buffer[i3 * 4 + 3] & 255;
          } else {
            var u2 = this.temp[i3 - 2];
            var t1_1 = (u2 >>> 17 | u2 << 15) ^ (u2 >>> 19 | u2 << 13) ^ u2 >>> 10;
            u2 = this.temp[i3 - 15];
            var t2_1 = (u2 >>> 7 | u2 << 25) ^ (u2 >>> 18 | u2 << 14) ^ u2 >>> 3;
            this.temp[i3] = (t1_1 + this.temp[i3 - 7] | 0) + (t2_1 + this.temp[i3 - 16] | 0);
          }
          var t1 = (((state4 >>> 6 | state4 << 26) ^ (state4 >>> 11 | state4 << 21) ^ (state4 >>> 25 | state4 << 7)) + (state4 & state5 ^ ~state4 & state6) | 0) + (state7 + (constants_1.KEY[i3] + this.temp[i3] | 0) | 0) | 0;
          var t22 = ((state0 >>> 2 | state0 << 30) ^ (state0 >>> 13 | state0 << 19) ^ (state0 >>> 22 | state0 << 10)) + (state0 & state1 ^ state0 & state2 ^ state1 & state2) | 0;
          state7 = state6;
          state6 = state5;
          state5 = state4;
          state4 = state3 + t1 | 0;
          state3 = state2;
          state2 = state1;
          state1 = state0;
          state0 = t1 + t22 | 0;
        }
        state[0] += state0;
        state[1] += state1;
        state[2] += state2;
        state[3] += state3;
        state[4] += state4;
        state[5] += state5;
        state[6] += state6;
        state[7] += state7;
      };
      return RawSha2562;
    }();
    exports.RawSha256 = RawSha256;
  }
});

// node_modules/@aws-crypto/sha256-js/build/jsSha256.js
var require_jsSha256 = __commonJS({
  "node_modules/@aws-crypto/sha256-js/build/jsSha256.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Sha256 = void 0;
    var tslib_1 = require_tslib7();
    var constants_1 = require_constants3();
    var RawSha256_1 = require_RawSha256();
    var util_1 = require_build();
    var Sha2562 = function() {
      function Sha2563(secret) {
        this.secret = secret;
        this.hash = new RawSha256_1.RawSha256();
        this.reset();
      }
      Sha2563.prototype.update = function(toHash) {
        if ((0, util_1.isEmptyData)(toHash) || this.error) {
          return;
        }
        try {
          this.hash.update((0, util_1.convertToBuffer)(toHash));
        } catch (e3) {
          this.error = e3;
        }
      };
      Sha2563.prototype.digestSync = function() {
        if (this.error) {
          throw this.error;
        }
        if (this.outer) {
          if (!this.outer.finished) {
            this.outer.update(this.hash.digest());
          }
          return this.outer.digest();
        }
        return this.hash.digest();
      };
      Sha2563.prototype.digest = function() {
        return tslib_1.__awaiter(this, void 0, void 0, function() {
          return tslib_1.__generator(this, function(_a) {
            return [2, this.digestSync()];
          });
        });
      };
      Sha2563.prototype.reset = function() {
        this.hash = new RawSha256_1.RawSha256();
        if (this.secret) {
          this.outer = new RawSha256_1.RawSha256();
          var inner = bufferFromSecret(this.secret);
          var outer = new Uint8Array(constants_1.BLOCK_SIZE);
          outer.set(inner);
          for (var i3 = 0; i3 < constants_1.BLOCK_SIZE; i3++) {
            inner[i3] ^= 54;
            outer[i3] ^= 92;
          }
          this.hash.update(inner);
          this.outer.update(outer);
          for (var i3 = 0; i3 < inner.byteLength; i3++) {
            inner[i3] = 0;
          }
        }
      };
      return Sha2563;
    }();
    exports.Sha256 = Sha2562;
    function bufferFromSecret(secret) {
      var input = (0, util_1.convertToBuffer)(secret);
      if (input.byteLength > constants_1.BLOCK_SIZE) {
        var bufferHash = new RawSha256_1.RawSha256();
        bufferHash.update(input);
        input = bufferHash.digest();
      }
      var buffer = new Uint8Array(constants_1.BLOCK_SIZE);
      buffer.set(input);
      return buffer;
    }
  }
});

// node_modules/@aws-crypto/sha256-js/build/index.js
var require_build7 = __commonJS({
  "node_modules/@aws-crypto/sha256-js/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib7();
    tslib_1.__exportStar(require_jsSha256(), exports);
  }
});

// node_modules/@aws-crypto/sha256-browser/build/crossPlatformSha256.js
var require_crossPlatformSha256 = __commonJS({
  "node_modules/@aws-crypto/sha256-browser/build/crossPlatformSha256.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Sha256 = void 0;
    var ie11Sha256_1 = require_ie11Sha256();
    var webCryptoSha256_1 = require_webCryptoSha256();
    var sha256_js_1 = require_build7();
    var supports_web_crypto_1 = require_build4();
    var ie11_detection_1 = require_build5();
    var util_locate_window_1 = require_dist_cjs2();
    var util_1 = require_build();
    var Sha2562 = function() {
      function Sha2563(secret) {
        if ((0, supports_web_crypto_1.supportsWebCrypto)((0, util_locate_window_1.locateWindow)())) {
          this.hash = new webCryptoSha256_1.Sha256(secret);
        } else if ((0, ie11_detection_1.isMsWindow)((0, util_locate_window_1.locateWindow)())) {
          this.hash = new ie11Sha256_1.Sha256(secret);
        } else {
          this.hash = new sha256_js_1.Sha256(secret);
        }
      }
      Sha2563.prototype.update = function(data, encoding) {
        this.hash.update((0, util_1.convertToBuffer)(data));
      };
      Sha2563.prototype.digest = function() {
        return this.hash.digest();
      };
      Sha2563.prototype.reset = function() {
        this.hash.reset();
      };
      return Sha2563;
    }();
    exports.Sha256 = Sha2562;
  }
});

// node_modules/@aws-crypto/sha256-browser/build/index.js
var require_build8 = __commonJS({
  "node_modules/@aws-crypto/sha256-browser/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebCryptoSha256 = exports.Ie11Sha256 = void 0;
    var tslib_1 = require_tslib6();
    tslib_1.__exportStar(require_crossPlatformSha256(), exports);
    var ie11Sha256_1 = require_ie11Sha256();
    Object.defineProperty(exports, "Ie11Sha256", { enumerable: true, get: function() {
      return ie11Sha256_1.Sha256;
    } });
    var webCryptoSha256_1 = require_webCryptoSha256();
    Object.defineProperty(exports, "WebCryptoSha256", { enumerable: true, get: function() {
      return webCryptoSha256_1.Sha256;
    } });
  }
});

// node_modules/bowser/es5.js
var require_es5 = __commonJS({
  "node_modules/bowser/es5.js"(exports, module2) {
    !function(e3, t3) {
      typeof exports == "object" && typeof module2 == "object" ? module2.exports = t3() : typeof define == "function" && define.amd ? define([], t3) : typeof exports == "object" ? exports.bowser = t3() : e3.bowser = t3();
    }(exports, function() {
      return function(e3) {
        var t3 = {};
        function r3(n2) {
          if (t3[n2])
            return t3[n2].exports;
          var i3 = t3[n2] = { i: n2, l: false, exports: {} };
          return e3[n2].call(i3.exports, i3, i3.exports, r3), i3.l = true, i3.exports;
        }
        return r3.m = e3, r3.c = t3, r3.d = function(e4, t4, n2) {
          r3.o(e4, t4) || Object.defineProperty(e4, t4, { enumerable: true, get: n2 });
        }, r3.r = function(e4) {
          typeof Symbol != "undefined" && Symbol.toStringTag && Object.defineProperty(e4, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e4, "__esModule", { value: true });
        }, r3.t = function(e4, t4) {
          if (1 & t4 && (e4 = r3(e4)), 8 & t4)
            return e4;
          if (4 & t4 && typeof e4 == "object" && e4 && e4.__esModule)
            return e4;
          var n2 = /* @__PURE__ */ Object.create(null);
          if (r3.r(n2), Object.defineProperty(n2, "default", { enumerable: true, value: e4 }), 2 & t4 && typeof e4 != "string")
            for (var i3 in e4)
              r3.d(n2, i3, function(t5) {
                return e4[t5];
              }.bind(null, i3));
          return n2;
        }, r3.n = function(e4) {
          var t4 = e4 && e4.__esModule ? function() {
            return e4.default;
          } : function() {
            return e4;
          };
          return r3.d(t4, "a", t4), t4;
        }, r3.o = function(e4, t4) {
          return Object.prototype.hasOwnProperty.call(e4, t4);
        }, r3.p = "", r3(r3.s = 90);
      }({ 17: function(e3, t3, r3) {
        "use strict";
        t3.__esModule = true, t3.default = void 0;
        var n2 = r3(18), i3 = function() {
          function e4() {
          }
          return e4.getFirstMatch = function(e5, t4) {
            var r4 = t4.match(e5);
            return r4 && r4.length > 0 && r4[1] || "";
          }, e4.getSecondMatch = function(e5, t4) {
            var r4 = t4.match(e5);
            return r4 && r4.length > 1 && r4[2] || "";
          }, e4.matchAndReturnConst = function(e5, t4, r4) {
            if (e5.test(t4))
              return r4;
          }, e4.getWindowsVersionName = function(e5) {
            switch (e5) {
              case "NT":
                return "NT";
              case "XP":
                return "XP";
              case "NT 5.0":
                return "2000";
              case "NT 5.1":
                return "XP";
              case "NT 5.2":
                return "2003";
              case "NT 6.0":
                return "Vista";
              case "NT 6.1":
                return "7";
              case "NT 6.2":
                return "8";
              case "NT 6.3":
                return "8.1";
              case "NT 10.0":
                return "10";
              default:
                return;
            }
          }, e4.getMacOSVersionName = function(e5) {
            var t4 = e5.split(".").splice(0, 2).map(function(e6) {
              return parseInt(e6, 10) || 0;
            });
            if (t4.push(0), t4[0] === 10)
              switch (t4[1]) {
                case 5:
                  return "Leopard";
                case 6:
                  return "Snow Leopard";
                case 7:
                  return "Lion";
                case 8:
                  return "Mountain Lion";
                case 9:
                  return "Mavericks";
                case 10:
                  return "Yosemite";
                case 11:
                  return "El Capitan";
                case 12:
                  return "Sierra";
                case 13:
                  return "High Sierra";
                case 14:
                  return "Mojave";
                case 15:
                  return "Catalina";
                default:
                  return;
              }
          }, e4.getAndroidVersionName = function(e5) {
            var t4 = e5.split(".").splice(0, 2).map(function(e6) {
              return parseInt(e6, 10) || 0;
            });
            if (t4.push(0), !(t4[0] === 1 && t4[1] < 5))
              return t4[0] === 1 && t4[1] < 6 ? "Cupcake" : t4[0] === 1 && t4[1] >= 6 ? "Donut" : t4[0] === 2 && t4[1] < 2 ? "Eclair" : t4[0] === 2 && t4[1] === 2 ? "Froyo" : t4[0] === 2 && t4[1] > 2 ? "Gingerbread" : t4[0] === 3 ? "Honeycomb" : t4[0] === 4 && t4[1] < 1 ? "Ice Cream Sandwich" : t4[0] === 4 && t4[1] < 4 ? "Jelly Bean" : t4[0] === 4 && t4[1] >= 4 ? "KitKat" : t4[0] === 5 ? "Lollipop" : t4[0] === 6 ? "Marshmallow" : t4[0] === 7 ? "Nougat" : t4[0] === 8 ? "Oreo" : t4[0] === 9 ? "Pie" : void 0;
          }, e4.getVersionPrecision = function(e5) {
            return e5.split(".").length;
          }, e4.compareVersions = function(t4, r4, n3) {
            n3 === void 0 && (n3 = false);
            var i4 = e4.getVersionPrecision(t4), s3 = e4.getVersionPrecision(r4), a3 = Math.max(i4, s3), o3 = 0, u2 = e4.map([t4, r4], function(t5) {
              var r5 = a3 - e4.getVersionPrecision(t5), n4 = t5 + new Array(r5 + 1).join(".0");
              return e4.map(n4.split("."), function(e5) {
                return new Array(20 - e5.length).join("0") + e5;
              }).reverse();
            });
            for (n3 && (o3 = a3 - Math.min(i4, s3)), a3 -= 1; a3 >= o3; ) {
              if (u2[0][a3] > u2[1][a3])
                return 1;
              if (u2[0][a3] === u2[1][a3]) {
                if (a3 === o3)
                  return 0;
                a3 -= 1;
              } else if (u2[0][a3] < u2[1][a3])
                return -1;
            }
          }, e4.map = function(e5, t4) {
            var r4, n3 = [];
            if (Array.prototype.map)
              return Array.prototype.map.call(e5, t4);
            for (r4 = 0; r4 < e5.length; r4 += 1)
              n3.push(t4(e5[r4]));
            return n3;
          }, e4.find = function(e5, t4) {
            var r4, n3;
            if (Array.prototype.find)
              return Array.prototype.find.call(e5, t4);
            for (r4 = 0, n3 = e5.length; r4 < n3; r4 += 1) {
              var i4 = e5[r4];
              if (t4(i4, r4))
                return i4;
            }
          }, e4.assign = function(e5) {
            for (var t4, r4, n3 = e5, i4 = arguments.length, s3 = new Array(i4 > 1 ? i4 - 1 : 0), a3 = 1; a3 < i4; a3++)
              s3[a3 - 1] = arguments[a3];
            if (Object.assign)
              return Object.assign.apply(Object, [e5].concat(s3));
            var o3 = function() {
              var e6 = s3[t4];
              typeof e6 == "object" && e6 !== null && Object.keys(e6).forEach(function(t5) {
                n3[t5] = e6[t5];
              });
            };
            for (t4 = 0, r4 = s3.length; t4 < r4; t4 += 1)
              o3();
            return e5;
          }, e4.getBrowserAlias = function(e5) {
            return n2.BROWSER_ALIASES_MAP[e5];
          }, e4.getBrowserTypeByAlias = function(e5) {
            return n2.BROWSER_MAP[e5] || "";
          }, e4;
        }();
        t3.default = i3, e3.exports = t3.default;
      }, 18: function(e3, t3, r3) {
        "use strict";
        t3.__esModule = true, t3.ENGINE_MAP = t3.OS_MAP = t3.PLATFORMS_MAP = t3.BROWSER_MAP = t3.BROWSER_ALIASES_MAP = void 0;
        t3.BROWSER_ALIASES_MAP = { "Amazon Silk": "amazon_silk", "Android Browser": "android", Bada: "bada", BlackBerry: "blackberry", Chrome: "chrome", Chromium: "chromium", Electron: "electron", Epiphany: "epiphany", Firefox: "firefox", Focus: "focus", Generic: "generic", "Google Search": "google_search", Googlebot: "googlebot", "Internet Explorer": "ie", "K-Meleon": "k_meleon", Maxthon: "maxthon", "Microsoft Edge": "edge", "MZ Browser": "mz", "NAVER Whale Browser": "naver", Opera: "opera", "Opera Coast": "opera_coast", PhantomJS: "phantomjs", Puffin: "puffin", QupZilla: "qupzilla", QQ: "qq", QQLite: "qqlite", Safari: "safari", Sailfish: "sailfish", "Samsung Internet for Android": "samsung_internet", SeaMonkey: "seamonkey", Sleipnir: "sleipnir", Swing: "swing", Tizen: "tizen", "UC Browser": "uc", Vivaldi: "vivaldi", "WebOS Browser": "webos", WeChat: "wechat", "Yandex Browser": "yandex", Roku: "roku" };
        t3.BROWSER_MAP = { amazon_silk: "Amazon Silk", android: "Android Browser", bada: "Bada", blackberry: "BlackBerry", chrome: "Chrome", chromium: "Chromium", electron: "Electron", epiphany: "Epiphany", firefox: "Firefox", focus: "Focus", generic: "Generic", googlebot: "Googlebot", google_search: "Google Search", ie: "Internet Explorer", k_meleon: "K-Meleon", maxthon: "Maxthon", edge: "Microsoft Edge", mz: "MZ Browser", naver: "NAVER Whale Browser", opera: "Opera", opera_coast: "Opera Coast", phantomjs: "PhantomJS", puffin: "Puffin", qupzilla: "QupZilla", qq: "QQ Browser", qqlite: "QQ Browser Lite", safari: "Safari", sailfish: "Sailfish", samsung_internet: "Samsung Internet for Android", seamonkey: "SeaMonkey", sleipnir: "Sleipnir", swing: "Swing", tizen: "Tizen", uc: "UC Browser", vivaldi: "Vivaldi", webos: "WebOS Browser", wechat: "WeChat", yandex: "Yandex Browser" };
        t3.PLATFORMS_MAP = { tablet: "tablet", mobile: "mobile", desktop: "desktop", tv: "tv" };
        t3.OS_MAP = { WindowsPhone: "Windows Phone", Windows: "Windows", MacOS: "macOS", iOS: "iOS", Android: "Android", WebOS: "WebOS", BlackBerry: "BlackBerry", Bada: "Bada", Tizen: "Tizen", Linux: "Linux", ChromeOS: "Chrome OS", PlayStation4: "PlayStation 4", Roku: "Roku" };
        t3.ENGINE_MAP = { EdgeHTML: "EdgeHTML", Blink: "Blink", Trident: "Trident", Presto: "Presto", Gecko: "Gecko", WebKit: "WebKit" };
      }, 90: function(e3, t3, r3) {
        "use strict";
        t3.__esModule = true, t3.default = void 0;
        var n2, i3 = (n2 = r3(91)) && n2.__esModule ? n2 : { default: n2 }, s3 = r3(18);
        function a3(e4, t4) {
          for (var r4 = 0; r4 < t4.length; r4++) {
            var n3 = t4[r4];
            n3.enumerable = n3.enumerable || false, n3.configurable = true, "value" in n3 && (n3.writable = true), Object.defineProperty(e4, n3.key, n3);
          }
        }
        var o3 = function() {
          function e4() {
          }
          var t4, r4, n3;
          return e4.getParser = function(e5, t5) {
            if (t5 === void 0 && (t5 = false), typeof e5 != "string")
              throw new Error("UserAgent should be a string");
            return new i3.default(e5, t5);
          }, e4.parse = function(e5) {
            return new i3.default(e5).getResult();
          }, t4 = e4, n3 = [{ key: "BROWSER_MAP", get: function() {
            return s3.BROWSER_MAP;
          } }, { key: "ENGINE_MAP", get: function() {
            return s3.ENGINE_MAP;
          } }, { key: "OS_MAP", get: function() {
            return s3.OS_MAP;
          } }, { key: "PLATFORMS_MAP", get: function() {
            return s3.PLATFORMS_MAP;
          } }], (r4 = null) && a3(t4.prototype, r4), n3 && a3(t4, n3), e4;
        }();
        t3.default = o3, e3.exports = t3.default;
      }, 91: function(e3, t3, r3) {
        "use strict";
        t3.__esModule = true, t3.default = void 0;
        var n2 = u2(r3(92)), i3 = u2(r3(93)), s3 = u2(r3(94)), a3 = u2(r3(95)), o3 = u2(r3(17));
        function u2(e4) {
          return e4 && e4.__esModule ? e4 : { default: e4 };
        }
        var d2 = function() {
          function e4(e5, t5) {
            if (t5 === void 0 && (t5 = false), e5 == null || e5 === "")
              throw new Error("UserAgent parameter can't be empty");
            this._ua = e5, this.parsedResult = {}, t5 !== true && this.parse();
          }
          var t4 = e4.prototype;
          return t4.getUA = function() {
            return this._ua;
          }, t4.test = function(e5) {
            return e5.test(this._ua);
          }, t4.parseBrowser = function() {
            var e5 = this;
            this.parsedResult.browser = {};
            var t5 = o3.default.find(n2.default, function(t6) {
              if (typeof t6.test == "function")
                return t6.test(e5);
              if (t6.test instanceof Array)
                return t6.test.some(function(t7) {
                  return e5.test(t7);
                });
              throw new Error("Browser's test function is not valid");
            });
            return t5 && (this.parsedResult.browser = t5.describe(this.getUA())), this.parsedResult.browser;
          }, t4.getBrowser = function() {
            return this.parsedResult.browser ? this.parsedResult.browser : this.parseBrowser();
          }, t4.getBrowserName = function(e5) {
            return e5 ? String(this.getBrowser().name).toLowerCase() || "" : this.getBrowser().name || "";
          }, t4.getBrowserVersion = function() {
            return this.getBrowser().version;
          }, t4.getOS = function() {
            return this.parsedResult.os ? this.parsedResult.os : this.parseOS();
          }, t4.parseOS = function() {
            var e5 = this;
            this.parsedResult.os = {};
            var t5 = o3.default.find(i3.default, function(t6) {
              if (typeof t6.test == "function")
                return t6.test(e5);
              if (t6.test instanceof Array)
                return t6.test.some(function(t7) {
                  return e5.test(t7);
                });
              throw new Error("Browser's test function is not valid");
            });
            return t5 && (this.parsedResult.os = t5.describe(this.getUA())), this.parsedResult.os;
          }, t4.getOSName = function(e5) {
            var t5 = this.getOS().name;
            return e5 ? String(t5).toLowerCase() || "" : t5 || "";
          }, t4.getOSVersion = function() {
            return this.getOS().version;
          }, t4.getPlatform = function() {
            return this.parsedResult.platform ? this.parsedResult.platform : this.parsePlatform();
          }, t4.getPlatformType = function(e5) {
            e5 === void 0 && (e5 = false);
            var t5 = this.getPlatform().type;
            return e5 ? String(t5).toLowerCase() || "" : t5 || "";
          }, t4.parsePlatform = function() {
            var e5 = this;
            this.parsedResult.platform = {};
            var t5 = o3.default.find(s3.default, function(t6) {
              if (typeof t6.test == "function")
                return t6.test(e5);
              if (t6.test instanceof Array)
                return t6.test.some(function(t7) {
                  return e5.test(t7);
                });
              throw new Error("Browser's test function is not valid");
            });
            return t5 && (this.parsedResult.platform = t5.describe(this.getUA())), this.parsedResult.platform;
          }, t4.getEngine = function() {
            return this.parsedResult.engine ? this.parsedResult.engine : this.parseEngine();
          }, t4.getEngineName = function(e5) {
            return e5 ? String(this.getEngine().name).toLowerCase() || "" : this.getEngine().name || "";
          }, t4.parseEngine = function() {
            var e5 = this;
            this.parsedResult.engine = {};
            var t5 = o3.default.find(a3.default, function(t6) {
              if (typeof t6.test == "function")
                return t6.test(e5);
              if (t6.test instanceof Array)
                return t6.test.some(function(t7) {
                  return e5.test(t7);
                });
              throw new Error("Browser's test function is not valid");
            });
            return t5 && (this.parsedResult.engine = t5.describe(this.getUA())), this.parsedResult.engine;
          }, t4.parse = function() {
            return this.parseBrowser(), this.parseOS(), this.parsePlatform(), this.parseEngine(), this;
          }, t4.getResult = function() {
            return o3.default.assign({}, this.parsedResult);
          }, t4.satisfies = function(e5) {
            var t5 = this, r4 = {}, n3 = 0, i4 = {}, s4 = 0;
            if (Object.keys(e5).forEach(function(t6) {
              var a5 = e5[t6];
              typeof a5 == "string" ? (i4[t6] = a5, s4 += 1) : typeof a5 == "object" && (r4[t6] = a5, n3 += 1);
            }), n3 > 0) {
              var a4 = Object.keys(r4), u3 = o3.default.find(a4, function(e6) {
                return t5.isOS(e6);
              });
              if (u3) {
                var d3 = this.satisfies(r4[u3]);
                if (d3 !== void 0)
                  return d3;
              }
              var c3 = o3.default.find(a4, function(e6) {
                return t5.isPlatform(e6);
              });
              if (c3) {
                var f3 = this.satisfies(r4[c3]);
                if (f3 !== void 0)
                  return f3;
              }
            }
            if (s4 > 0) {
              var l3 = Object.keys(i4), h2 = o3.default.find(l3, function(e6) {
                return t5.isBrowser(e6, true);
              });
              if (h2 !== void 0)
                return this.compareVersion(i4[h2]);
            }
          }, t4.isBrowser = function(e5, t5) {
            t5 === void 0 && (t5 = false);
            var r4 = this.getBrowserName().toLowerCase(), n3 = e5.toLowerCase(), i4 = o3.default.getBrowserTypeByAlias(n3);
            return t5 && i4 && (n3 = i4.toLowerCase()), n3 === r4;
          }, t4.compareVersion = function(e5) {
            var t5 = [0], r4 = e5, n3 = false, i4 = this.getBrowserVersion();
            if (typeof i4 == "string")
              return e5[0] === ">" || e5[0] === "<" ? (r4 = e5.substr(1), e5[1] === "=" ? (n3 = true, r4 = e5.substr(2)) : t5 = [], e5[0] === ">" ? t5.push(1) : t5.push(-1)) : e5[0] === "=" ? r4 = e5.substr(1) : e5[0] === "~" && (n3 = true, r4 = e5.substr(1)), t5.indexOf(o3.default.compareVersions(i4, r4, n3)) > -1;
          }, t4.isOS = function(e5) {
            return this.getOSName(true) === String(e5).toLowerCase();
          }, t4.isPlatform = function(e5) {
            return this.getPlatformType(true) === String(e5).toLowerCase();
          }, t4.isEngine = function(e5) {
            return this.getEngineName(true) === String(e5).toLowerCase();
          }, t4.is = function(e5, t5) {
            return t5 === void 0 && (t5 = false), this.isBrowser(e5, t5) || this.isOS(e5) || this.isPlatform(e5);
          }, t4.some = function(e5) {
            var t5 = this;
            return e5 === void 0 && (e5 = []), e5.some(function(e6) {
              return t5.is(e6);
            });
          }, e4;
        }();
        t3.default = d2, e3.exports = t3.default;
      }, 92: function(e3, t3, r3) {
        "use strict";
        t3.__esModule = true, t3.default = void 0;
        var n2, i3 = (n2 = r3(17)) && n2.__esModule ? n2 : { default: n2 };
        var s3 = /version\/(\d+(\.?_?\d+)+)/i, a3 = [{ test: [/googlebot/i], describe: function(e4) {
          var t4 = { name: "Googlebot" }, r4 = i3.default.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, e4) || i3.default.getFirstMatch(s3, e4);
          return r4 && (t4.version = r4), t4;
        } }, { test: [/opera/i], describe: function(e4) {
          var t4 = { name: "Opera" }, r4 = i3.default.getFirstMatch(s3, e4) || i3.default.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, e4);
          return r4 && (t4.version = r4), t4;
        } }, { test: [/opr\/|opios/i], describe: function(e4) {
          var t4 = { name: "Opera" }, r4 = i3.default.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, e4) || i3.default.getFirstMatch(s3, e4);
          return r4 && (t4.version = r4), t4;
        } }, { test: [/SamsungBrowser/i], describe: function(e4) {
          var t4 = { name: "Samsung Internet for Android" }, r4 = i3.default.getFirstMatch(s3, e4) || i3.default.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, e4);
          return r4 && (t4.version = r4), t4;
        } }, { test: [/Whale/i], describe: function(e4) {
          var t4 = { name: "NAVER Whale Browser" }, r4 = i3.default.getFirstMatch(s3, e4) || i3.default.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, e4);
          return r4 && (t4.version = r4), t4;
        } }, { test: [/MZBrowser/i], describe: function(e4) {
          var t4 = { name: "MZ Browser" }, r4 = i3.default.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, e4) || i3.default.getFirstMatch(s3, e4);
          return r4 && (t4.version = r4), t4;
        } }, { test: [/focus/i], describe: function(e4) {
          var t4 = { name: "Focus" }, r4 = i3.default.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, e4) || i3.default.getFirstMatch(s3, e4);
          return r4 && (t4.version = r4), t4;
        } }, { test: [/swing/i], describe: function(e4) {
          var t4 = { name: "Swing" }, r4 = i3.default.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, e4) || i3.default.getFirstMatch(s3, e4);
          return r4 && (t4.version = r4), t4;
        } }, { test: [/coast/i], describe: function(e4) {
          var t4 = { name: "Opera Coast" }, r4 = i3.default.getFirstMatch(s3, e4) || i3.default.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, e4);
          return r4 && (t4.version = r4), t4;
        } }, { test: [/opt\/\d+(?:.?_?\d+)+/i], describe: function(e4) {
          var t4 = { name: "Opera Touch" }, r4 = i3.default.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i, e4) || i3.default.getFirstMatch(s3, e4);
          return r4 && (t4.version = r4), t4;
        } }, { test: [/yabrowser/i], describe: function(e4) {
          var t4 = { name: "Yandex Browser" }, r4 = i3.default.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, e4) || i3.default.getFirstMatch(s3, e4);
          return r4 && (t4.version = r4), t4;
        } }, { test: [/ucbrowser/i], describe: function(e4) {
          var t4 = { name: "UC Browser" }, r4 = i3.default.getFirstMatch(s3, e4) || i3.default.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, e4);
          return r4 && (t4.version = r4), t4;
        } }, { test: [/Maxthon|mxios/i], describe: function(e4) {
          var t4 = { name: "Maxthon" }, r4 = i3.default.getFirstMatch(s3, e4) || i3.default.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, e4);
          return r4 && (t4.version = r4), t4;
        } }, { test: [/epiphany/i], describe: function(e4) {
          var t4 = { name: "Epiphany" }, r4 = i3.default.getFirstMatch(s3, e4) || i3.default.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, e4);
          return r4 && (t4.version = r4), t4;
        } }, { test: [/puffin/i], describe: function(e4) {
          var t4 = { name: "Puffin" }, r4 = i3.default.getFirstMatch(s3, e4) || i3.default.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, e4);
          return r4 && (t4.version = r4), t4;
        } }, { test: [/sleipnir/i], describe: function(e4) {
          var t4 = { name: "Sleipnir" }, r4 = i3.default.getFirstMatch(s3, e4) || i3.default.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, e4);
          return r4 && (t4.version = r4), t4;
        } }, { test: [/k-meleon/i], describe: function(e4) {
          var t4 = { name: "K-Meleon" }, r4 = i3.default.getFirstMatch(s3, e4) || i3.default.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, e4);
          return r4 && (t4.version = r4), t4;
        } }, { test: [/micromessenger/i], describe: function(e4) {
          var t4 = { name: "WeChat" }, r4 = i3.default.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, e4) || i3.default.getFirstMatch(s3, e4);
          return r4 && (t4.version = r4), t4;
        } }, { test: [/qqbrowser/i], describe: function(e4) {
          var t4 = { name: /qqbrowserlite/i.test(e4) ? "QQ Browser Lite" : "QQ Browser" }, r4 = i3.default.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, e4) || i3.default.getFirstMatch(s3, e4);
          return r4 && (t4.version = r4), t4;
        } }, { test: [/msie|trident/i], describe: function(e4) {
          var t4 = { name: "Internet Explorer" }, r4 = i3.default.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, e4);
          return r4 && (t4.version = r4), t4;
        } }, { test: [/\sedg\//i], describe: function(e4) {
          var t4 = { name: "Microsoft Edge" }, r4 = i3.default.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, e4);
          return r4 && (t4.version = r4), t4;
        } }, { test: [/edg([ea]|ios)/i], describe: function(e4) {
          var t4 = { name: "Microsoft Edge" }, r4 = i3.default.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, e4);
          return r4 && (t4.version = r4), t4;
        } }, { test: [/vivaldi/i], describe: function(e4) {
          var t4 = { name: "Vivaldi" }, r4 = i3.default.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, e4);
          return r4 && (t4.version = r4), t4;
        } }, { test: [/seamonkey/i], describe: function(e4) {
          var t4 = { name: "SeaMonkey" }, r4 = i3.default.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, e4);
          return r4 && (t4.version = r4), t4;
        } }, { test: [/sailfish/i], describe: function(e4) {
          var t4 = { name: "Sailfish" }, r4 = i3.default.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, e4);
          return r4 && (t4.version = r4), t4;
        } }, { test: [/silk/i], describe: function(e4) {
          var t4 = { name: "Amazon Silk" }, r4 = i3.default.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, e4);
          return r4 && (t4.version = r4), t4;
        } }, { test: [/phantom/i], describe: function(e4) {
          var t4 = { name: "PhantomJS" }, r4 = i3.default.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, e4);
          return r4 && (t4.version = r4), t4;
        } }, { test: [/slimerjs/i], describe: function(e4) {
          var t4 = { name: "SlimerJS" }, r4 = i3.default.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, e4);
          return r4 && (t4.version = r4), t4;
        } }, { test: [/blackberry|\bbb\d+/i, /rim\stablet/i], describe: function(e4) {
          var t4 = { name: "BlackBerry" }, r4 = i3.default.getFirstMatch(s3, e4) || i3.default.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, e4);
          return r4 && (t4.version = r4), t4;
        } }, { test: [/(web|hpw)[o0]s/i], describe: function(e4) {
          var t4 = { name: "WebOS Browser" }, r4 = i3.default.getFirstMatch(s3, e4) || i3.default.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, e4);
          return r4 && (t4.version = r4), t4;
        } }, { test: [/bada/i], describe: function(e4) {
          var t4 = { name: "Bada" }, r4 = i3.default.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, e4);
          return r4 && (t4.version = r4), t4;
        } }, { test: [/tizen/i], describe: function(e4) {
          var t4 = { name: "Tizen" }, r4 = i3.default.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, e4) || i3.default.getFirstMatch(s3, e4);
          return r4 && (t4.version = r4), t4;
        } }, { test: [/qupzilla/i], describe: function(e4) {
          var t4 = { name: "QupZilla" }, r4 = i3.default.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, e4) || i3.default.getFirstMatch(s3, e4);
          return r4 && (t4.version = r4), t4;
        } }, { test: [/firefox|iceweasel|fxios/i], describe: function(e4) {
          var t4 = { name: "Firefox" }, r4 = i3.default.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, e4);
          return r4 && (t4.version = r4), t4;
        } }, { test: [/electron/i], describe: function(e4) {
          var t4 = { name: "Electron" }, r4 = i3.default.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i, e4);
          return r4 && (t4.version = r4), t4;
        } }, { test: [/MiuiBrowser/i], describe: function(e4) {
          var t4 = { name: "Miui" }, r4 = i3.default.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i, e4);
          return r4 && (t4.version = r4), t4;
        } }, { test: [/chromium/i], describe: function(e4) {
          var t4 = { name: "Chromium" }, r4 = i3.default.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, e4) || i3.default.getFirstMatch(s3, e4);
          return r4 && (t4.version = r4), t4;
        } }, { test: [/chrome|crios|crmo/i], describe: function(e4) {
          var t4 = { name: "Chrome" }, r4 = i3.default.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, e4);
          return r4 && (t4.version = r4), t4;
        } }, { test: [/GSA/i], describe: function(e4) {
          var t4 = { name: "Google Search" }, r4 = i3.default.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, e4);
          return r4 && (t4.version = r4), t4;
        } }, { test: function(e4) {
          var t4 = !e4.test(/like android/i), r4 = e4.test(/android/i);
          return t4 && r4;
        }, describe: function(e4) {
          var t4 = { name: "Android Browser" }, r4 = i3.default.getFirstMatch(s3, e4);
          return r4 && (t4.version = r4), t4;
        } }, { test: [/playstation 4/i], describe: function(e4) {
          var t4 = { name: "PlayStation 4" }, r4 = i3.default.getFirstMatch(s3, e4);
          return r4 && (t4.version = r4), t4;
        } }, { test: [/safari|applewebkit/i], describe: function(e4) {
          var t4 = { name: "Safari" }, r4 = i3.default.getFirstMatch(s3, e4);
          return r4 && (t4.version = r4), t4;
        } }, { test: [/.*/i], describe: function(e4) {
          var t4 = e4.search("\\(") !== -1 ? /^(.*)\/(.*)[ \t]\((.*)/ : /^(.*)\/(.*) /;
          return { name: i3.default.getFirstMatch(t4, e4), version: i3.default.getSecondMatch(t4, e4) };
        } }];
        t3.default = a3, e3.exports = t3.default;
      }, 93: function(e3, t3, r3) {
        "use strict";
        t3.__esModule = true, t3.default = void 0;
        var n2, i3 = (n2 = r3(17)) && n2.__esModule ? n2 : { default: n2 }, s3 = r3(18);
        var a3 = [{ test: [/Roku\/DVP/], describe: function(e4) {
          var t4 = i3.default.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, e4);
          return { name: s3.OS_MAP.Roku, version: t4 };
        } }, { test: [/windows phone/i], describe: function(e4) {
          var t4 = i3.default.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, e4);
          return { name: s3.OS_MAP.WindowsPhone, version: t4 };
        } }, { test: [/windows /i], describe: function(e4) {
          var t4 = i3.default.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, e4), r4 = i3.default.getWindowsVersionName(t4);
          return { name: s3.OS_MAP.Windows, version: t4, versionName: r4 };
        } }, { test: [/Macintosh(.*?) FxiOS(.*?)\//], describe: function(e4) {
          var t4 = { name: s3.OS_MAP.iOS }, r4 = i3.default.getSecondMatch(/(Version\/)(\d[\d.]+)/, e4);
          return r4 && (t4.version = r4), t4;
        } }, { test: [/macintosh/i], describe: function(e4) {
          var t4 = i3.default.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, e4).replace(/[_\s]/g, "."), r4 = i3.default.getMacOSVersionName(t4), n3 = { name: s3.OS_MAP.MacOS, version: t4 };
          return r4 && (n3.versionName = r4), n3;
        } }, { test: [/(ipod|iphone|ipad)/i], describe: function(e4) {
          var t4 = i3.default.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i, e4).replace(/[_\s]/g, ".");
          return { name: s3.OS_MAP.iOS, version: t4 };
        } }, { test: function(e4) {
          var t4 = !e4.test(/like android/i), r4 = e4.test(/android/i);
          return t4 && r4;
        }, describe: function(e4) {
          var t4 = i3.default.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, e4), r4 = i3.default.getAndroidVersionName(t4), n3 = { name: s3.OS_MAP.Android, version: t4 };
          return r4 && (n3.versionName = r4), n3;
        } }, { test: [/(web|hpw)[o0]s/i], describe: function(e4) {
          var t4 = i3.default.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, e4), r4 = { name: s3.OS_MAP.WebOS };
          return t4 && t4.length && (r4.version = t4), r4;
        } }, { test: [/blackberry|\bbb\d+/i, /rim\stablet/i], describe: function(e4) {
          var t4 = i3.default.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, e4) || i3.default.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, e4) || i3.default.getFirstMatch(/\bbb(\d+)/i, e4);
          return { name: s3.OS_MAP.BlackBerry, version: t4 };
        } }, { test: [/bada/i], describe: function(e4) {
          var t4 = i3.default.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, e4);
          return { name: s3.OS_MAP.Bada, version: t4 };
        } }, { test: [/tizen/i], describe: function(e4) {
          var t4 = i3.default.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, e4);
          return { name: s3.OS_MAP.Tizen, version: t4 };
        } }, { test: [/linux/i], describe: function() {
          return { name: s3.OS_MAP.Linux };
        } }, { test: [/CrOS/], describe: function() {
          return { name: s3.OS_MAP.ChromeOS };
        } }, { test: [/PlayStation 4/], describe: function(e4) {
          var t4 = i3.default.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, e4);
          return { name: s3.OS_MAP.PlayStation4, version: t4 };
        } }];
        t3.default = a3, e3.exports = t3.default;
      }, 94: function(e3, t3, r3) {
        "use strict";
        t3.__esModule = true, t3.default = void 0;
        var n2, i3 = (n2 = r3(17)) && n2.__esModule ? n2 : { default: n2 }, s3 = r3(18);
        var a3 = [{ test: [/googlebot/i], describe: function() {
          return { type: "bot", vendor: "Google" };
        } }, { test: [/huawei/i], describe: function(e4) {
          var t4 = i3.default.getFirstMatch(/(can-l01)/i, e4) && "Nova", r4 = { type: s3.PLATFORMS_MAP.mobile, vendor: "Huawei" };
          return t4 && (r4.model = t4), r4;
        } }, { test: [/nexus\s*(?:7|8|9|10).*/i], describe: function() {
          return { type: s3.PLATFORMS_MAP.tablet, vendor: "Nexus" };
        } }, { test: [/ipad/i], describe: function() {
          return { type: s3.PLATFORMS_MAP.tablet, vendor: "Apple", model: "iPad" };
        } }, { test: [/Macintosh(.*?) FxiOS(.*?)\//], describe: function() {
          return { type: s3.PLATFORMS_MAP.tablet, vendor: "Apple", model: "iPad" };
        } }, { test: [/kftt build/i], describe: function() {
          return { type: s3.PLATFORMS_MAP.tablet, vendor: "Amazon", model: "Kindle Fire HD 7" };
        } }, { test: [/silk/i], describe: function() {
          return { type: s3.PLATFORMS_MAP.tablet, vendor: "Amazon" };
        } }, { test: [/tablet(?! pc)/i], describe: function() {
          return { type: s3.PLATFORMS_MAP.tablet };
        } }, { test: function(e4) {
          var t4 = e4.test(/ipod|iphone/i), r4 = e4.test(/like (ipod|iphone)/i);
          return t4 && !r4;
        }, describe: function(e4) {
          var t4 = i3.default.getFirstMatch(/(ipod|iphone)/i, e4);
          return { type: s3.PLATFORMS_MAP.mobile, vendor: "Apple", model: t4 };
        } }, { test: [/nexus\s*[0-6].*/i, /galaxy nexus/i], describe: function() {
          return { type: s3.PLATFORMS_MAP.mobile, vendor: "Nexus" };
        } }, { test: [/[^-]mobi/i], describe: function() {
          return { type: s3.PLATFORMS_MAP.mobile };
        } }, { test: function(e4) {
          return e4.getBrowserName(true) === "blackberry";
        }, describe: function() {
          return { type: s3.PLATFORMS_MAP.mobile, vendor: "BlackBerry" };
        } }, { test: function(e4) {
          return e4.getBrowserName(true) === "bada";
        }, describe: function() {
          return { type: s3.PLATFORMS_MAP.mobile };
        } }, { test: function(e4) {
          return e4.getBrowserName() === "windows phone";
        }, describe: function() {
          return { type: s3.PLATFORMS_MAP.mobile, vendor: "Microsoft" };
        } }, { test: function(e4) {
          var t4 = Number(String(e4.getOSVersion()).split(".")[0]);
          return e4.getOSName(true) === "android" && t4 >= 3;
        }, describe: function() {
          return { type: s3.PLATFORMS_MAP.tablet };
        } }, { test: function(e4) {
          return e4.getOSName(true) === "android";
        }, describe: function() {
          return { type: s3.PLATFORMS_MAP.mobile };
        } }, { test: function(e4) {
          return e4.getOSName(true) === "macos";
        }, describe: function() {
          return { type: s3.PLATFORMS_MAP.desktop, vendor: "Apple" };
        } }, { test: function(e4) {
          return e4.getOSName(true) === "windows";
        }, describe: function() {
          return { type: s3.PLATFORMS_MAP.desktop };
        } }, { test: function(e4) {
          return e4.getOSName(true) === "linux";
        }, describe: function() {
          return { type: s3.PLATFORMS_MAP.desktop };
        } }, { test: function(e4) {
          return e4.getOSName(true) === "playstation 4";
        }, describe: function() {
          return { type: s3.PLATFORMS_MAP.tv };
        } }, { test: function(e4) {
          return e4.getOSName(true) === "roku";
        }, describe: function() {
          return { type: s3.PLATFORMS_MAP.tv };
        } }];
        t3.default = a3, e3.exports = t3.default;
      }, 95: function(e3, t3, r3) {
        "use strict";
        t3.__esModule = true, t3.default = void 0;
        var n2, i3 = (n2 = r3(17)) && n2.__esModule ? n2 : { default: n2 }, s3 = r3(18);
        var a3 = [{ test: function(e4) {
          return e4.getBrowserName(true) === "microsoft edge";
        }, describe: function(e4) {
          if (/\sedg\//i.test(e4))
            return { name: s3.ENGINE_MAP.Blink };
          var t4 = i3.default.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, e4);
          return { name: s3.ENGINE_MAP.EdgeHTML, version: t4 };
        } }, { test: [/trident/i], describe: function(e4) {
          var t4 = { name: s3.ENGINE_MAP.Trident }, r4 = i3.default.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, e4);
          return r4 && (t4.version = r4), t4;
        } }, { test: function(e4) {
          return e4.test(/presto/i);
        }, describe: function(e4) {
          var t4 = { name: s3.ENGINE_MAP.Presto }, r4 = i3.default.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, e4);
          return r4 && (t4.version = r4), t4;
        } }, { test: function(e4) {
          var t4 = e4.test(/gecko/i), r4 = e4.test(/like gecko/i);
          return t4 && !r4;
        }, describe: function(e4) {
          var t4 = { name: s3.ENGINE_MAP.Gecko }, r4 = i3.default.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, e4);
          return r4 && (t4.version = r4), t4;
        } }, { test: [/(apple)?webkit\/537\.36/i], describe: function() {
          return { name: s3.ENGINE_MAP.Blink };
        } }, { test: [/(apple)?webkit/i], describe: function(e4) {
          var t4 = { name: s3.ENGINE_MAP.WebKit }, r4 = i3.default.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, e4);
          return r4 && (t4.version = r4), t4;
        } }];
        t3.default = a3, e3.exports = t3.default;
      } });
    });
  }
});

// (disabled):@aws-sdk/signature-v4-crt
var require_signature_v4_crt = __commonJS({
  "(disabled):@aws-sdk/signature-v4-crt"() {
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => S3UploaderPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// node_modules/@aws-sdk/protocol-http/dist-es/FieldPosition.js
var FieldPosition;
(function(FieldPosition3) {
  FieldPosition3[FieldPosition3["HEADER"] = 0] = "HEADER";
  FieldPosition3[FieldPosition3["TRAILER"] = 1] = "TRAILER";
})(FieldPosition || (FieldPosition = {}));

// node_modules/@aws-sdk/protocol-http/dist-es/httpRequest.js
var HttpRequest = class {
  constructor(options) {
    this.method = options.method || "GET";
    this.hostname = options.hostname || "localhost";
    this.port = options.port;
    this.query = options.query || {};
    this.headers = options.headers || {};
    this.body = options.body;
    this.protocol = options.protocol ? options.protocol.slice(-1) !== ":" ? `${options.protocol}:` : options.protocol : "https:";
    this.path = options.path ? options.path.charAt(0) !== "/" ? `/${options.path}` : options.path : "/";
  }
  static isInstance(request) {
    if (!request)
      return false;
    const req = request;
    return "method" in req && "protocol" in req && "hostname" in req && "path" in req && typeof req["query"] === "object" && typeof req["headers"] === "object";
  }
  clone() {
    const cloned = new HttpRequest({
      ...this,
      headers: { ...this.headers }
    });
    if (cloned.query)
      cloned.query = cloneQuery(cloned.query);
    return cloned;
  }
};
function cloneQuery(query) {
  return Object.keys(query).reduce((carry, paramName) => {
    const param = query[paramName];
    return {
      ...carry,
      [paramName]: Array.isArray(param) ? [...param] : param
    };
  }, {});
}

// node_modules/@aws-sdk/protocol-http/dist-es/httpResponse.js
var HttpResponse = class {
  constructor(options) {
    this.statusCode = options.statusCode;
    this.headers = options.headers || {};
    this.body = options.body;
  }
  static isInstance(response) {
    if (!response)
      return false;
    const resp = response;
    return typeof resp.statusCode === "number" && typeof resp.headers === "object";
  }
};

// node_modules/@aws-sdk/util-uri-escape/dist-es/escape-uri.js
var escapeUri = (uri) => encodeURIComponent(uri).replace(/[!'()*]/g, hexEncode);
var hexEncode = (c3) => `%${c3.charCodeAt(0).toString(16).toUpperCase()}`;

// node_modules/@aws-sdk/querystring-builder/dist-es/index.js
function buildQueryString(query) {
  const parts = [];
  for (let key of Object.keys(query).sort()) {
    const value = query[key];
    key = escapeUri(key);
    if (Array.isArray(value)) {
      for (let i3 = 0, iLen = value.length; i3 < iLen; i3++) {
        parts.push(`${key}=${escapeUri(value[i3])}`);
      }
    } else {
      let qsEntry = key;
      if (value || typeof value === "string") {
        qsEntry += `=${escapeUri(value)}`;
      }
      parts.push(qsEntry);
    }
  }
  return parts.join("&");
}

// node_modules/@smithy/fetch-http-handler/dist-es/request-timeout.js
function requestTimeout(timeoutInMs = 0) {
  return new Promise((resolve, reject) => {
    if (timeoutInMs) {
      setTimeout(() => {
        const timeoutError = new Error(`Request did not complete within ${timeoutInMs} ms`);
        timeoutError.name = "TimeoutError";
        reject(timeoutError);
      }, timeoutInMs);
    }
  });
}

// node_modules/@smithy/types/dist-es/auth/auth.js
var HttpAuthLocation;
(function(HttpAuthLocation3) {
  HttpAuthLocation3["HEADER"] = "header";
  HttpAuthLocation3["QUERY"] = "query";
})(HttpAuthLocation || (HttpAuthLocation = {}));

// node_modules/@smithy/types/dist-es/auth/HttpApiKeyAuth.js
var HttpApiKeyAuthLocation;
(function(HttpApiKeyAuthLocation2) {
  HttpApiKeyAuthLocation2["HEADER"] = "header";
  HttpApiKeyAuthLocation2["QUERY"] = "query";
})(HttpApiKeyAuthLocation || (HttpApiKeyAuthLocation = {}));

// node_modules/@smithy/types/dist-es/endpoint.js
var EndpointURLScheme;
(function(EndpointURLScheme3) {
  EndpointURLScheme3["HTTP"] = "http";
  EndpointURLScheme3["HTTPS"] = "https";
})(EndpointURLScheme || (EndpointURLScheme = {}));

// node_modules/@smithy/types/dist-es/extensions/checksum.js
var AlgorithmId;
(function(AlgorithmId2) {
  AlgorithmId2["MD5"] = "md5";
  AlgorithmId2["CRC32"] = "crc32";
  AlgorithmId2["CRC32C"] = "crc32c";
  AlgorithmId2["SHA1"] = "sha1";
  AlgorithmId2["SHA256"] = "sha256";
})(AlgorithmId || (AlgorithmId = {}));

// node_modules/@smithy/types/dist-es/http.js
var FieldPosition2;
(function(FieldPosition3) {
  FieldPosition3[FieldPosition3["HEADER"] = 0] = "HEADER";
  FieldPosition3[FieldPosition3["TRAILER"] = 1] = "TRAILER";
})(FieldPosition2 || (FieldPosition2 = {}));

// node_modules/@smithy/types/dist-es/profile.js
var IniSectionType;
(function(IniSectionType2) {
  IniSectionType2["PROFILE"] = "profile";
  IniSectionType2["SSO_SESSION"] = "sso-session";
  IniSectionType2["SERVICES"] = "services";
})(IniSectionType || (IniSectionType = {}));

// node_modules/@smithy/types/dist-es/transfer.js
var RequestHandlerProtocol;
(function(RequestHandlerProtocol3) {
  RequestHandlerProtocol3["HTTP_0_9"] = "http/0.9";
  RequestHandlerProtocol3["HTTP_1_0"] = "http/1.0";
  RequestHandlerProtocol3["TDS_8_0"] = "tds/8.0";
})(RequestHandlerProtocol || (RequestHandlerProtocol = {}));

// node_modules/@smithy/protocol-http/dist-es/httpResponse.js
var HttpResponse2 = class {
  constructor(options) {
    this.statusCode = options.statusCode;
    this.reason = options.reason;
    this.headers = options.headers || {};
    this.body = options.body;
  }
  static isInstance(response) {
    if (!response)
      return false;
    const resp = response;
    return typeof resp.statusCode === "number" && typeof resp.headers === "object";
  }
};

// node_modules/@smithy/util-uri-escape/dist-es/escape-uri.js
var escapeUri2 = (uri) => encodeURIComponent(uri).replace(/[!'()*]/g, hexEncode2);
var hexEncode2 = (c3) => `%${c3.charCodeAt(0).toString(16).toUpperCase()}`;

// node_modules/@smithy/querystring-builder/dist-es/index.js
function buildQueryString2(query) {
  const parts = [];
  for (let key of Object.keys(query).sort()) {
    const value = query[key];
    key = escapeUri2(key);
    if (Array.isArray(value)) {
      for (let i3 = 0, iLen = value.length; i3 < iLen; i3++) {
        parts.push(`${key}=${escapeUri2(value[i3])}`);
      }
    } else {
      let qsEntry = key;
      if (value || typeof value === "string") {
        qsEntry += `=${escapeUri2(value)}`;
      }
      parts.push(qsEntry);
    }
  }
  return parts.join("&");
}

// node_modules/@smithy/fetch-http-handler/dist-es/fetch-http-handler.js
var keepAliveSupport = {
  supported: Boolean(typeof Request !== "undefined" && "keepalive" in new Request("https://[::1]"))
};
var FetchHttpHandler = class {
  constructor(options) {
    if (typeof options === "function") {
      this.configProvider = options().then((opts) => opts || {});
    } else {
      this.config = options != null ? options : {};
      this.configProvider = Promise.resolve(this.config);
    }
  }
  destroy() {
  }
  async handle(request, { abortSignal } = {}) {
    var _a, _b;
    if (!this.config) {
      this.config = await this.configProvider;
    }
    const requestTimeoutInMs = this.config.requestTimeout;
    const keepAlive = this.config.keepAlive === true;
    if (abortSignal == null ? void 0 : abortSignal.aborted) {
      const abortError = new Error("Request aborted");
      abortError.name = "AbortError";
      return Promise.reject(abortError);
    }
    let path2 = request.path;
    const queryString = buildQueryString2(request.query || {});
    if (queryString) {
      path2 += `?${queryString}`;
    }
    if (request.fragment) {
      path2 += `#${request.fragment}`;
    }
    let auth = "";
    if (request.username != null || request.password != null) {
      const username = (_a = request.username) != null ? _a : "";
      const password = (_b = request.password) != null ? _b : "";
      auth = `${username}:${password}@`;
    }
    const { port, method } = request;
    const url = `${request.protocol}//${auth}${request.hostname}${port ? `:${port}` : ""}${path2}`;
    const body = method === "GET" || method === "HEAD" ? void 0 : request.body;
    const requestOptions = { body, headers: new Headers(request.headers), method };
    if (typeof AbortController !== "undefined") {
      requestOptions["signal"] = abortSignal;
    }
    if (keepAliveSupport.supported) {
      requestOptions["keepalive"] = keepAlive;
    }
    const fetchRequest = new Request(url, requestOptions);
    const raceOfPromises = [
      fetch(fetchRequest).then((response) => {
        const fetchHeaders = response.headers;
        const transformedHeaders = {};
        for (const pair of fetchHeaders.entries()) {
          transformedHeaders[pair[0]] = pair[1];
        }
        const hasReadableStream = response.body != void 0;
        if (!hasReadableStream) {
          return response.blob().then((body2) => ({
            response: new HttpResponse2({
              headers: transformedHeaders,
              reason: response.statusText,
              statusCode: response.status,
              body: body2
            })
          }));
        }
        return {
          response: new HttpResponse2({
            headers: transformedHeaders,
            reason: response.statusText,
            statusCode: response.status,
            body: response.body
          })
        };
      }),
      requestTimeout(requestTimeoutInMs)
    ];
    if (abortSignal) {
      raceOfPromises.push(new Promise((resolve, reject) => {
        abortSignal.onabort = () => {
          const abortError = new Error("Request aborted");
          abortError.name = "AbortError";
          reject(abortError);
        };
      }));
    }
    return Promise.race(raceOfPromises);
  }
  updateHttpClientConfig(key, value) {
    this.config = void 0;
    this.configProvider = this.configProvider.then((config) => {
      config[key] = value;
      return config;
    });
  }
  httpHandlerConfigs() {
    var _a;
    return (_a = this.config) != null ? _a : {};
  }
};

// node_modules/@smithy/util-base64/dist-es/constants.browser.js
var alphabetByEncoding = {};
var alphabetByValue = new Array(64);
for (let i3 = 0, start = "A".charCodeAt(0), limit = "Z".charCodeAt(0); i3 + start <= limit; i3++) {
  const char = String.fromCharCode(i3 + start);
  alphabetByEncoding[char] = i3;
  alphabetByValue[i3] = char;
}
for (let i3 = 0, start = "a".charCodeAt(0), limit = "z".charCodeAt(0); i3 + start <= limit; i3++) {
  const char = String.fromCharCode(i3 + start);
  const index = i3 + 26;
  alphabetByEncoding[char] = index;
  alphabetByValue[index] = char;
}
for (let i3 = 0; i3 < 10; i3++) {
  alphabetByEncoding[i3.toString(10)] = i3 + 52;
  const char = i3.toString(10);
  const index = i3 + 52;
  alphabetByEncoding[char] = index;
  alphabetByValue[index] = char;
}
alphabetByEncoding["+"] = 62;
alphabetByValue[62] = "+";
alphabetByEncoding["/"] = 63;
alphabetByValue[63] = "/";

// node_modules/filesize/dist/filesize.esm.js
var ARRAY = "array";
var BIT = "bit";
var BITS = "bits";
var BYTE = "byte";
var BYTES = "bytes";
var EMPTY = "";
var EXPONENT = "exponent";
var FUNCTION = "function";
var IEC = "iec";
var INVALID_NUMBER = "Invalid number";
var INVALID_ROUND = "Invalid rounding method";
var JEDEC = "jedec";
var OBJECT = "object";
var PERIOD = ".";
var ROUND = "round";
var S = "s";
var SI = "si";
var SI_KBIT = "kbit";
var SI_KBYTE = "kB";
var SPACE = " ";
var STRING = "string";
var ZERO = "0";
var STRINGS = {
  symbol: {
    iec: {
      bits: ["bit", "Kibit", "Mibit", "Gibit", "Tibit", "Pibit", "Eibit", "Zibit", "Yibit"],
      bytes: ["B", "KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"]
    },
    jedec: {
      bits: ["bit", "Kbit", "Mbit", "Gbit", "Tbit", "Pbit", "Ebit", "Zbit", "Ybit"],
      bytes: ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"]
    }
  },
  fullform: {
    iec: ["", "kibi", "mebi", "gibi", "tebi", "pebi", "exbi", "zebi", "yobi"],
    jedec: ["", "kilo", "mega", "giga", "tera", "peta", "exa", "zetta", "yotta"]
  }
};
function filesize(arg, {
  bits = false,
  pad = false,
  base = -1,
  round = 2,
  locale = EMPTY,
  localeOptions = {},
  separator = EMPTY,
  spacer = SPACE,
  symbols = {},
  standard = EMPTY,
  output = STRING,
  fullform = false,
  fullforms = [],
  exponent = -1,
  roundingMethod = ROUND,
  precision = 0
} = {}) {
  let e3 = exponent, num = Number(arg), result = [], val = 0, u2 = EMPTY;
  if (standard === SI) {
    base = 10;
    standard = JEDEC;
  } else if (standard === IEC || standard === JEDEC) {
    base = 2;
  } else if (base === 2) {
    standard = IEC;
  } else {
    base = 10;
    standard = JEDEC;
  }
  const ceil = base === 10 ? 1e3 : 1024, full = fullform === true, neg = num < 0, roundingFunc = Math[roundingMethod];
  if (typeof arg !== "bigint" && isNaN(arg)) {
    throw new TypeError(INVALID_NUMBER);
  }
  if (typeof roundingFunc !== FUNCTION) {
    throw new TypeError(INVALID_ROUND);
  }
  if (neg) {
    num = -num;
  }
  if (e3 === -1 || isNaN(e3)) {
    e3 = Math.floor(Math.log(num) / Math.log(ceil));
    if (e3 < 0) {
      e3 = 0;
    }
  }
  if (e3 > 8) {
    if (precision > 0) {
      precision += 8 - e3;
    }
    e3 = 8;
  }
  if (output === EXPONENT) {
    return e3;
  }
  if (num === 0) {
    result[0] = 0;
    u2 = result[1] = STRINGS.symbol[standard][bits ? BITS : BYTES][e3];
  } else {
    val = num / (base === 2 ? Math.pow(2, e3 * 10) : Math.pow(1e3, e3));
    if (bits) {
      val = val * 8;
      if (val >= ceil && e3 < 8) {
        val = val / ceil;
        e3++;
      }
    }
    const p2 = Math.pow(10, e3 > 0 ? round : 0);
    result[0] = roundingFunc(val * p2) / p2;
    if (result[0] === ceil && e3 < 8 && exponent === -1) {
      result[0] = 1;
      e3++;
    }
    u2 = result[1] = base === 10 && e3 === 1 ? bits ? SI_KBIT : SI_KBYTE : STRINGS.symbol[standard][bits ? BITS : BYTES][e3];
  }
  if (neg) {
    result[0] = -result[0];
  }
  if (precision > 0) {
    result[0] = result[0].toPrecision(precision);
  }
  result[1] = symbols[result[1]] || result[1];
  if (locale === true) {
    result[0] = result[0].toLocaleString();
  } else if (locale.length > 0) {
    result[0] = result[0].toLocaleString(locale, localeOptions);
  } else if (separator.length > 0) {
    result[0] = result[0].toString().replace(PERIOD, separator);
  }
  if (pad && round > 0) {
    const i3 = result[0].toString(), x2 = separator || ((i3.match(/(\D)/g) || []).pop() || PERIOD), tmp = i3.toString().split(x2), s3 = tmp[1] || EMPTY, l3 = s3.length, n2 = round - l3;
    result[0] = `${tmp[0]}${x2}${s3.padEnd(l3 + n2, ZERO)}`;
  }
  if (full) {
    result[1] = fullforms[e3] ? fullforms[e3] : STRINGS.fullform[standard][e3] + (bits ? BIT : BYTE) + (result[0] === 1 ? EMPTY : S);
  }
  return output === ARRAY ? result : output === OBJECT ? {
    value: result[0],
    symbol: result[1],
    exponent: e3,
    unit: u2
  } : result.join(spacer);
}

// node_modules/@aws-sdk/smithy-client/dist-es/NoOpLogger.js
var NoOpLogger = class {
  trace() {
  }
  debug() {
  }
  info() {
  }
  warn() {
  }
  error() {
  }
};

// node_modules/@aws-sdk/middleware-stack/dist-es/MiddlewareStack.js
var constructStack = () => {
  let absoluteEntries = [];
  let relativeEntries = [];
  const entriesNameSet = /* @__PURE__ */ new Set();
  const sort = (entries) => entries.sort((a3, b2) => stepWeights[b2.step] - stepWeights[a3.step] || priorityWeights[b2.priority || "normal"] - priorityWeights[a3.priority || "normal"]);
  const removeByName = (toRemove) => {
    let isRemoved = false;
    const filterCb = (entry) => {
      if (entry.name && entry.name === toRemove) {
        isRemoved = true;
        entriesNameSet.delete(toRemove);
        return false;
      }
      return true;
    };
    absoluteEntries = absoluteEntries.filter(filterCb);
    relativeEntries = relativeEntries.filter(filterCb);
    return isRemoved;
  };
  const removeByReference = (toRemove) => {
    let isRemoved = false;
    const filterCb = (entry) => {
      if (entry.middleware === toRemove) {
        isRemoved = true;
        if (entry.name)
          entriesNameSet.delete(entry.name);
        return false;
      }
      return true;
    };
    absoluteEntries = absoluteEntries.filter(filterCb);
    relativeEntries = relativeEntries.filter(filterCb);
    return isRemoved;
  };
  const cloneTo = (toStack) => {
    absoluteEntries.forEach((entry) => {
      toStack.add(entry.middleware, { ...entry });
    });
    relativeEntries.forEach((entry) => {
      toStack.addRelativeTo(entry.middleware, { ...entry });
    });
    return toStack;
  };
  const expandRelativeMiddlewareList = (from) => {
    const expandedMiddlewareList = [];
    from.before.forEach((entry) => {
      if (entry.before.length === 0 && entry.after.length === 0) {
        expandedMiddlewareList.push(entry);
      } else {
        expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
      }
    });
    expandedMiddlewareList.push(from);
    from.after.reverse().forEach((entry) => {
      if (entry.before.length === 0 && entry.after.length === 0) {
        expandedMiddlewareList.push(entry);
      } else {
        expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
      }
    });
    return expandedMiddlewareList;
  };
  const getMiddlewareList = (debug = false) => {
    const normalizedAbsoluteEntries = [];
    const normalizedRelativeEntries = [];
    const normalizedEntriesNameMap = {};
    absoluteEntries.forEach((entry) => {
      const normalizedEntry = {
        ...entry,
        before: [],
        after: []
      };
      if (normalizedEntry.name)
        normalizedEntriesNameMap[normalizedEntry.name] = normalizedEntry;
      normalizedAbsoluteEntries.push(normalizedEntry);
    });
    relativeEntries.forEach((entry) => {
      const normalizedEntry = {
        ...entry,
        before: [],
        after: []
      };
      if (normalizedEntry.name)
        normalizedEntriesNameMap[normalizedEntry.name] = normalizedEntry;
      normalizedRelativeEntries.push(normalizedEntry);
    });
    normalizedRelativeEntries.forEach((entry) => {
      if (entry.toMiddleware) {
        const toMiddleware = normalizedEntriesNameMap[entry.toMiddleware];
        if (toMiddleware === void 0) {
          if (debug) {
            return;
          }
          throw new Error(`${entry.toMiddleware} is not found when adding ${entry.name || "anonymous"} middleware ${entry.relation} ${entry.toMiddleware}`);
        }
        if (entry.relation === "after") {
          toMiddleware.after.push(entry);
        }
        if (entry.relation === "before") {
          toMiddleware.before.push(entry);
        }
      }
    });
    const mainChain = sort(normalizedAbsoluteEntries).map(expandRelativeMiddlewareList).reduce((wholeList, expendedMiddlewareList) => {
      wholeList.push(...expendedMiddlewareList);
      return wholeList;
    }, []);
    return mainChain;
  };
  const stack = {
    add: (middleware, options = {}) => {
      const { name, override } = options;
      const entry = {
        step: "initialize",
        priority: "normal",
        middleware,
        ...options
      };
      if (name) {
        if (entriesNameSet.has(name)) {
          if (!override)
            throw new Error(`Duplicate middleware name '${name}'`);
          const toOverrideIndex = absoluteEntries.findIndex((entry2) => entry2.name === name);
          const toOverride = absoluteEntries[toOverrideIndex];
          if (toOverride.step !== entry.step || toOverride.priority !== entry.priority) {
            throw new Error(`"${name}" middleware with ${toOverride.priority} priority in ${toOverride.step} step cannot be overridden by same-name middleware with ${entry.priority} priority in ${entry.step} step.`);
          }
          absoluteEntries.splice(toOverrideIndex, 1);
        }
        entriesNameSet.add(name);
      }
      absoluteEntries.push(entry);
    },
    addRelativeTo: (middleware, options) => {
      const { name, override } = options;
      const entry = {
        middleware,
        ...options
      };
      if (name) {
        if (entriesNameSet.has(name)) {
          if (!override)
            throw new Error(`Duplicate middleware name '${name}'`);
          const toOverrideIndex = relativeEntries.findIndex((entry2) => entry2.name === name);
          const toOverride = relativeEntries[toOverrideIndex];
          if (toOverride.toMiddleware !== entry.toMiddleware || toOverride.relation !== entry.relation) {
            throw new Error(`"${name}" middleware ${toOverride.relation} "${toOverride.toMiddleware}" middleware cannot be overridden by same-name middleware ${entry.relation} "${entry.toMiddleware}" middleware.`);
          }
          relativeEntries.splice(toOverrideIndex, 1);
        }
        entriesNameSet.add(name);
      }
      relativeEntries.push(entry);
    },
    clone: () => cloneTo(constructStack()),
    use: (plugin) => {
      plugin.applyToStack(stack);
    },
    remove: (toRemove) => {
      if (typeof toRemove === "string")
        return removeByName(toRemove);
      else
        return removeByReference(toRemove);
    },
    removeByTag: (toRemove) => {
      let isRemoved = false;
      const filterCb = (entry) => {
        const { tags, name } = entry;
        if (tags && tags.includes(toRemove)) {
          if (name)
            entriesNameSet.delete(name);
          isRemoved = true;
          return false;
        }
        return true;
      };
      absoluteEntries = absoluteEntries.filter(filterCb);
      relativeEntries = relativeEntries.filter(filterCb);
      return isRemoved;
    },
    concat: (from) => {
      const cloned = cloneTo(constructStack());
      cloned.use(from);
      return cloned;
    },
    applyToStack: cloneTo,
    identify: () => {
      return getMiddlewareList(true).map((mw) => {
        return mw.name + ": " + (mw.tags || []).join(",");
      });
    },
    resolve: (handler, context) => {
      for (const middleware of getMiddlewareList().map((entry) => entry.middleware).reverse()) {
        handler = middleware(handler, context);
      }
      return handler;
    }
  };
  return stack;
};
var stepWeights = {
  initialize: 5,
  serialize: 4,
  build: 3,
  finalizeRequest: 2,
  deserialize: 1
};
var priorityWeights = {
  high: 3,
  normal: 2,
  low: 1
};

// node_modules/@aws-sdk/smithy-client/dist-es/client.js
var Client = class {
  constructor(config) {
    this.middlewareStack = constructStack();
    this.config = config;
  }
  send(command, optionsOrCb, cb2) {
    const options = typeof optionsOrCb !== "function" ? optionsOrCb : void 0;
    const callback = typeof optionsOrCb === "function" ? optionsOrCb : cb2;
    const handler = command.resolveMiddleware(this.middlewareStack, this.config, options);
    if (callback) {
      handler(command).then((result) => callback(null, result.output), (err) => callback(err)).catch(() => {
      });
    } else {
      return handler(command).then((result) => result.output);
    }
  }
  destroy() {
    if (this.config.requestHandler.destroy)
      this.config.requestHandler.destroy();
  }
};

// node_modules/@aws-sdk/smithy-client/dist-es/command.js
var Command = class {
  constructor() {
    this.middlewareStack = constructStack();
  }
};

// node_modules/@aws-sdk/smithy-client/dist-es/constants.js
var SENSITIVE_STRING = "***SensitiveInformation***";

// node_modules/@aws-sdk/smithy-client/dist-es/parse-utils.js
var parseBoolean = (value) => {
  switch (value) {
    case "true":
      return true;
    case "false":
      return false;
    default:
      throw new Error(`Unable to parse boolean value "${value}"`);
  }
};
var MAX_FLOAT = Math.ceil(2 ** 127 * (2 - 2 ** -23));

// node_modules/@aws-sdk/smithy-client/dist-es/date-utils.js
var DAYS = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
var MONTHS = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
function dateToUtcString(date) {
  const year = date.getUTCFullYear();
  const month = date.getUTCMonth();
  const dayOfWeek = date.getUTCDay();
  const dayOfMonthInt = date.getUTCDate();
  const hoursInt = date.getUTCHours();
  const minutesInt = date.getUTCMinutes();
  const secondsInt = date.getUTCSeconds();
  const dayOfMonthString = dayOfMonthInt < 10 ? `0${dayOfMonthInt}` : `${dayOfMonthInt}`;
  const hoursString = hoursInt < 10 ? `0${hoursInt}` : `${hoursInt}`;
  const minutesString = minutesInt < 10 ? `0${minutesInt}` : `${minutesInt}`;
  const secondsString = secondsInt < 10 ? `0${secondsInt}` : `${secondsInt}`;
  return `${DAYS[dayOfWeek]}, ${dayOfMonthString} ${MONTHS[month]} ${year} ${hoursString}:${minutesString}:${secondsString} GMT`;
}
var RFC3339 = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?[zZ]$/);
var RFC3339_WITH_OFFSET = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?(([-+]\d{2}\:\d{2})|[zZ])$/);
var IMF_FIXDATE = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d{2}) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/);
var RFC_850_DATE = new RegExp(/^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/);
var ASC_TIME = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( [1-9]|\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? (\d{4})$/);
var FIFTY_YEARS_IN_MILLIS = 50 * 365 * 24 * 60 * 60 * 1e3;

// node_modules/@aws-sdk/smithy-client/dist-es/exceptions.js
var ServiceException = class extends Error {
  constructor(options) {
    super(options.message);
    Object.setPrototypeOf(this, ServiceException.prototype);
    this.name = options.name;
    this.$fault = options.$fault;
    this.$metadata = options.$metadata;
  }
};
var decorateServiceException = (exception, additions = {}) => {
  Object.entries(additions).filter(([, v2]) => v2 !== void 0).forEach(([k2, v2]) => {
    if (exception[k2] == void 0 || exception[k2] === "") {
      exception[k2] = v2;
    }
  });
  const message = exception.message || exception.Message || "UnknownError";
  exception.message = message;
  delete exception.Message;
  return exception;
};

// node_modules/@aws-sdk/smithy-client/dist-es/default-error-handler.js
var throwDefaultError = ({ output, parsedBody, exceptionCtor, errorCode }) => {
  const $metadata = deserializeMetadata(output);
  const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : void 0;
  const response = new exceptionCtor({
    name: (parsedBody == null ? void 0 : parsedBody.code) || (parsedBody == null ? void 0 : parsedBody.Code) || errorCode || statusCode || "UnknownError",
    $fault: "client",
    $metadata
  });
  throw decorateServiceException(response, parsedBody);
};
var withBaseException = (ExceptionCtor) => {
  return ({ output, parsedBody, errorCode }) => {
    throwDefaultError({ output, parsedBody, exceptionCtor: ExceptionCtor, errorCode });
  };
};
var deserializeMetadata = (output) => {
  var _a, _b;
  return {
    httpStatusCode: output.statusCode,
    requestId: (_b = (_a = output.headers["x-amzn-requestid"]) != null ? _a : output.headers["x-amzn-request-id"]) != null ? _b : output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"]
  };
};

// node_modules/@aws-sdk/smithy-client/dist-es/defaults-mode.js
var loadConfigsForDefaultMode = (mode) => {
  switch (mode) {
    case "standard":
      return {
        retryMode: "standard",
        connectionTimeout: 3100
      };
    case "in-region":
      return {
        retryMode: "standard",
        connectionTimeout: 1100
      };
    case "cross-region":
      return {
        retryMode: "standard",
        connectionTimeout: 3100
      };
    case "mobile":
      return {
        retryMode: "standard",
        connectionTimeout: 3e4
      };
    default:
      return {};
  }
};

// node_modules/@aws-sdk/smithy-client/dist-es/extended-encode-uri-component.js
function extendedEncodeURIComponent(str) {
  return encodeURIComponent(str).replace(/[!'()*]/g, function(c3) {
    return "%" + c3.charCodeAt(0).toString(16).toUpperCase();
  });
}

// node_modules/@aws-sdk/smithy-client/dist-es/get-value-from-text-node.js
var getValueFromTextNode = (obj) => {
  const textNodeName = "#text";
  for (const key in obj) {
    if (obj.hasOwnProperty(key) && obj[key][textNodeName] !== void 0) {
      obj[key] = obj[key][textNodeName];
    } else if (typeof obj[key] === "object" && obj[key] !== null) {
      obj[key] = getValueFromTextNode(obj[key]);
    }
  }
  return obj;
};

// node_modules/@aws-sdk/smithy-client/dist-es/lazy-json.js
var StringWrapper = function() {
  const Class = Object.getPrototypeOf(this).constructor;
  const Constructor = Function.bind.apply(String, [null, ...arguments]);
  const instance = new Constructor();
  Object.setPrototypeOf(instance, Class.prototype);
  return instance;
};
StringWrapper.prototype = Object.create(String.prototype, {
  constructor: {
    value: StringWrapper,
    enumerable: false,
    writable: true,
    configurable: true
  }
});
Object.setPrototypeOf(StringWrapper, String);

// node_modules/@aws-sdk/smithy-client/dist-es/object-mapping.js
function map(arg0, arg1, arg2) {
  let target;
  let filter2;
  let instructions;
  if (typeof arg1 === "undefined" && typeof arg2 === "undefined") {
    target = {};
    instructions = arg0;
  } else {
    target = arg0;
    if (typeof arg1 === "function") {
      filter2 = arg1;
      instructions = arg2;
      return mapWithFilter(target, filter2, instructions);
    } else {
      instructions = arg1;
    }
  }
  for (const key of Object.keys(instructions)) {
    if (!Array.isArray(instructions[key])) {
      target[key] = instructions[key];
      continue;
    }
    applyInstruction(target, null, instructions, key);
  }
  return target;
}
var mapWithFilter = (target, filter2, instructions) => {
  return map(target, Object.entries(instructions).reduce((_instructions, [key, value]) => {
    if (Array.isArray(value)) {
      _instructions[key] = value;
    } else {
      if (typeof value === "function") {
        _instructions[key] = [filter2, value()];
      } else {
        _instructions[key] = [filter2, value];
      }
    }
    return _instructions;
  }, {}));
};
var applyInstruction = (target, source, instructions, targetKey) => {
  if (source !== null) {
    let instruction = instructions[targetKey];
    if (typeof instruction === "function") {
      instruction = [, instruction];
    }
    const [filter3 = nonNullish, valueFn = pass, sourceKey = targetKey] = instruction;
    if (typeof filter3 === "function" && filter3(source[sourceKey]) || typeof filter3 !== "function" && !!filter3) {
      target[targetKey] = valueFn(source[sourceKey]);
    }
    return;
  }
  let [filter2, value] = instructions[targetKey];
  if (typeof value === "function") {
    let _value;
    const defaultFilterPassed = filter2 === void 0 && (_value = value()) != null;
    const customFilterPassed = typeof filter2 === "function" && !!filter2(void 0) || typeof filter2 !== "function" && !!filter2;
    if (defaultFilterPassed) {
      target[targetKey] = _value;
    } else if (customFilterPassed) {
      target[targetKey] = value();
    }
  } else {
    const defaultFilterPassed = filter2 === void 0 && value != null;
    const customFilterPassed = typeof filter2 === "function" && !!filter2(value) || typeof filter2 !== "function" && !!filter2;
    if (defaultFilterPassed || customFilterPassed) {
      target[targetKey] = value;
    }
  }
};
var nonNullish = (_) => _ != null;
var pass = (_) => _;

// node_modules/@aws-sdk/smithy-client/dist-es/resolve-path.js
var resolvedPath = (resolvedPath2, input, memberName, labelValueProvider, uriLabel, isGreedyLabel) => {
  if (input != null && input[memberName] !== void 0) {
    const labelValue = labelValueProvider();
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: " + memberName + ".");
    }
    resolvedPath2 = resolvedPath2.replace(uriLabel, isGreedyLabel ? labelValue.split("/").map((segment) => extendedEncodeURIComponent(segment)).join("/") : extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: " + memberName + ".");
  }
  return resolvedPath2;
};

// node_modules/@aws-sdk/middleware-endpoint/dist-es/service-customizations/s3.js
var resolveParamsForS3 = async (endpointParams) => {
  const bucket = (endpointParams == null ? void 0 : endpointParams.Bucket) || "";
  if (typeof endpointParams.Bucket === "string") {
    endpointParams.Bucket = bucket.replace(/#/g, encodeURIComponent("#")).replace(/\?/g, encodeURIComponent("?"));
  }
  if (isArnBucketName(bucket)) {
    if (endpointParams.ForcePathStyle === true) {
      throw new Error("Path-style addressing cannot be used with ARN buckets");
    }
  } else if (!isDnsCompatibleBucketName(bucket) || bucket.indexOf(".") !== -1 && !String(endpointParams.Endpoint).startsWith("http:") || bucket.toLowerCase() !== bucket || bucket.length < 3) {
    endpointParams.ForcePathStyle = true;
  }
  if (endpointParams.DisableMultiRegionAccessPoints) {
    endpointParams.disableMultiRegionAccessPoints = true;
    endpointParams.DisableMRAP = true;
  }
  return endpointParams;
};
var DOMAIN_PATTERN = /^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/;
var IP_ADDRESS_PATTERN = /(\d+\.){3}\d+/;
var DOTS_PATTERN = /\.\./;
var isDnsCompatibleBucketName = (bucketName) => DOMAIN_PATTERN.test(bucketName) && !IP_ADDRESS_PATTERN.test(bucketName) && !DOTS_PATTERN.test(bucketName);
var isArnBucketName = (bucketName) => {
  const [arn, partition2, service, region, account, typeOrId] = bucketName.split(":");
  const isArn = arn === "arn" && bucketName.split(":").length >= 6;
  const isValidArn = [arn, partition2, service, account, typeOrId].filter(Boolean).length === 5;
  if (isArn && !isValidArn) {
    throw new Error(`Invalid ARN: ${bucketName} was an invalid ARN.`);
  }
  return arn === "arn" && !!partition2 && !!service && !!account && !!typeOrId;
};

// node_modules/@aws-sdk/middleware-endpoint/dist-es/adaptors/createConfigValueProvider.js
var createConfigValueProvider = (configKey, canonicalEndpointParamKey, config) => {
  const configProvider = async () => {
    var _a;
    const configValue = (_a = config[configKey]) != null ? _a : config[canonicalEndpointParamKey];
    if (typeof configValue === "function") {
      return configValue();
    }
    return configValue;
  };
  if (configKey === "endpoint" || canonicalEndpointParamKey === "endpoint") {
    return async () => {
      const endpoint = await configProvider();
      if (endpoint && typeof endpoint === "object") {
        if ("url" in endpoint) {
          return endpoint.url.href;
        }
        if ("hostname" in endpoint) {
          const { protocol, hostname, port, path: path2 } = endpoint;
          return `${protocol}//${hostname}${port ? ":" + port : ""}${path2}`;
        }
      }
      return endpoint;
    };
  }
  return configProvider;
};

// node_modules/@aws-sdk/middleware-endpoint/dist-es/adaptors/getEndpointFromInstructions.js
var getEndpointFromInstructions = async (commandInput, instructionsSupplier, clientConfig, context) => {
  const endpointParams = await resolveParams(commandInput, instructionsSupplier, clientConfig);
  if (typeof clientConfig.endpointProvider !== "function") {
    throw new Error("config.endpointProvider is not set.");
  }
  const endpoint = clientConfig.endpointProvider(endpointParams, context);
  return endpoint;
};
var resolveParams = async (commandInput, instructionsSupplier, clientConfig) => {
  var _a;
  const endpointParams = {};
  const instructions = ((_a = instructionsSupplier == null ? void 0 : instructionsSupplier.getEndpointParameterInstructions) == null ? void 0 : _a.call(instructionsSupplier)) || {};
  for (const [name, instruction] of Object.entries(instructions)) {
    switch (instruction.type) {
      case "staticContextParams":
        endpointParams[name] = instruction.value;
        break;
      case "contextParams":
        endpointParams[name] = commandInput[instruction.name];
        break;
      case "clientContextParams":
      case "builtInParams":
        endpointParams[name] = await createConfigValueProvider(instruction.name, name, clientConfig)();
        break;
      default:
        throw new Error("Unrecognized endpoint parameter instruction: " + JSON.stringify(instruction));
    }
  }
  if (Object.keys(instructions).length === 0) {
    Object.assign(endpointParams, clientConfig);
  }
  if (String(clientConfig.serviceId).toLowerCase() === "s3") {
    await resolveParamsForS3(endpointParams);
  }
  return endpointParams;
};

// node_modules/@aws-sdk/querystring-parser/dist-es/index.js
function parseQueryString(querystring) {
  const query = {};
  querystring = querystring.replace(/^\?/, "");
  if (querystring) {
    for (const pair of querystring.split("&")) {
      let [key, value = null] = pair.split("=");
      key = decodeURIComponent(key);
      if (value) {
        value = decodeURIComponent(value);
      }
      if (!(key in query)) {
        query[key] = value;
      } else if (Array.isArray(query[key])) {
        query[key].push(value);
      } else {
        query[key] = [query[key], value];
      }
    }
  }
  return query;
}

// node_modules/@aws-sdk/url-parser/dist-es/index.js
var parseUrl = (url) => {
  if (typeof url === "string") {
    return parseUrl(new URL(url));
  }
  const { hostname, pathname, port, protocol, search } = url;
  let query;
  if (search) {
    query = parseQueryString(search);
  }
  return {
    hostname,
    port: port ? parseInt(port) : void 0,
    protocol,
    path: pathname,
    query
  };
};

// node_modules/@aws-sdk/middleware-endpoint/dist-es/adaptors/toEndpointV1.js
var toEndpointV1 = (endpoint) => {
  if (typeof endpoint === "object") {
    if ("url" in endpoint) {
      return parseUrl(endpoint.url);
    }
    return endpoint;
  }
  return parseUrl(endpoint);
};

// node_modules/@aws-sdk/middleware-endpoint/dist-es/endpointMiddleware.js
var endpointMiddleware = ({ config, instructions }) => {
  return (next, context) => async (args) => {
    var _a, _b;
    const endpoint = await getEndpointFromInstructions(args.input, {
      getEndpointParameterInstructions() {
        return instructions;
      }
    }, { ...config }, context);
    context.endpointV2 = endpoint;
    context.authSchemes = (_a = endpoint.properties) == null ? void 0 : _a.authSchemes;
    const authScheme = (_b = context.authSchemes) == null ? void 0 : _b[0];
    if (authScheme) {
      context["signing_region"] = authScheme.signingRegion;
      context["signing_service"] = authScheme.signingName;
    }
    return next({
      ...args
    });
  };
};

// node_modules/@aws-sdk/middleware-serde/dist-es/deserializerMiddleware.js
var deserializerMiddleware = (options, deserializer) => (next, context) => async (args) => {
  const { response } = await next(args);
  try {
    const parsed = await deserializer(response, options);
    return {
      response,
      output: parsed
    };
  } catch (error) {
    Object.defineProperty(error, "$response", {
      value: response
    });
    if (!("$metadata" in error)) {
      const hint = `Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.`;
      error.message += "\n  " + hint;
    }
    throw error;
  }
};

// node_modules/@aws-sdk/middleware-serde/dist-es/serializerMiddleware.js
var serializerMiddleware = (options, serializer) => (next, context) => async (args) => {
  var _a;
  const endpoint = ((_a = context.endpointV2) == null ? void 0 : _a.url) && options.urlParser ? async () => options.urlParser(context.endpointV2.url) : options.endpoint;
  if (!endpoint) {
    throw new Error("No valid endpoint provider available.");
  }
  const request = await serializer(args.input, { ...options, endpoint });
  return next({
    ...args,
    request
  });
};

// node_modules/@aws-sdk/middleware-serde/dist-es/serdePlugin.js
var deserializerMiddlewareOption = {
  name: "deserializerMiddleware",
  step: "deserialize",
  tags: ["DESERIALIZER"],
  override: true
};
var serializerMiddlewareOption = {
  name: "serializerMiddleware",
  step: "serialize",
  tags: ["SERIALIZER"],
  override: true
};
function getSerdePlugin(config, serializer, deserializer) {
  return {
    applyToStack: (commandStack) => {
      commandStack.add(deserializerMiddleware(config, deserializer), deserializerMiddlewareOption);
      commandStack.add(serializerMiddleware(config, serializer), serializerMiddlewareOption);
    }
  };
}

// node_modules/@aws-sdk/middleware-endpoint/dist-es/getEndpointPlugin.js
var endpointMiddlewareOptions = {
  step: "serialize",
  tags: ["ENDPOINT_PARAMETERS", "ENDPOINT_V2", "ENDPOINT"],
  name: "endpointV2Middleware",
  override: true,
  relation: "before",
  toMiddleware: serializerMiddlewareOption.name
};
var getEndpointPlugin = (config, instructions) => ({
  applyToStack: (clientStack) => {
    clientStack.addRelativeTo(endpointMiddleware({
      config,
      instructions
    }), endpointMiddlewareOptions);
  }
});

// node_modules/@aws-sdk/util-middleware/dist-es/normalizeProvider.js
var normalizeProvider = (input) => {
  if (typeof input === "function")
    return input;
  const promisified = Promise.resolve(input);
  return () => promisified;
};

// node_modules/@aws-sdk/middleware-endpoint/dist-es/resolveEndpointConfig.js
var resolveEndpointConfig = (input) => {
  var _a, _b, _c;
  const tls = (_a = input.tls) != null ? _a : true;
  const { endpoint } = input;
  const customEndpointProvider = endpoint != null ? async () => toEndpointV1(await normalizeProvider(endpoint)()) : void 0;
  const isCustomEndpoint = !!endpoint;
  return {
    ...input,
    endpoint: customEndpointProvider,
    tls,
    isCustomEndpoint,
    useDualstackEndpoint: normalizeProvider((_b = input.useDualstackEndpoint) != null ? _b : false),
    useFipsEndpoint: normalizeProvider((_c = input.useFipsEndpoint) != null ? _c : false)
  };
};

// node_modules/@aws-sdk/client-s3/dist-es/protocols/Aws_restXml.js
var import_fast_xml_parser = __toESM(require_fxp());

// node_modules/@aws-sdk/client-s3/dist-es/models/S3ServiceException.js
var S3ServiceException = class extends ServiceException {
  constructor(options) {
    super(options);
    Object.setPrototypeOf(this, S3ServiceException.prototype);
  }
};

// node_modules/@aws-sdk/client-s3/dist-es/models/models_0.js
var AnalyticsFilter;
(function(AnalyticsFilter2) {
  AnalyticsFilter2.visit = (value, visitor) => {
    if (value.Prefix !== void 0)
      return visitor.Prefix(value.Prefix);
    if (value.Tag !== void 0)
      return visitor.Tag(value.Tag);
    if (value.And !== void 0)
      return visitor.And(value.And);
    return visitor._(value.$unknown[0], value.$unknown[1]);
  };
})(AnalyticsFilter || (AnalyticsFilter = {}));
var LifecycleRuleFilter;
(function(LifecycleRuleFilter2) {
  LifecycleRuleFilter2.visit = (value, visitor) => {
    if (value.Prefix !== void 0)
      return visitor.Prefix(value.Prefix);
    if (value.Tag !== void 0)
      return visitor.Tag(value.Tag);
    if (value.ObjectSizeGreaterThan !== void 0)
      return visitor.ObjectSizeGreaterThan(value.ObjectSizeGreaterThan);
    if (value.ObjectSizeLessThan !== void 0)
      return visitor.ObjectSizeLessThan(value.ObjectSizeLessThan);
    if (value.And !== void 0)
      return visitor.And(value.And);
    return visitor._(value.$unknown[0], value.$unknown[1]);
  };
})(LifecycleRuleFilter || (LifecycleRuleFilter = {}));
var MetricsFilter;
(function(MetricsFilter2) {
  MetricsFilter2.visit = (value, visitor) => {
    if (value.Prefix !== void 0)
      return visitor.Prefix(value.Prefix);
    if (value.Tag !== void 0)
      return visitor.Tag(value.Tag);
    if (value.AccessPointArn !== void 0)
      return visitor.AccessPointArn(value.AccessPointArn);
    if (value.And !== void 0)
      return visitor.And(value.And);
    return visitor._(value.$unknown[0], value.$unknown[1]);
  };
})(MetricsFilter || (MetricsFilter = {}));
var ReplicationRuleFilter;
(function(ReplicationRuleFilter2) {
  ReplicationRuleFilter2.visit = (value, visitor) => {
    if (value.Prefix !== void 0)
      return visitor.Prefix(value.Prefix);
    if (value.Tag !== void 0)
      return visitor.Tag(value.Tag);
    if (value.And !== void 0)
      return visitor.And(value.And);
    return visitor._(value.$unknown[0], value.$unknown[1]);
  };
})(ReplicationRuleFilter || (ReplicationRuleFilter = {}));
var PutObjectOutputFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.SSEKMSKeyId && { SSEKMSKeyId: SENSITIVE_STRING },
  ...obj.SSEKMSEncryptionContext && { SSEKMSEncryptionContext: SENSITIVE_STRING }
});
var PutObjectRequestFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.SSECustomerKey && { SSECustomerKey: SENSITIVE_STRING },
  ...obj.SSEKMSKeyId && { SSEKMSKeyId: SENSITIVE_STRING },
  ...obj.SSEKMSEncryptionContext && { SSEKMSEncryptionContext: SENSITIVE_STRING }
});

// node_modules/@aws-sdk/client-s3/dist-es/protocols/Aws_restXml.js
var se_PutObjectCommand = async (input, context) => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers = map({}, isSerializableHeaderValue, {
    "content-type": input.ContentType || "application/octet-stream",
    "x-amz-acl": input.ACL,
    "cache-control": input.CacheControl,
    "content-disposition": input.ContentDisposition,
    "content-encoding": input.ContentEncoding,
    "content-language": input.ContentLanguage,
    "content-length": [() => isSerializableHeaderValue(input.ContentLength), () => input.ContentLength.toString()],
    "content-md5": input.ContentMD5,
    "x-amz-sdk-checksum-algorithm": input.ChecksumAlgorithm,
    "x-amz-checksum-crc32": input.ChecksumCRC32,
    "x-amz-checksum-crc32c": input.ChecksumCRC32C,
    "x-amz-checksum-sha1": input.ChecksumSHA1,
    "x-amz-checksum-sha256": input.ChecksumSHA256,
    expires: [() => isSerializableHeaderValue(input.Expires), () => dateToUtcString(input.Expires).toString()],
    "x-amz-grant-full-control": input.GrantFullControl,
    "x-amz-grant-read": input.GrantRead,
    "x-amz-grant-read-acp": input.GrantReadACP,
    "x-amz-grant-write-acp": input.GrantWriteACP,
    "x-amz-server-side-encryption": input.ServerSideEncryption,
    "x-amz-storage-class": input.StorageClass,
    "x-amz-website-redirect-location": input.WebsiteRedirectLocation,
    "x-amz-server-side-encryption-customer-algorithm": input.SSECustomerAlgorithm,
    "x-amz-server-side-encryption-customer-key": input.SSECustomerKey,
    "x-amz-server-side-encryption-customer-key-md5": input.SSECustomerKeyMD5,
    "x-amz-server-side-encryption-aws-kms-key-id": input.SSEKMSKeyId,
    "x-amz-server-side-encryption-context": input.SSEKMSEncryptionContext,
    "x-amz-server-side-encryption-bucket-key-enabled": [
      () => isSerializableHeaderValue(input.BucketKeyEnabled),
      () => input.BucketKeyEnabled.toString()
    ],
    "x-amz-request-payer": input.RequestPayer,
    "x-amz-tagging": input.Tagging,
    "x-amz-object-lock-mode": input.ObjectLockMode,
    "x-amz-object-lock-retain-until-date": [
      () => isSerializableHeaderValue(input.ObjectLockRetainUntilDate),
      () => (input.ObjectLockRetainUntilDate.toISOString().split(".")[0] + "Z").toString()
    ],
    "x-amz-object-lock-legal-hold": input.ObjectLockLegalHoldStatus,
    "x-amz-expected-bucket-owner": input.ExpectedBucketOwner,
    ...input.Metadata !== void 0 && Object.keys(input.Metadata).reduce((acc, suffix) => {
      acc[`x-amz-meta-${suffix.toLowerCase()}`] = input.Metadata[suffix];
      return acc;
    }, {})
  });
  let resolvedPath2 = `${(basePath == null ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}/{Key+}`;
  resolvedPath2 = resolvedPath(resolvedPath2, input, "Bucket", () => input.Bucket, "{Bucket}", false);
  resolvedPath2 = resolvedPath(resolvedPath2, input, "Key", () => input.Key, "{Key+}", true);
  const query = map({
    "x-id": [, "PutObject"]
  });
  let body;
  if (input.Body !== void 0) {
    body = input.Body;
  }
  let contents;
  if (input.Body !== void 0) {
    contents = input.Body;
    body = contents;
  }
  return new HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath2,
    query,
    body
  });
};
var de_PutObjectCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return de_PutObjectCommandError(output, context);
  }
  const contents = map({
    $metadata: deserializeMetadata2(output),
    Expiration: [, output.headers["x-amz-expiration"]],
    ETag: [, output.headers["etag"]],
    ChecksumCRC32: [, output.headers["x-amz-checksum-crc32"]],
    ChecksumCRC32C: [, output.headers["x-amz-checksum-crc32c"]],
    ChecksumSHA1: [, output.headers["x-amz-checksum-sha1"]],
    ChecksumSHA256: [, output.headers["x-amz-checksum-sha256"]],
    ServerSideEncryption: [, output.headers["x-amz-server-side-encryption"]],
    VersionId: [, output.headers["x-amz-version-id"]],
    SSECustomerAlgorithm: [, output.headers["x-amz-server-side-encryption-customer-algorithm"]],
    SSECustomerKeyMD5: [, output.headers["x-amz-server-side-encryption-customer-key-md5"]],
    SSEKMSKeyId: [, output.headers["x-amz-server-side-encryption-aws-kms-key-id"]],
    SSEKMSEncryptionContext: [, output.headers["x-amz-server-side-encryption-context"]],
    BucketKeyEnabled: [
      () => output.headers["x-amz-server-side-encryption-bucket-key-enabled"] !== void 0,
      () => parseBoolean(output.headers["x-amz-server-side-encryption-bucket-key-enabled"])
    ],
    RequestCharged: [, output.headers["x-amz-request-charged"]]
  });
  await collectBody(output.body, context);
  return contents;
};
var de_PutObjectCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  const parsedBody = parsedOutput.body;
  return throwDefaultError2({
    output,
    parsedBody,
    errorCode
  });
};
var throwDefaultError2 = withBaseException(S3ServiceException);
var deserializeMetadata2 = (output) => {
  var _a, _b;
  return {
    httpStatusCode: output.statusCode,
    requestId: (_b = (_a = output.headers["x-amzn-requestid"]) != null ? _a : output.headers["x-amzn-request-id"]) != null ? _b : output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"]
  };
};
var collectBody = (streamBody = new Uint8Array(), context) => {
  if (streamBody instanceof Uint8Array) {
    return Promise.resolve(streamBody);
  }
  return context.streamCollector(streamBody) || Promise.resolve(new Uint8Array());
};
var collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
var isSerializableHeaderValue = (value) => value !== void 0 && value !== null && value !== "" && (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) && (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
var parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
  if (encoded.length) {
    const parser = new import_fast_xml_parser.XMLParser({
      attributeNamePrefix: "",
      htmlEntities: true,
      ignoreAttributes: false,
      ignoreDeclaration: true,
      parseTagValue: false,
      trimValues: false,
      tagValueProcessor: (_, val) => val.trim() === "" && val.includes("\n") ? "" : void 0
    });
    parser.addEntity("#xD", "\r");
    parser.addEntity("#10", "\n");
    const parsedObj = parser.parse(encoded);
    const textNodeName = "#text";
    const key = Object.keys(parsedObj)[0];
    const parsedObjToReturn = parsedObj[key];
    if (parsedObjToReturn[textNodeName]) {
      parsedObjToReturn[key] = parsedObjToReturn[textNodeName];
      delete parsedObjToReturn[textNodeName];
    }
    return getValueFromTextNode(parsedObjToReturn);
  }
  return {};
});
var parseErrorBody = async (errorBody, context) => {
  var _a;
  const value = await parseBody(errorBody, context);
  if (value.Error) {
    value.Error.message = (_a = value.Error.message) != null ? _a : value.Error.Message;
  }
  return value;
};
var loadRestXmlErrorCode = (output, data) => {
  if ((data == null ? void 0 : data.Code) !== void 0) {
    return data.Code;
  }
  if (output.statusCode == 404) {
    return "NotFound";
  }
};

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/check-content-length-header.js
var CONTENT_LENGTH_HEADER = "content-length";
function checkContentLengthHeader() {
  return (next, context) => async (args) => {
    var _a;
    const { request } = args;
    if (HttpRequest.isInstance(request)) {
      if (!request.headers[CONTENT_LENGTH_HEADER]) {
        const message = `Are you using a Stream of unknown length as the Body of a PutObject request? Consider using Upload instead from @aws-sdk/lib-storage.`;
        if (typeof ((_a = context == null ? void 0 : context.logger) == null ? void 0 : _a.warn) === "function") {
          context.logger.warn(message);
        } else {
          console.warn(message);
        }
      }
    }
    return next({ ...args });
  };
}
var checkContentLengthHeaderMiddlewareOptions = {
  step: "finalizeRequest",
  tags: ["CHECK_CONTENT_LENGTH_HEADER"],
  name: "getCheckContentLengthHeaderPlugin",
  override: true
};
var getCheckContentLengthHeaderPlugin = (unused) => ({
  applyToStack: (clientStack) => {
    clientStack.add(checkContentLengthHeader(), checkContentLengthHeaderMiddlewareOptions);
  }
});

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/configuration.js
var resolveS3Config = (input) => {
  var _a, _b, _c;
  return {
    ...input,
    forcePathStyle: (_a = input.forcePathStyle) != null ? _a : false,
    useAccelerateEndpoint: (_b = input.useAccelerateEndpoint) != null ? _b : false,
    disableMultiregionAccessPoints: (_c = input.disableMultiregionAccessPoints) != null ? _c : false
  };
};

// node_modules/@aws-sdk/util-arn-parser/dist-es/index.js
var validate = (str) => typeof str === "string" && str.indexOf("arn:") === 0 && str.split(":").length >= 6;

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/validate-bucket-name.js
function validateBucketNameMiddleware() {
  return (next) => async (args) => {
    const { input: { Bucket } } = args;
    if (typeof Bucket === "string" && !validate(Bucket) && Bucket.indexOf("/") >= 0) {
      const err = new Error(`Bucket name shouldn't contain '/', received '${Bucket}'`);
      err.name = "InvalidBucketName";
      throw err;
    }
    return next({ ...args });
  };
}
var validateBucketNameMiddlewareOptions = {
  step: "initialize",
  tags: ["VALIDATE_BUCKET_NAME"],
  name: "validateBucketNameMiddleware",
  override: true
};
var getValidateBucketNamePlugin = (unused) => ({
  applyToStack: (clientStack) => {
    clientStack.add(validateBucketNameMiddleware(), validateBucketNameMiddlewareOptions);
  }
});

// node_modules/@aws-sdk/middleware-ssec/dist-es/index.js
function ssecMiddleware(options) {
  return (next) => async (args) => {
    let input = { ...args.input };
    const properties = [
      {
        target: "SSECustomerKey",
        hash: "SSECustomerKeyMD5"
      },
      {
        target: "CopySourceSSECustomerKey",
        hash: "CopySourceSSECustomerKeyMD5"
      }
    ];
    for (const prop of properties) {
      const value = input[prop.target];
      if (value) {
        const valueView = ArrayBuffer.isView(value) ? new Uint8Array(value.buffer, value.byteOffset, value.byteLength) : typeof value === "string" ? options.utf8Decoder(value) : new Uint8Array(value);
        const encoded = options.base64Encoder(valueView);
        const hash = new options.md5();
        hash.update(valueView);
        input = {
          ...input,
          [prop.target]: encoded,
          [prop.hash]: options.base64Encoder(await hash.digest())
        };
      }
    }
    return next({
      ...args,
      input
    });
  };
}
var ssecMiddlewareOptions = {
  name: "ssecMiddleware",
  step: "initialize",
  tags: ["SSE"],
  override: true
};
var getSsecPlugin = (config) => ({
  applyToStack: (clientStack) => {
    clientStack.add(ssecMiddleware(config), ssecMiddlewareOptions);
  }
});

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/constants.js
var ChecksumAlgorithm;
(function(ChecksumAlgorithm2) {
  ChecksumAlgorithm2["MD5"] = "MD5";
  ChecksumAlgorithm2["CRC32"] = "CRC32";
  ChecksumAlgorithm2["CRC32C"] = "CRC32C";
  ChecksumAlgorithm2["SHA1"] = "SHA1";
  ChecksumAlgorithm2["SHA256"] = "SHA256";
})(ChecksumAlgorithm || (ChecksumAlgorithm = {}));
var ChecksumLocation;
(function(ChecksumLocation2) {
  ChecksumLocation2["HEADER"] = "header";
  ChecksumLocation2["TRAILER"] = "trailer";
})(ChecksumLocation || (ChecksumLocation = {}));

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/types.js
var CLIENT_SUPPORTED_ALGORITHMS = [
  ChecksumAlgorithm.CRC32,
  ChecksumAlgorithm.CRC32C,
  ChecksumAlgorithm.SHA1,
  ChecksumAlgorithm.SHA256
];
var PRIORITY_ORDER_ALGORITHMS = [
  ChecksumAlgorithm.CRC32,
  ChecksumAlgorithm.CRC32C,
  ChecksumAlgorithm.SHA1,
  ChecksumAlgorithm.SHA256
];

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/getChecksumAlgorithmForRequest.js
var getChecksumAlgorithmForRequest = (input, { requestChecksumRequired, requestAlgorithmMember }) => {
  if (!requestAlgorithmMember || !input[requestAlgorithmMember]) {
    return requestChecksumRequired ? ChecksumAlgorithm.MD5 : void 0;
  }
  const checksumAlgorithm = input[requestAlgorithmMember];
  if (!CLIENT_SUPPORTED_ALGORITHMS.includes(checksumAlgorithm)) {
    throw new Error(`The checksum algorithm "${checksumAlgorithm}" is not supported by the client. Select one of ${CLIENT_SUPPORTED_ALGORITHMS}.`);
  }
  return checksumAlgorithm;
};

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/getChecksumLocationName.js
var getChecksumLocationName = (algorithm) => algorithm === ChecksumAlgorithm.MD5 ? "content-md5" : `x-amz-checksum-${algorithm.toLowerCase()}`;

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/hasHeader.js
var hasHeader = (header, headers) => {
  const soughtHeader = header.toLowerCase();
  for (const headerName of Object.keys(headers)) {
    if (soughtHeader === headerName.toLowerCase()) {
      return true;
    }
  }
  return false;
};

// node_modules/@aws-sdk/is-array-buffer/dist-es/index.js
var isArrayBuffer = (arg) => typeof ArrayBuffer === "function" && arg instanceof ArrayBuffer || Object.prototype.toString.call(arg) === "[object ArrayBuffer]";

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/isStreaming.js
var isStreaming = (body) => body !== void 0 && typeof body !== "string" && !ArrayBuffer.isView(body) && !isArrayBuffer(body);

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/selectChecksumAlgorithmFunction.js
var import_crc32 = __toESM(require_build2());
var import_crc32c = __toESM(require_build3());
var selectChecksumAlgorithmFunction = (checksumAlgorithm, config) => ({
  [ChecksumAlgorithm.MD5]: config.md5,
  [ChecksumAlgorithm.CRC32]: import_crc32.AwsCrc32,
  [ChecksumAlgorithm.CRC32C]: import_crc32c.AwsCrc32c,
  [ChecksumAlgorithm.SHA1]: config.sha1,
  [ChecksumAlgorithm.SHA256]: config.sha256
})[checksumAlgorithm];

// node_modules/@aws-sdk/util-utf8/dist-es/fromUtf8.browser.js
var fromUtf8 = (input) => new TextEncoder().encode(input);

// node_modules/@aws-sdk/util-utf8/dist-es/toUint8Array.js
var toUint8Array = (data) => {
  if (typeof data === "string") {
    return fromUtf8(data);
  }
  if (ArrayBuffer.isView(data)) {
    return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
  }
  return new Uint8Array(data);
};

// node_modules/@aws-sdk/util-utf8/dist-es/toUtf8.browser.js
var toUtf8 = (input) => new TextDecoder("utf-8").decode(input);

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/stringHasher.js
var stringHasher = (checksumAlgorithmFn, body) => {
  const hash = new checksumAlgorithmFn();
  hash.update(toUint8Array(body || ""));
  return hash.digest();
};

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/getChecksum.js
var getChecksum = async (body, { streamHasher, checksumAlgorithmFn, base64Encoder }) => {
  const digest = isStreaming(body) ? streamHasher(checksumAlgorithmFn, body) : stringHasher(checksumAlgorithmFn, body);
  return base64Encoder(await digest);
};

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/getChecksumAlgorithmListForResponse.js
var getChecksumAlgorithmListForResponse = (responseAlgorithms = []) => {
  const validChecksumAlgorithms = [];
  for (const algorithm of PRIORITY_ORDER_ALGORITHMS) {
    if (!responseAlgorithms.includes(algorithm) || !CLIENT_SUPPORTED_ALGORITHMS.includes(algorithm)) {
      continue;
    }
    validChecksumAlgorithms.push(algorithm);
  }
  return validChecksumAlgorithms;
};

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/validateChecksumFromResponse.js
var validateChecksumFromResponse = async (response, { config, responseAlgorithms }) => {
  const checksumAlgorithms = getChecksumAlgorithmListForResponse(responseAlgorithms);
  const { body: responseBody, headers: responseHeaders } = response;
  for (const algorithm of checksumAlgorithms) {
    const responseHeader = getChecksumLocationName(algorithm);
    const checksumFromResponse = responseHeaders[responseHeader];
    if (checksumFromResponse) {
      const checksumAlgorithmFn = selectChecksumAlgorithmFunction(algorithm, config);
      const { streamHasher, base64Encoder } = config;
      const checksum = await getChecksum(responseBody, { streamHasher, checksumAlgorithmFn, base64Encoder });
      if (checksum === checksumFromResponse) {
        break;
      }
      throw new Error(`Checksum mismatch: expected "${checksum}" but received "${checksumFromResponse}" in response header "${responseHeader}".`);
    }
  }
};

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/flexibleChecksumsMiddleware.js
var flexibleChecksumsMiddleware = (config, middlewareConfig) => (next) => async (args) => {
  if (!HttpRequest.isInstance(args.request)) {
    return next(args);
  }
  const { request } = args;
  const { body: requestBody, headers } = request;
  const { base64Encoder, streamHasher } = config;
  const { input, requestChecksumRequired, requestAlgorithmMember } = middlewareConfig;
  const checksumAlgorithm = getChecksumAlgorithmForRequest(input, {
    requestChecksumRequired,
    requestAlgorithmMember
  });
  let updatedBody = requestBody;
  let updatedHeaders = headers;
  if (checksumAlgorithm) {
    const checksumLocationName = getChecksumLocationName(checksumAlgorithm);
    const checksumAlgorithmFn = selectChecksumAlgorithmFunction(checksumAlgorithm, config);
    if (isStreaming(requestBody)) {
      const { getAwsChunkedEncodingStream: getAwsChunkedEncodingStream2, bodyLengthChecker } = config;
      updatedBody = getAwsChunkedEncodingStream2(requestBody, {
        base64Encoder,
        bodyLengthChecker,
        checksumLocationName,
        checksumAlgorithmFn,
        streamHasher
      });
      updatedHeaders = {
        ...headers,
        "content-encoding": headers["content-encoding"] ? `${headers["content-encoding"]},aws-chunked` : "aws-chunked",
        "transfer-encoding": "chunked",
        "x-amz-decoded-content-length": headers["content-length"],
        "x-amz-content-sha256": "STREAMING-UNSIGNED-PAYLOAD-TRAILER",
        "x-amz-trailer": checksumLocationName
      };
      delete updatedHeaders["content-length"];
    } else if (!hasHeader(checksumLocationName, headers)) {
      const rawChecksum = await stringHasher(checksumAlgorithmFn, requestBody);
      updatedHeaders = {
        ...headers,
        [checksumLocationName]: base64Encoder(rawChecksum)
      };
    }
  }
  const result = await next({
    ...args,
    request: {
      ...request,
      headers: updatedHeaders,
      body: updatedBody
    }
  });
  const { requestValidationModeMember, responseAlgorithms } = middlewareConfig;
  if (requestValidationModeMember && input[requestValidationModeMember] === "ENABLED") {
    validateChecksumFromResponse(result.response, {
      config,
      responseAlgorithms
    });
  }
  return result;
};

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/getFlexibleChecksumsPlugin.js
var flexibleChecksumsMiddlewareOptions = {
  name: "flexibleChecksumsMiddleware",
  step: "build",
  tags: ["BODY_CHECKSUM"],
  override: true
};
var getFlexibleChecksumsPlugin = (config, middlewareConfig) => ({
  applyToStack: (clientStack) => {
    clientStack.add(flexibleChecksumsMiddleware(config, middlewareConfig), flexibleChecksumsMiddlewareOptions);
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/PutObjectCommand.js
var PutObjectCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      Bucket: { type: "contextParams", name: "Bucket" },
      ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
      UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
      DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
      Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
      UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, PutObjectCommand.getEndpointParameterInstructions()));
    this.middlewareStack.use(getCheckContentLengthHeaderPlugin(configuration));
    this.middlewareStack.use(getSsecPlugin(configuration));
    this.middlewareStack.use(getFlexibleChecksumsPlugin(configuration, {
      input: this.input,
      requestAlgorithmMember: "ChecksumAlgorithm",
      requestChecksumRequired: false
    }));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "S3Client";
    const commandName = "PutObjectCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: PutObjectRequestFilterSensitiveLog,
      outputFilterSensitiveLog: PutObjectOutputFilterSensitiveLog
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_PutObjectCommand(input, context);
  }
  deserialize(output, context) {
    return de_PutObjectCommand(output, context);
  }
};

// node_modules/@aws-sdk/util-config-provider/dist-es/booleanSelector.js
var SelectorType;
(function(SelectorType2) {
  SelectorType2["ENV"] = "env";
  SelectorType2["CONFIG"] = "shared config entry";
})(SelectorType || (SelectorType = {}));

// node_modules/@aws-sdk/config-resolver/dist-es/endpointsConfig/NodeUseDualstackEndpointConfigOptions.js
var DEFAULT_USE_DUALSTACK_ENDPOINT = false;

// node_modules/@aws-sdk/config-resolver/dist-es/endpointsConfig/NodeUseFipsEndpointConfigOptions.js
var DEFAULT_USE_FIPS_ENDPOINT = false;

// node_modules/@aws-sdk/config-resolver/dist-es/regionConfig/isFipsRegion.js
var isFipsRegion = (region) => typeof region === "string" && (region.startsWith("fips-") || region.endsWith("-fips"));

// node_modules/@aws-sdk/config-resolver/dist-es/regionConfig/getRealRegion.js
var getRealRegion = (region) => isFipsRegion(region) ? ["fips-aws-global", "aws-fips"].includes(region) ? "us-east-1" : region.replace(/fips-(dkr-|prod-)?|-fips/, "") : region;

// node_modules/@aws-sdk/config-resolver/dist-es/regionConfig/resolveRegionConfig.js
var resolveRegionConfig = (input) => {
  const { region, useFipsEndpoint } = input;
  if (!region) {
    throw new Error("Region is missing");
  }
  return {
    ...input,
    region: async () => {
      if (typeof region === "string") {
        return getRealRegion(region);
      }
      const providedRegion = await region();
      return getRealRegion(providedRegion);
    },
    useFipsEndpoint: async () => {
      const providedRegion = typeof region === "string" ? region : await region();
      if (isFipsRegion(providedRegion)) {
        return true;
      }
      return typeof useFipsEndpoint !== "function" ? Promise.resolve(!!useFipsEndpoint) : useFipsEndpoint();
    }
  };
};

// node_modules/@aws-sdk/eventstream-serde-config-resolver/dist-es/EventStreamSerdeConfig.js
var resolveEventStreamSerdeConfig = (input) => ({
  ...input,
  eventStreamMarshaller: input.eventStreamSerdeProvider(input)
});

// node_modules/@aws-sdk/middleware-content-length/dist-es/index.js
var CONTENT_LENGTH_HEADER2 = "content-length";
function contentLengthMiddleware(bodyLengthChecker) {
  return (next) => async (args) => {
    const request = args.request;
    if (HttpRequest.isInstance(request)) {
      const { body, headers } = request;
      if (body && Object.keys(headers).map((str) => str.toLowerCase()).indexOf(CONTENT_LENGTH_HEADER2) === -1) {
        try {
          const length = bodyLengthChecker(body);
          request.headers = {
            ...request.headers,
            [CONTENT_LENGTH_HEADER2]: String(length)
          };
        } catch (error) {
        }
      }
    }
    return next({
      ...args,
      request
    });
  };
}
var contentLengthMiddlewareOptions = {
  step: "build",
  tags: ["SET_CONTENT_LENGTH", "CONTENT_LENGTH"],
  name: "contentLengthMiddleware",
  override: true
};
var getContentLengthPlugin = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(contentLengthMiddleware(options.bodyLengthChecker), contentLengthMiddlewareOptions);
  }
});

// node_modules/@aws-sdk/middleware-expect-continue/dist-es/index.js
function addExpectContinueMiddleware(options) {
  return (next) => async (args) => {
    const { request } = args;
    if (HttpRequest.isInstance(request) && request.body && options.runtime === "node") {
      request.headers = {
        ...request.headers,
        Expect: "100-continue"
      };
    }
    return next({
      ...args,
      request
    });
  };
}
var addExpectContinueMiddlewareOptions = {
  step: "build",
  tags: ["SET_EXPECT_HEADER", "EXPECT_HEADER"],
  name: "addExpectContinueMiddleware",
  override: true
};
var getAddExpectContinuePlugin = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(addExpectContinueMiddleware(options), addExpectContinueMiddlewareOptions);
  }
});

// node_modules/@aws-sdk/middleware-host-header/dist-es/index.js
function resolveHostHeaderConfig(input) {
  return input;
}
var hostHeaderMiddleware = (options) => (next) => async (args) => {
  if (!HttpRequest.isInstance(args.request))
    return next(args);
  const { request } = args;
  const { handlerProtocol = "" } = options.requestHandler.metadata || {};
  if (handlerProtocol.indexOf("h2") >= 0 && !request.headers[":authority"]) {
    delete request.headers["host"];
    request.headers[":authority"] = "";
  } else if (!request.headers["host"]) {
    let host = request.hostname;
    if (request.port != null)
      host += `:${request.port}`;
    request.headers["host"] = host;
  }
  return next(args);
};
var hostHeaderMiddlewareOptions = {
  name: "hostHeaderMiddleware",
  step: "build",
  priority: "low",
  tags: ["HOST"],
  override: true
};
var getHostHeaderPlugin = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(hostHeaderMiddleware(options), hostHeaderMiddlewareOptions);
  }
});

// node_modules/@aws-sdk/middleware-logger/dist-es/loggerMiddleware.js
var loggerMiddleware = () => (next, context) => async (args) => {
  var _a, _b;
  try {
    const response = await next(args);
    const { clientName, commandName, logger, dynamoDbDocumentClientOptions = {} } = context;
    const { overrideInputFilterSensitiveLog, overrideOutputFilterSensitiveLog } = dynamoDbDocumentClientOptions;
    const inputFilterSensitiveLog = overrideInputFilterSensitiveLog != null ? overrideInputFilterSensitiveLog : context.inputFilterSensitiveLog;
    const outputFilterSensitiveLog = overrideOutputFilterSensitiveLog != null ? overrideOutputFilterSensitiveLog : context.outputFilterSensitiveLog;
    const { $metadata, ...outputWithoutMetadata } = response.output;
    (_a = logger == null ? void 0 : logger.info) == null ? void 0 : _a.call(logger, {
      clientName,
      commandName,
      input: inputFilterSensitiveLog(args.input),
      output: outputFilterSensitiveLog(outputWithoutMetadata),
      metadata: $metadata
    });
    return response;
  } catch (error) {
    const { clientName, commandName, logger, dynamoDbDocumentClientOptions = {} } = context;
    const { overrideInputFilterSensitiveLog } = dynamoDbDocumentClientOptions;
    const inputFilterSensitiveLog = overrideInputFilterSensitiveLog != null ? overrideInputFilterSensitiveLog : context.inputFilterSensitiveLog;
    (_b = logger == null ? void 0 : logger.error) == null ? void 0 : _b.call(logger, {
      clientName,
      commandName,
      input: inputFilterSensitiveLog(args.input),
      error,
      metadata: error.$metadata
    });
    throw error;
  }
};
var loggerMiddlewareOptions = {
  name: "loggerMiddleware",
  tags: ["LOGGER"],
  step: "initialize",
  override: true
};
var getLoggerPlugin = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(loggerMiddleware(), loggerMiddlewareOptions);
  }
});

// node_modules/@aws-sdk/middleware-recursion-detection/dist-es/index.js
var TRACE_ID_HEADER_NAME = "X-Amzn-Trace-Id";
var ENV_LAMBDA_FUNCTION_NAME = "AWS_LAMBDA_FUNCTION_NAME";
var ENV_TRACE_ID = "_X_AMZN_TRACE_ID";
var recursionDetectionMiddleware = (options) => (next) => async (args) => {
  const { request } = args;
  if (!HttpRequest.isInstance(request) || options.runtime !== "node" || request.headers.hasOwnProperty(TRACE_ID_HEADER_NAME)) {
    return next(args);
  }
  const functionName = process.env[ENV_LAMBDA_FUNCTION_NAME];
  const traceId = process.env[ENV_TRACE_ID];
  const nonEmptyString = (str) => typeof str === "string" && str.length > 0;
  if (nonEmptyString(functionName) && nonEmptyString(traceId)) {
    request.headers[TRACE_ID_HEADER_NAME] = traceId;
  }
  return next({
    ...args,
    request
  });
};
var addRecursionDetectionMiddlewareOptions = {
  step: "build",
  tags: ["RECURSION_DETECTION"],
  name: "recursionDetectionMiddleware",
  override: true,
  priority: "low"
};
var getRecursionDetectionPlugin = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(recursionDetectionMiddleware(options), addRecursionDetectionMiddlewareOptions);
  }
});

// node_modules/@aws-sdk/util-retry/dist-es/config.js
var RETRY_MODES;
(function(RETRY_MODES2) {
  RETRY_MODES2["STANDARD"] = "standard";
  RETRY_MODES2["ADAPTIVE"] = "adaptive";
})(RETRY_MODES || (RETRY_MODES = {}));
var DEFAULT_MAX_ATTEMPTS = 3;
var DEFAULT_RETRY_MODE = "STANDARD";

// node_modules/@aws-sdk/service-error-classification/dist-es/constants.js
var THROTTLING_ERROR_CODES = [
  "BandwidthLimitExceeded",
  "EC2ThrottledException",
  "LimitExceededException",
  "PriorRequestNotComplete",
  "ProvisionedThroughputExceededException",
  "RequestLimitExceeded",
  "RequestThrottled",
  "RequestThrottledException",
  "SlowDown",
  "ThrottledException",
  "Throttling",
  "ThrottlingException",
  "TooManyRequestsException",
  "TransactionInProgressException"
];
var TRANSIENT_ERROR_CODES = ["AbortError", "TimeoutError", "RequestTimeout", "RequestTimeoutException"];
var TRANSIENT_ERROR_STATUS_CODES = [500, 502, 503, 504];
var NODEJS_TIMEOUT_ERROR_CODES = ["ECONNRESET", "EPIPE", "ETIMEDOUT"];

// node_modules/@aws-sdk/service-error-classification/dist-es/index.js
var isThrottlingError = (error) => {
  var _a, _b;
  return ((_a = error.$metadata) == null ? void 0 : _a.httpStatusCode) === 429 || THROTTLING_ERROR_CODES.includes(error.name) || ((_b = error.$retryable) == null ? void 0 : _b.throttling) == true;
};
var isTransientError = (error) => {
  var _a;
  return TRANSIENT_ERROR_CODES.includes(error.name) || NODEJS_TIMEOUT_ERROR_CODES.includes((error == null ? void 0 : error.code) || "") || TRANSIENT_ERROR_STATUS_CODES.includes(((_a = error.$metadata) == null ? void 0 : _a.httpStatusCode) || 0);
};
var isServerError = (error) => {
  var _a;
  if (((_a = error.$metadata) == null ? void 0 : _a.httpStatusCode) !== void 0) {
    const statusCode = error.$metadata.httpStatusCode;
    if (500 <= statusCode && statusCode <= 599 && !isTransientError(error)) {
      return true;
    }
    return false;
  }
  return false;
};

// node_modules/@aws-sdk/util-retry/dist-es/DefaultRateLimiter.js
var DefaultRateLimiter = class {
  constructor(options) {
    var _a, _b, _c, _d, _e;
    this.currentCapacity = 0;
    this.enabled = false;
    this.lastMaxRate = 0;
    this.measuredTxRate = 0;
    this.requestCount = 0;
    this.lastTimestamp = 0;
    this.timeWindow = 0;
    this.beta = (_a = options == null ? void 0 : options.beta) != null ? _a : 0.7;
    this.minCapacity = (_b = options == null ? void 0 : options.minCapacity) != null ? _b : 1;
    this.minFillRate = (_c = options == null ? void 0 : options.minFillRate) != null ? _c : 0.5;
    this.scaleConstant = (_d = options == null ? void 0 : options.scaleConstant) != null ? _d : 0.4;
    this.smooth = (_e = options == null ? void 0 : options.smooth) != null ? _e : 0.8;
    const currentTimeInSeconds = this.getCurrentTimeInSeconds();
    this.lastThrottleTime = currentTimeInSeconds;
    this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds());
    this.fillRate = this.minFillRate;
    this.maxCapacity = this.minCapacity;
  }
  getCurrentTimeInSeconds() {
    return Date.now() / 1e3;
  }
  async getSendToken() {
    return this.acquireTokenBucket(1);
  }
  async acquireTokenBucket(amount) {
    if (!this.enabled) {
      return;
    }
    this.refillTokenBucket();
    if (amount > this.currentCapacity) {
      const delay = (amount - this.currentCapacity) / this.fillRate * 1e3;
      await new Promise((resolve) => setTimeout(resolve, delay));
    }
    this.currentCapacity = this.currentCapacity - amount;
  }
  refillTokenBucket() {
    const timestamp = this.getCurrentTimeInSeconds();
    if (!this.lastTimestamp) {
      this.lastTimestamp = timestamp;
      return;
    }
    const fillAmount = (timestamp - this.lastTimestamp) * this.fillRate;
    this.currentCapacity = Math.min(this.maxCapacity, this.currentCapacity + fillAmount);
    this.lastTimestamp = timestamp;
  }
  updateClientSendingRate(response) {
    let calculatedRate;
    this.updateMeasuredRate();
    if (isThrottlingError(response)) {
      const rateToUse = !this.enabled ? this.measuredTxRate : Math.min(this.measuredTxRate, this.fillRate);
      this.lastMaxRate = rateToUse;
      this.calculateTimeWindow();
      this.lastThrottleTime = this.getCurrentTimeInSeconds();
      calculatedRate = this.cubicThrottle(rateToUse);
      this.enableTokenBucket();
    } else {
      this.calculateTimeWindow();
      calculatedRate = this.cubicSuccess(this.getCurrentTimeInSeconds());
    }
    const newRate = Math.min(calculatedRate, 2 * this.measuredTxRate);
    this.updateTokenBucketRate(newRate);
  }
  calculateTimeWindow() {
    this.timeWindow = this.getPrecise(Math.pow(this.lastMaxRate * (1 - this.beta) / this.scaleConstant, 1 / 3));
  }
  cubicThrottle(rateToUse) {
    return this.getPrecise(rateToUse * this.beta);
  }
  cubicSuccess(timestamp) {
    return this.getPrecise(this.scaleConstant * Math.pow(timestamp - this.lastThrottleTime - this.timeWindow, 3) + this.lastMaxRate);
  }
  enableTokenBucket() {
    this.enabled = true;
  }
  updateTokenBucketRate(newRate) {
    this.refillTokenBucket();
    this.fillRate = Math.max(newRate, this.minFillRate);
    this.maxCapacity = Math.max(newRate, this.minCapacity);
    this.currentCapacity = Math.min(this.currentCapacity, this.maxCapacity);
  }
  updateMeasuredRate() {
    const t3 = this.getCurrentTimeInSeconds();
    const timeBucket = Math.floor(t3 * 2) / 2;
    this.requestCount++;
    if (timeBucket > this.lastTxRateBucket) {
      const currentRate = this.requestCount / (timeBucket - this.lastTxRateBucket);
      this.measuredTxRate = this.getPrecise(currentRate * this.smooth + this.measuredTxRate * (1 - this.smooth));
      this.requestCount = 0;
      this.lastTxRateBucket = timeBucket;
    }
  }
  getPrecise(num) {
    return parseFloat(num.toFixed(8));
  }
};

// node_modules/@aws-sdk/util-retry/dist-es/constants.js
var DEFAULT_RETRY_DELAY_BASE = 100;
var MAXIMUM_RETRY_DELAY = 20 * 1e3;
var THROTTLING_RETRY_DELAY_BASE = 500;
var INITIAL_RETRY_TOKENS = 500;
var RETRY_COST = 5;
var TIMEOUT_RETRY_COST = 10;
var NO_RETRY_INCREMENT = 1;
var INVOCATION_ID_HEADER = "amz-sdk-invocation-id";
var REQUEST_HEADER = "amz-sdk-request";

// node_modules/@aws-sdk/util-retry/dist-es/defaultRetryBackoffStrategy.js
var getDefaultRetryBackoffStrategy = () => {
  let delayBase = DEFAULT_RETRY_DELAY_BASE;
  const computeNextBackoffDelay = (attempts) => {
    return Math.floor(Math.min(MAXIMUM_RETRY_DELAY, Math.random() * 2 ** attempts * delayBase));
  };
  const setDelayBase = (delay) => {
    delayBase = delay;
  };
  return {
    computeNextBackoffDelay,
    setDelayBase
  };
};

// node_modules/@aws-sdk/util-retry/dist-es/defaultRetryToken.js
var getDefaultRetryToken = (initialRetryTokens, initialRetryDelay, initialRetryCount, options) => {
  var _a, _b, _c;
  const MAX_CAPACITY = initialRetryTokens;
  const retryCost = (_a = options == null ? void 0 : options.retryCost) != null ? _a : RETRY_COST;
  const timeoutRetryCost = (_b = options == null ? void 0 : options.timeoutRetryCost) != null ? _b : TIMEOUT_RETRY_COST;
  const retryBackoffStrategy = (_c = options == null ? void 0 : options.retryBackoffStrategy) != null ? _c : getDefaultRetryBackoffStrategy();
  let availableCapacity = initialRetryTokens;
  let retryDelay = Math.min(MAXIMUM_RETRY_DELAY, initialRetryDelay);
  let lastRetryCost = void 0;
  let retryCount = initialRetryCount != null ? initialRetryCount : 0;
  const getCapacityAmount = (errorType) => errorType === "TRANSIENT" ? timeoutRetryCost : retryCost;
  const getRetryCount = () => retryCount;
  const getRetryDelay = () => retryDelay;
  const getLastRetryCost = () => lastRetryCost;
  const hasRetryTokens = (errorType) => getCapacityAmount(errorType) <= availableCapacity;
  const getRetryTokenCount = (errorInfo) => {
    const errorType = errorInfo.errorType;
    if (!hasRetryTokens(errorType)) {
      throw new Error("No retry token available");
    }
    const capacityAmount = getCapacityAmount(errorType);
    const delayBase = errorType === "THROTTLING" ? THROTTLING_RETRY_DELAY_BASE : DEFAULT_RETRY_DELAY_BASE;
    retryBackoffStrategy.setDelayBase(delayBase);
    const delayFromErrorType = retryBackoffStrategy.computeNextBackoffDelay(retryCount);
    if (errorInfo.retryAfterHint) {
      const delayFromRetryAfterHint = errorInfo.retryAfterHint.getTime() - Date.now();
      retryDelay = Math.max(delayFromRetryAfterHint || 0, delayFromErrorType);
    } else {
      retryDelay = delayFromErrorType;
    }
    retryCount++;
    lastRetryCost = capacityAmount;
    availableCapacity -= capacityAmount;
    return capacityAmount;
  };
  const releaseRetryTokens = (releaseAmount) => {
    availableCapacity += releaseAmount != null ? releaseAmount : NO_RETRY_INCREMENT;
    availableCapacity = Math.min(availableCapacity, MAX_CAPACITY);
  };
  return {
    getRetryCount,
    getRetryDelay,
    getLastRetryCost,
    hasRetryTokens,
    getRetryTokenCount,
    releaseRetryTokens
  };
};

// node_modules/@aws-sdk/util-retry/dist-es/StandardRetryStrategy.js
var StandardRetryStrategy = class {
  constructor(maxAttemptsProvider) {
    this.maxAttemptsProvider = maxAttemptsProvider;
    this.mode = RETRY_MODES.STANDARD;
    this.retryToken = getDefaultRetryToken(INITIAL_RETRY_TOKENS, DEFAULT_RETRY_DELAY_BASE);
    this.maxAttemptsProvider = maxAttemptsProvider;
  }
  async acquireInitialRetryToken(retryTokenScope) {
    return this.retryToken;
  }
  async refreshRetryTokenForRetry(tokenToRenew, errorInfo) {
    const maxAttempts = await this.getMaxAttempts();
    if (this.shouldRetry(tokenToRenew, errorInfo, maxAttempts)) {
      tokenToRenew.getRetryTokenCount(errorInfo);
      return tokenToRenew;
    }
    throw new Error("No retry token available");
  }
  recordSuccess(token) {
    this.retryToken.releaseRetryTokens(token.getLastRetryCost());
  }
  async getMaxAttempts() {
    let maxAttempts;
    try {
      return await this.maxAttemptsProvider();
    } catch (error) {
      console.warn(`Max attempts provider could not resolve. Using default of ${DEFAULT_MAX_ATTEMPTS}`);
      return DEFAULT_MAX_ATTEMPTS;
    }
  }
  shouldRetry(tokenToRenew, errorInfo, maxAttempts) {
    const attempts = tokenToRenew.getRetryCount();
    return attempts < maxAttempts && tokenToRenew.hasRetryTokens(errorInfo.errorType) && this.isRetryableError(errorInfo.errorType);
  }
  isRetryableError(errorType) {
    return errorType === "THROTTLING" || errorType === "TRANSIENT";
  }
};

// node_modules/@aws-sdk/util-retry/dist-es/AdaptiveRetryStrategy.js
var AdaptiveRetryStrategy = class {
  constructor(maxAttemptsProvider, options) {
    this.maxAttemptsProvider = maxAttemptsProvider;
    this.mode = RETRY_MODES.ADAPTIVE;
    const { rateLimiter } = options != null ? options : {};
    this.rateLimiter = rateLimiter != null ? rateLimiter : new DefaultRateLimiter();
    this.standardRetryStrategy = new StandardRetryStrategy(maxAttemptsProvider);
  }
  async acquireInitialRetryToken(retryTokenScope) {
    await this.rateLimiter.getSendToken();
    return this.standardRetryStrategy.acquireInitialRetryToken(retryTokenScope);
  }
  async refreshRetryTokenForRetry(tokenToRenew, errorInfo) {
    this.rateLimiter.updateClientSendingRate(errorInfo);
    return this.standardRetryStrategy.refreshRetryTokenForRetry(tokenToRenew, errorInfo);
  }
  recordSuccess(token) {
    this.rateLimiter.updateClientSendingRate({});
    this.standardRetryStrategy.recordSuccess(token);
  }
};

// node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/regex.js
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

// node_modules/uuid/dist/esm-browser/validate.js
function validate2(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default = validate2;

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (i3 = 0; i3 < 256; ++i3) {
  byteToHex.push((i3 + 256).toString(16).substr(1));
}
var i3;
function stringify(arr) {
  var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  if (!validate_default(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
var stringify_default = stringify;

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (var i3 = 0; i3 < 16; ++i3) {
      buf[offset + i3] = rnds[i3];
    }
    return buf;
  }
  return stringify_default(rnds);
}
var v4_default = v4;

// node_modules/@aws-sdk/middleware-retry/dist-es/util.js
var asSdkError = (error) => {
  if (error instanceof Error)
    return error;
  if (error instanceof Object)
    return Object.assign(new Error(), error);
  if (typeof error === "string")
    return new Error(error);
  return new Error(`AWS SDK error wrapper for ${error}`);
};

// node_modules/@aws-sdk/middleware-retry/dist-es/configurations.js
var resolveRetryConfig = (input) => {
  var _a;
  const { retryStrategy } = input;
  const maxAttempts = normalizeProvider((_a = input.maxAttempts) != null ? _a : DEFAULT_MAX_ATTEMPTS);
  return {
    ...input,
    maxAttempts,
    retryStrategy: async () => {
      if (retryStrategy) {
        return retryStrategy;
      }
      const retryMode = await normalizeProvider(input.retryMode)();
      if (retryMode === RETRY_MODES.ADAPTIVE) {
        return new AdaptiveRetryStrategy(maxAttempts);
      }
      return new StandardRetryStrategy(maxAttempts);
    }
  };
};

// node_modules/@aws-sdk/middleware-retry/dist-es/retryMiddleware.js
var retryMiddleware = (options) => (next, context) => async (args) => {
  let retryStrategy = await options.retryStrategy();
  const maxAttempts = await options.maxAttempts();
  if (isRetryStrategyV2(retryStrategy)) {
    retryStrategy = retryStrategy;
    let retryToken = await retryStrategy.acquireInitialRetryToken(context["partition_id"]);
    let lastError = new Error();
    let attempts = 0;
    let totalRetryDelay = 0;
    const { request } = args;
    if (HttpRequest.isInstance(request)) {
      request.headers[INVOCATION_ID_HEADER] = v4_default();
    }
    while (true) {
      try {
        if (HttpRequest.isInstance(request)) {
          request.headers[REQUEST_HEADER] = `attempt=${attempts + 1}; max=${maxAttempts}`;
        }
        const { response, output } = await next(args);
        retryStrategy.recordSuccess(retryToken);
        output.$metadata.attempts = attempts + 1;
        output.$metadata.totalRetryDelay = totalRetryDelay;
        return { response, output };
      } catch (e3) {
        const retryErrorInfo = getRetyErrorInto(e3);
        lastError = asSdkError(e3);
        try {
          retryToken = await retryStrategy.refreshRetryTokenForRetry(retryToken, retryErrorInfo);
        } catch (refreshError) {
          if (!lastError.$metadata) {
            lastError.$metadata = {};
          }
          lastError.$metadata.attempts = attempts + 1;
          lastError.$metadata.totalRetryDelay = totalRetryDelay;
          throw lastError;
        }
        attempts = retryToken.getRetryCount();
        const delay = retryToken.getRetryDelay();
        totalRetryDelay += delay;
        await new Promise((resolve) => setTimeout(resolve, delay));
      }
    }
  } else {
    retryStrategy = retryStrategy;
    if (retryStrategy == null ? void 0 : retryStrategy.mode)
      context.userAgent = [...context.userAgent || [], ["cfg/retry-mode", retryStrategy.mode]];
    return retryStrategy.retry(next, args);
  }
};
var isRetryStrategyV2 = (retryStrategy) => typeof retryStrategy.acquireInitialRetryToken !== "undefined" && typeof retryStrategy.refreshRetryTokenForRetry !== "undefined" && typeof retryStrategy.recordSuccess !== "undefined";
var getRetyErrorInto = (error) => {
  const errorInfo = {
    errorType: getRetryErrorType(error)
  };
  const retryAfterHint = getRetryAfterHint(error.$response);
  if (retryAfterHint) {
    errorInfo.retryAfterHint = retryAfterHint;
  }
  return errorInfo;
};
var getRetryErrorType = (error) => {
  if (isThrottlingError(error))
    return "THROTTLING";
  if (isTransientError(error))
    return "TRANSIENT";
  if (isServerError(error))
    return "SERVER_ERROR";
  return "CLIENT_ERROR";
};
var retryMiddlewareOptions = {
  name: "retryMiddleware",
  tags: ["RETRY"],
  step: "finalizeRequest",
  priority: "high",
  override: true
};
var getRetryPlugin = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(retryMiddleware(options), retryMiddlewareOptions);
  }
});
var getRetryAfterHint = (response) => {
  if (!HttpResponse.isInstance(response))
    return;
  const retryAfterHeaderName = Object.keys(response.headers).find((key) => key.toLowerCase() === "retry-after");
  if (!retryAfterHeaderName)
    return;
  const retryAfter = response.headers[retryAfterHeaderName];
  const retryAfterSeconds = Number(retryAfter);
  if (!Number.isNaN(retryAfterSeconds))
    return new Date(retryAfterSeconds * 1e3);
  const retryAfterDate = new Date(retryAfter);
  return retryAfterDate;
};

// node_modules/@aws-sdk/property-provider/dist-es/memoize.js
var memoize = (provider, isExpired, requiresRefresh) => {
  let resolved;
  let pending;
  let hasResult;
  let isConstant = false;
  const coalesceProvider = async () => {
    if (!pending) {
      pending = provider();
    }
    try {
      resolved = await pending;
      hasResult = true;
      isConstant = false;
    } finally {
      pending = void 0;
    }
    return resolved;
  };
  if (isExpired === void 0) {
    return async (options) => {
      if (!hasResult || (options == null ? void 0 : options.forceRefresh)) {
        resolved = await coalesceProvider();
      }
      return resolved;
    };
  }
  return async (options) => {
    if (!hasResult || (options == null ? void 0 : options.forceRefresh)) {
      resolved = await coalesceProvider();
    }
    if (isConstant) {
      return resolved;
    }
    if (requiresRefresh && !requiresRefresh(resolved)) {
      isConstant = true;
      return resolved;
    }
    if (isExpired(resolved)) {
      await coalesceProvider();
      return resolved;
    }
    return resolved;
  };
};

// node_modules/@aws-sdk/util-hex-encoding/dist-es/index.js
var SHORT_TO_HEX = {};
var HEX_TO_SHORT = {};
for (let i3 = 0; i3 < 256; i3++) {
  let encodedByte = i3.toString(16).toLowerCase();
  if (encodedByte.length === 1) {
    encodedByte = `0${encodedByte}`;
  }
  SHORT_TO_HEX[i3] = encodedByte;
  HEX_TO_SHORT[encodedByte] = i3;
}
function fromHex(encoded) {
  if (encoded.length % 2 !== 0) {
    throw new Error("Hex encoded strings must have an even number length");
  }
  const out = new Uint8Array(encoded.length / 2);
  for (let i3 = 0; i3 < encoded.length; i3 += 2) {
    const encodedByte = encoded.slice(i3, i3 + 2).toLowerCase();
    if (encodedByte in HEX_TO_SHORT) {
      out[i3 / 2] = HEX_TO_SHORT[encodedByte];
    } else {
      throw new Error(`Cannot decode unrecognized sequence ${encodedByte} as hexadecimal`);
    }
  }
  return out;
}
function toHex(bytes) {
  let out = "";
  for (let i3 = 0; i3 < bytes.byteLength; i3++) {
    out += SHORT_TO_HEX[bytes[i3]];
  }
  return out;
}

// node_modules/@aws-sdk/signature-v4/dist-es/constants.js
var ALGORITHM_QUERY_PARAM = "X-Amz-Algorithm";
var CREDENTIAL_QUERY_PARAM = "X-Amz-Credential";
var AMZ_DATE_QUERY_PARAM = "X-Amz-Date";
var SIGNED_HEADERS_QUERY_PARAM = "X-Amz-SignedHeaders";
var EXPIRES_QUERY_PARAM = "X-Amz-Expires";
var SIGNATURE_QUERY_PARAM = "X-Amz-Signature";
var TOKEN_QUERY_PARAM = "X-Amz-Security-Token";
var AUTH_HEADER = "authorization";
var AMZ_DATE_HEADER = AMZ_DATE_QUERY_PARAM.toLowerCase();
var DATE_HEADER = "date";
var GENERATED_HEADERS = [AUTH_HEADER, AMZ_DATE_HEADER, DATE_HEADER];
var SIGNATURE_HEADER = SIGNATURE_QUERY_PARAM.toLowerCase();
var SHA256_HEADER = "x-amz-content-sha256";
var TOKEN_HEADER = TOKEN_QUERY_PARAM.toLowerCase();
var ALWAYS_UNSIGNABLE_HEADERS = {
  authorization: true,
  "cache-control": true,
  connection: true,
  expect: true,
  from: true,
  "keep-alive": true,
  "max-forwards": true,
  pragma: true,
  referer: true,
  te: true,
  trailer: true,
  "transfer-encoding": true,
  upgrade: true,
  "user-agent": true,
  "x-amzn-trace-id": true
};
var PROXY_HEADER_PATTERN = /^proxy-/;
var SEC_HEADER_PATTERN = /^sec-/;
var ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256";
var EVENT_ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256-PAYLOAD";
var UNSIGNED_PAYLOAD = "UNSIGNED-PAYLOAD";
var MAX_CACHE_SIZE = 50;
var KEY_TYPE_IDENTIFIER = "aws4_request";
var MAX_PRESIGNED_TTL = 60 * 60 * 24 * 7;

// node_modules/@aws-sdk/signature-v4/dist-es/credentialDerivation.js
var signingKeyCache = {};
var cacheQueue = [];
var createScope = (shortDate, region, service) => `${shortDate}/${region}/${service}/${KEY_TYPE_IDENTIFIER}`;
var getSigningKey = async (sha256Constructor, credentials, shortDate, region, service) => {
  const credsHash = await hmac(sha256Constructor, credentials.secretAccessKey, credentials.accessKeyId);
  const cacheKey = `${shortDate}:${region}:${service}:${toHex(credsHash)}:${credentials.sessionToken}`;
  if (cacheKey in signingKeyCache) {
    return signingKeyCache[cacheKey];
  }
  cacheQueue.push(cacheKey);
  while (cacheQueue.length > MAX_CACHE_SIZE) {
    delete signingKeyCache[cacheQueue.shift()];
  }
  let key = `AWS4${credentials.secretAccessKey}`;
  for (const signable of [shortDate, region, service, KEY_TYPE_IDENTIFIER]) {
    key = await hmac(sha256Constructor, key, signable);
  }
  return signingKeyCache[cacheKey] = key;
};
var hmac = (ctor, secret, data) => {
  const hash = new ctor(secret);
  hash.update(toUint8Array(data));
  return hash.digest();
};

// node_modules/@aws-sdk/signature-v4/dist-es/getCanonicalHeaders.js
var getCanonicalHeaders = ({ headers }, unsignableHeaders, signableHeaders) => {
  const canonical = {};
  for (const headerName of Object.keys(headers).sort()) {
    if (headers[headerName] == void 0) {
      continue;
    }
    const canonicalHeaderName = headerName.toLowerCase();
    if (canonicalHeaderName in ALWAYS_UNSIGNABLE_HEADERS || (unsignableHeaders == null ? void 0 : unsignableHeaders.has(canonicalHeaderName)) || PROXY_HEADER_PATTERN.test(canonicalHeaderName) || SEC_HEADER_PATTERN.test(canonicalHeaderName)) {
      if (!signableHeaders || signableHeaders && !signableHeaders.has(canonicalHeaderName)) {
        continue;
      }
    }
    canonical[canonicalHeaderName] = headers[headerName].trim().replace(/\s+/g, " ");
  }
  return canonical;
};

// node_modules/@aws-sdk/signature-v4/dist-es/getCanonicalQuery.js
var getCanonicalQuery = ({ query = {} }) => {
  const keys = [];
  const serialized = {};
  for (const key of Object.keys(query).sort()) {
    if (key.toLowerCase() === SIGNATURE_HEADER) {
      continue;
    }
    keys.push(key);
    const value = query[key];
    if (typeof value === "string") {
      serialized[key] = `${escapeUri(key)}=${escapeUri(value)}`;
    } else if (Array.isArray(value)) {
      serialized[key] = value.slice(0).sort().reduce((encoded, value2) => encoded.concat([`${escapeUri(key)}=${escapeUri(value2)}`]), []).join("&");
    }
  }
  return keys.map((key) => serialized[key]).filter((serialized2) => serialized2).join("&");
};

// node_modules/@aws-sdk/signature-v4/dist-es/getPayloadHash.js
var getPayloadHash = async ({ headers, body }, hashConstructor) => {
  for (const headerName of Object.keys(headers)) {
    if (headerName.toLowerCase() === SHA256_HEADER) {
      return headers[headerName];
    }
  }
  if (body == void 0) {
    return "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
  } else if (typeof body === "string" || ArrayBuffer.isView(body) || isArrayBuffer(body)) {
    const hashCtor = new hashConstructor();
    hashCtor.update(toUint8Array(body));
    return toHex(await hashCtor.digest());
  }
  return UNSIGNED_PAYLOAD;
};

// node_modules/@aws-sdk/signature-v4/dist-es/headerUtil.js
var hasHeader2 = (soughtHeader, headers) => {
  soughtHeader = soughtHeader.toLowerCase();
  for (const headerName of Object.keys(headers)) {
    if (soughtHeader === headerName.toLowerCase()) {
      return true;
    }
  }
  return false;
};

// node_modules/@aws-sdk/signature-v4/dist-es/cloneRequest.js
var cloneRequest = ({ headers, query, ...rest }) => ({
  ...rest,
  headers: { ...headers },
  query: query ? cloneQuery2(query) : void 0
});
var cloneQuery2 = (query) => Object.keys(query).reduce((carry, paramName) => {
  const param = query[paramName];
  return {
    ...carry,
    [paramName]: Array.isArray(param) ? [...param] : param
  };
}, {});

// node_modules/@aws-sdk/signature-v4/dist-es/moveHeadersToQuery.js
var moveHeadersToQuery = (request, options = {}) => {
  var _a;
  const { headers, query = {} } = typeof request.clone === "function" ? request.clone() : cloneRequest(request);
  for (const name of Object.keys(headers)) {
    const lname = name.toLowerCase();
    if (lname.slice(0, 6) === "x-amz-" && !((_a = options.unhoistableHeaders) == null ? void 0 : _a.has(lname))) {
      query[name] = headers[name];
      delete headers[name];
    }
  }
  return {
    ...request,
    headers,
    query
  };
};

// node_modules/@aws-sdk/signature-v4/dist-es/prepareRequest.js
var prepareRequest = (request) => {
  request = typeof request.clone === "function" ? request.clone() : cloneRequest(request);
  for (const headerName of Object.keys(request.headers)) {
    if (GENERATED_HEADERS.indexOf(headerName.toLowerCase()) > -1) {
      delete request.headers[headerName];
    }
  }
  return request;
};

// node_modules/@aws-sdk/signature-v4/dist-es/utilDate.js
var iso8601 = (time) => toDate(time).toISOString().replace(/\.\d{3}Z$/, "Z");
var toDate = (time) => {
  if (typeof time === "number") {
    return new Date(time * 1e3);
  }
  if (typeof time === "string") {
    if (Number(time)) {
      return new Date(Number(time) * 1e3);
    }
    return new Date(time);
  }
  return time;
};

// node_modules/@aws-sdk/signature-v4/dist-es/SignatureV4.js
var SignatureV4 = class {
  constructor({ applyChecksum, credentials, region, service, sha256, uriEscapePath = true }) {
    this.service = service;
    this.sha256 = sha256;
    this.uriEscapePath = uriEscapePath;
    this.applyChecksum = typeof applyChecksum === "boolean" ? applyChecksum : true;
    this.regionProvider = normalizeProvider(region);
    this.credentialProvider = normalizeProvider(credentials);
  }
  async presign(originalRequest, options = {}) {
    const { signingDate = new Date(), expiresIn = 3600, unsignableHeaders, unhoistableHeaders, signableHeaders, signingRegion, signingService } = options;
    const credentials = await this.credentialProvider();
    this.validateResolvedCredentials(credentials);
    const region = signingRegion != null ? signingRegion : await this.regionProvider();
    const { longDate, shortDate } = formatDate(signingDate);
    if (expiresIn > MAX_PRESIGNED_TTL) {
      return Promise.reject("Signature version 4 presigned URLs must have an expiration date less than one week in the future");
    }
    const scope = createScope(shortDate, region, signingService != null ? signingService : this.service);
    const request = moveHeadersToQuery(prepareRequest(originalRequest), { unhoistableHeaders });
    if (credentials.sessionToken) {
      request.query[TOKEN_QUERY_PARAM] = credentials.sessionToken;
    }
    request.query[ALGORITHM_QUERY_PARAM] = ALGORITHM_IDENTIFIER;
    request.query[CREDENTIAL_QUERY_PARAM] = `${credentials.accessKeyId}/${scope}`;
    request.query[AMZ_DATE_QUERY_PARAM] = longDate;
    request.query[EXPIRES_QUERY_PARAM] = expiresIn.toString(10);
    const canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);
    request.query[SIGNED_HEADERS_QUERY_PARAM] = getCanonicalHeaderList(canonicalHeaders);
    request.query[SIGNATURE_QUERY_PARAM] = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, await getPayloadHash(originalRequest, this.sha256)));
    return request;
  }
  async sign(toSign, options) {
    if (typeof toSign === "string") {
      return this.signString(toSign, options);
    } else if (toSign.headers && toSign.payload) {
      return this.signEvent(toSign, options);
    } else {
      return this.signRequest(toSign, options);
    }
  }
  async signEvent({ headers, payload }, { signingDate = new Date(), priorSignature, signingRegion, signingService }) {
    const region = signingRegion != null ? signingRegion : await this.regionProvider();
    const { shortDate, longDate } = formatDate(signingDate);
    const scope = createScope(shortDate, region, signingService != null ? signingService : this.service);
    const hashedPayload = await getPayloadHash({ headers: {}, body: payload }, this.sha256);
    const hash = new this.sha256();
    hash.update(headers);
    const hashedHeaders = toHex(await hash.digest());
    const stringToSign = [
      EVENT_ALGORITHM_IDENTIFIER,
      longDate,
      scope,
      priorSignature,
      hashedHeaders,
      hashedPayload
    ].join("\n");
    return this.signString(stringToSign, { signingDate, signingRegion: region, signingService });
  }
  async signString(stringToSign, { signingDate = new Date(), signingRegion, signingService } = {}) {
    const credentials = await this.credentialProvider();
    this.validateResolvedCredentials(credentials);
    const region = signingRegion != null ? signingRegion : await this.regionProvider();
    const { shortDate } = formatDate(signingDate);
    const hash = new this.sha256(await this.getSigningKey(credentials, region, shortDate, signingService));
    hash.update(toUint8Array(stringToSign));
    return toHex(await hash.digest());
  }
  async signRequest(requestToSign, { signingDate = new Date(), signableHeaders, unsignableHeaders, signingRegion, signingService } = {}) {
    const credentials = await this.credentialProvider();
    this.validateResolvedCredentials(credentials);
    const region = signingRegion != null ? signingRegion : await this.regionProvider();
    const request = prepareRequest(requestToSign);
    const { longDate, shortDate } = formatDate(signingDate);
    const scope = createScope(shortDate, region, signingService != null ? signingService : this.service);
    request.headers[AMZ_DATE_HEADER] = longDate;
    if (credentials.sessionToken) {
      request.headers[TOKEN_HEADER] = credentials.sessionToken;
    }
    const payloadHash = await getPayloadHash(request, this.sha256);
    if (!hasHeader2(SHA256_HEADER, request.headers) && this.applyChecksum) {
      request.headers[SHA256_HEADER] = payloadHash;
    }
    const canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);
    const signature = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, payloadHash));
    request.headers[AUTH_HEADER] = `${ALGORITHM_IDENTIFIER} Credential=${credentials.accessKeyId}/${scope}, SignedHeaders=${getCanonicalHeaderList(canonicalHeaders)}, Signature=${signature}`;
    return request;
  }
  createCanonicalRequest(request, canonicalHeaders, payloadHash) {
    const sortedHeaders = Object.keys(canonicalHeaders).sort();
    return `${request.method}
${this.getCanonicalPath(request)}
${getCanonicalQuery(request)}
${sortedHeaders.map((name) => `${name}:${canonicalHeaders[name]}`).join("\n")}

${sortedHeaders.join(";")}
${payloadHash}`;
  }
  async createStringToSign(longDate, credentialScope, canonicalRequest) {
    const hash = new this.sha256();
    hash.update(toUint8Array(canonicalRequest));
    const hashedRequest = await hash.digest();
    return `${ALGORITHM_IDENTIFIER}
${longDate}
${credentialScope}
${toHex(hashedRequest)}`;
  }
  getCanonicalPath({ path: path2 }) {
    if (this.uriEscapePath) {
      const normalizedPathSegments = [];
      for (const pathSegment of path2.split("/")) {
        if ((pathSegment == null ? void 0 : pathSegment.length) === 0)
          continue;
        if (pathSegment === ".")
          continue;
        if (pathSegment === "..") {
          normalizedPathSegments.pop();
        } else {
          normalizedPathSegments.push(pathSegment);
        }
      }
      const normalizedPath = `${(path2 == null ? void 0 : path2.startsWith("/")) ? "/" : ""}${normalizedPathSegments.join("/")}${normalizedPathSegments.length > 0 && (path2 == null ? void 0 : path2.endsWith("/")) ? "/" : ""}`;
      const doubleEncoded = encodeURIComponent(normalizedPath);
      return doubleEncoded.replace(/%2F/g, "/");
    }
    return path2;
  }
  async getSignature(longDate, credentialScope, keyPromise, canonicalRequest) {
    const stringToSign = await this.createStringToSign(longDate, credentialScope, canonicalRequest);
    const hash = new this.sha256(await keyPromise);
    hash.update(toUint8Array(stringToSign));
    return toHex(await hash.digest());
  }
  getSigningKey(credentials, region, shortDate, service) {
    return getSigningKey(this.sha256, credentials, shortDate, region, service || this.service);
  }
  validateResolvedCredentials(credentials) {
    if (typeof credentials !== "object" || typeof credentials.accessKeyId !== "string" || typeof credentials.secretAccessKey !== "string") {
      throw new Error("Resolved credential object is not valid");
    }
  }
};
var formatDate = (now) => {
  const longDate = iso8601(now).replace(/[\-:]/g, "");
  return {
    longDate,
    shortDate: longDate.slice(0, 8)
  };
};
var getCanonicalHeaderList = (headers) => Object.keys(headers).sort().join(";");

// node_modules/@aws-sdk/middleware-signing/dist-es/configurations.js
var CREDENTIAL_EXPIRE_WINDOW = 3e5;
var resolveAwsAuthConfig = (input) => {
  const normalizedCreds = input.credentials ? normalizeCredentialProvider(input.credentials) : input.credentialDefaultProvider(input);
  const { signingEscapePath = true, systemClockOffset = input.systemClockOffset || 0, sha256 } = input;
  let signer;
  if (input.signer) {
    signer = normalizeProvider(input.signer);
  } else if (input.regionInfoProvider) {
    signer = () => normalizeProvider(input.region)().then(async (region) => [
      await input.regionInfoProvider(region, {
        useFipsEndpoint: await input.useFipsEndpoint(),
        useDualstackEndpoint: await input.useDualstackEndpoint()
      }) || {},
      region
    ]).then(([regionInfo, region]) => {
      const { signingRegion, signingService } = regionInfo;
      input.signingRegion = input.signingRegion || signingRegion || region;
      input.signingName = input.signingName || signingService || input.serviceId;
      const params = {
        ...input,
        credentials: normalizedCreds,
        region: input.signingRegion,
        service: input.signingName,
        sha256,
        uriEscapePath: signingEscapePath
      };
      const SignerCtor = input.signerConstructor || SignatureV4;
      return new SignerCtor(params);
    });
  } else {
    signer = async (authScheme) => {
      authScheme = Object.assign({}, {
        name: "sigv4",
        signingName: input.signingName || input.defaultSigningName,
        signingRegion: await normalizeProvider(input.region)(),
        properties: {}
      }, authScheme);
      const signingRegion = authScheme.signingRegion;
      const signingService = authScheme.signingName;
      input.signingRegion = input.signingRegion || signingRegion;
      input.signingName = input.signingName || signingService || input.serviceId;
      const params = {
        ...input,
        credentials: normalizedCreds,
        region: input.signingRegion,
        service: input.signingName,
        sha256,
        uriEscapePath: signingEscapePath
      };
      const SignerCtor = input.signerConstructor || SignatureV4;
      return new SignerCtor(params);
    };
  }
  return {
    ...input,
    systemClockOffset,
    signingEscapePath,
    credentials: normalizedCreds,
    signer
  };
};
var normalizeCredentialProvider = (credentials) => {
  if (typeof credentials === "function") {
    return memoize(credentials, (credentials2) => credentials2.expiration !== void 0 && credentials2.expiration.getTime() - Date.now() < CREDENTIAL_EXPIRE_WINDOW, (credentials2) => credentials2.expiration !== void 0);
  }
  return normalizeProvider(credentials);
};

// node_modules/@aws-sdk/middleware-signing/dist-es/utils/getSkewCorrectedDate.js
var getSkewCorrectedDate = (systemClockOffset) => new Date(Date.now() + systemClockOffset);

// node_modules/@aws-sdk/middleware-signing/dist-es/utils/isClockSkewed.js
var isClockSkewed = (clockTime, systemClockOffset) => Math.abs(getSkewCorrectedDate(systemClockOffset).getTime() - clockTime) >= 3e5;

// node_modules/@aws-sdk/middleware-signing/dist-es/utils/getUpdatedSystemClockOffset.js
var getUpdatedSystemClockOffset = (clockTime, currentSystemClockOffset) => {
  const clockTimeInMs = Date.parse(clockTime);
  if (isClockSkewed(clockTimeInMs, currentSystemClockOffset)) {
    return clockTimeInMs - Date.now();
  }
  return currentSystemClockOffset;
};

// node_modules/@aws-sdk/middleware-signing/dist-es/middleware.js
var awsAuthMiddleware = (options) => (next, context) => async function(args) {
  var _a, _b, _c, _d;
  if (!HttpRequest.isInstance(args.request))
    return next(args);
  const authScheme = (_c = (_b = (_a = context.endpointV2) == null ? void 0 : _a.properties) == null ? void 0 : _b.authSchemes) == null ? void 0 : _c[0];
  const multiRegionOverride = (authScheme == null ? void 0 : authScheme.name) === "sigv4a" ? (_d = authScheme == null ? void 0 : authScheme.signingRegionSet) == null ? void 0 : _d.join(",") : void 0;
  const signer = await options.signer(authScheme);
  const output = await next({
    ...args,
    request: await signer.sign(args.request, {
      signingDate: getSkewCorrectedDate(options.systemClockOffset),
      signingRegion: multiRegionOverride || context["signing_region"],
      signingService: context["signing_service"]
    })
  }).catch((error) => {
    var _a2;
    const serverTime = (_a2 = error.ServerTime) != null ? _a2 : getDateHeader(error.$response);
    if (serverTime) {
      options.systemClockOffset = getUpdatedSystemClockOffset(serverTime, options.systemClockOffset);
    }
    throw error;
  });
  const dateHeader = getDateHeader(output.response);
  if (dateHeader) {
    options.systemClockOffset = getUpdatedSystemClockOffset(dateHeader, options.systemClockOffset);
  }
  return output;
};
var getDateHeader = (response) => {
  var _a, _b, _c;
  return HttpResponse.isInstance(response) ? (_c = (_a = response.headers) == null ? void 0 : _a.date) != null ? _c : (_b = response.headers) == null ? void 0 : _b.Date : void 0;
};
var awsAuthMiddlewareOptions = {
  name: "awsAuthMiddleware",
  tags: ["SIGNATURE", "AWSAUTH"],
  relation: "after",
  toMiddleware: "retryMiddleware",
  override: true
};
var getAwsAuthPlugin = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.addRelativeTo(awsAuthMiddleware(options), awsAuthMiddlewareOptions);
  }
});

// node_modules/@aws-sdk/middleware-user-agent/dist-es/configurations.js
function resolveUserAgentConfig(input) {
  return {
    ...input,
    customUserAgent: typeof input.customUserAgent === "string" ? [[input.customUserAgent]] : input.customUserAgent
  };
}

// node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/partitions.json
var partitions_default = {
  partitions: [{
    id: "aws",
    outputs: {
      dnsSuffix: "amazonaws.com",
      dualStackDnsSuffix: "api.aws",
      name: "aws",
      supportsDualStack: true,
      supportsFIPS: true
    },
    regionRegex: "^(us|eu|ap|sa|ca|me|af)\\-\\w+\\-\\d+$",
    regions: {
      "af-south-1": {
        description: "Africa (Cape Town)"
      },
      "ap-east-1": {
        description: "Asia Pacific (Hong Kong)"
      },
      "ap-northeast-1": {
        description: "Asia Pacific (Tokyo)"
      },
      "ap-northeast-2": {
        description: "Asia Pacific (Seoul)"
      },
      "ap-northeast-3": {
        description: "Asia Pacific (Osaka)"
      },
      "ap-south-1": {
        description: "Asia Pacific (Mumbai)"
      },
      "ap-south-2": {
        description: "Asia Pacific (Hyderabad)"
      },
      "ap-southeast-1": {
        description: "Asia Pacific (Singapore)"
      },
      "ap-southeast-2": {
        description: "Asia Pacific (Sydney)"
      },
      "ap-southeast-3": {
        description: "Asia Pacific (Jakarta)"
      },
      "ap-southeast-4": {
        description: "Asia Pacific (Melbourne)"
      },
      "aws-global": {
        description: "AWS Standard global region"
      },
      "ca-central-1": {
        description: "Canada (Central)"
      },
      "eu-central-1": {
        description: "Europe (Frankfurt)"
      },
      "eu-central-2": {
        description: "Europe (Zurich)"
      },
      "eu-north-1": {
        description: "Europe (Stockholm)"
      },
      "eu-south-1": {
        description: "Europe (Milan)"
      },
      "eu-south-2": {
        description: "Europe (Spain)"
      },
      "eu-west-1": {
        description: "Europe (Ireland)"
      },
      "eu-west-2": {
        description: "Europe (London)"
      },
      "eu-west-3": {
        description: "Europe (Paris)"
      },
      "me-central-1": {
        description: "Middle East (UAE)"
      },
      "me-south-1": {
        description: "Middle East (Bahrain)"
      },
      "sa-east-1": {
        description: "South America (Sao Paulo)"
      },
      "us-east-1": {
        description: "US East (N. Virginia)"
      },
      "us-east-2": {
        description: "US East (Ohio)"
      },
      "us-west-1": {
        description: "US West (N. California)"
      },
      "us-west-2": {
        description: "US West (Oregon)"
      }
    }
  }, {
    id: "aws-cn",
    outputs: {
      dnsSuffix: "amazonaws.com.cn",
      dualStackDnsSuffix: "api.amazonwebservices.com.cn",
      name: "aws-cn",
      supportsDualStack: true,
      supportsFIPS: true
    },
    regionRegex: "^cn\\-\\w+\\-\\d+$",
    regions: {
      "aws-cn-global": {
        description: "AWS China global region"
      },
      "cn-north-1": {
        description: "China (Beijing)"
      },
      "cn-northwest-1": {
        description: "China (Ningxia)"
      }
    }
  }, {
    id: "aws-us-gov",
    outputs: {
      dnsSuffix: "amazonaws.com",
      dualStackDnsSuffix: "api.aws",
      name: "aws-us-gov",
      supportsDualStack: true,
      supportsFIPS: true
    },
    regionRegex: "^us\\-gov\\-\\w+\\-\\d+$",
    regions: {
      "aws-us-gov-global": {
        description: "AWS GovCloud (US) global region"
      },
      "us-gov-east-1": {
        description: "AWS GovCloud (US-East)"
      },
      "us-gov-west-1": {
        description: "AWS GovCloud (US-West)"
      }
    }
  }, {
    id: "aws-iso",
    outputs: {
      dnsSuffix: "c2s.ic.gov",
      dualStackDnsSuffix: "c2s.ic.gov",
      name: "aws-iso",
      supportsDualStack: false,
      supportsFIPS: true
    },
    regionRegex: "^us\\-iso\\-\\w+\\-\\d+$",
    regions: {
      "aws-iso-global": {
        description: "AWS ISO (US) global region"
      },
      "us-iso-east-1": {
        description: "US ISO East"
      },
      "us-iso-west-1": {
        description: "US ISO WEST"
      }
    }
  }, {
    id: "aws-iso-b",
    outputs: {
      dnsSuffix: "sc2s.sgov.gov",
      dualStackDnsSuffix: "sc2s.sgov.gov",
      name: "aws-iso-b",
      supportsDualStack: false,
      supportsFIPS: true
    },
    regionRegex: "^us\\-isob\\-\\w+\\-\\d+$",
    regions: {
      "aws-iso-b-global": {
        description: "AWS ISOB (US) global region"
      },
      "us-isob-east-1": {
        description: "US ISOB East (Ohio)"
      }
    }
  }],
  version: "1.1"
};

// node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/partition.js
var selectedPartitionsInfo = partitions_default;
var selectedUserAgentPrefix = "";
var partition = (value) => {
  const { partitions } = selectedPartitionsInfo;
  for (const partition2 of partitions) {
    const { regions, outputs } = partition2;
    for (const [region, regionData] of Object.entries(regions)) {
      if (region === value) {
        return {
          ...outputs,
          ...regionData
        };
      }
    }
  }
  for (const partition2 of partitions) {
    const { regionRegex, outputs } = partition2;
    if (new RegExp(regionRegex).test(value)) {
      return {
        ...outputs
      };
    }
  }
  const DEFAULT_PARTITION = partitions.find((partition2) => partition2.id === "aws");
  if (!DEFAULT_PARTITION) {
    throw new Error("Provided region was not found in the partition array or regex, and default partition with id 'aws' doesn't exist.");
  }
  return {
    ...DEFAULT_PARTITION.outputs
  };
};
var setPartitionInfo = (partitionsInfo, userAgentPrefix = "") => {
  selectedPartitionsInfo = partitionsInfo;
  selectedUserAgentPrefix = userAgentPrefix;
};
var useDefaultPartitionInfo = () => {
  setPartitionInfo(partitions_default, "");
};
var getUserAgentPrefix = () => selectedUserAgentPrefix;

// node_modules/@aws-sdk/util-endpoints/dist-es/debug/debugId.js
var debugId = "endpoints";

// node_modules/@aws-sdk/util-endpoints/dist-es/debug/toDebugString.js
function toDebugString(input) {
  if (typeof input !== "object" || input == null) {
    return input;
  }
  if ("ref" in input) {
    return `$${toDebugString(input.ref)}`;
  }
  if ("fn" in input) {
    return `${input.fn}(${(input.argv || []).map(toDebugString).join(", ")})`;
  }
  return JSON.stringify(input, null, 2);
}

// node_modules/@aws-sdk/util-endpoints/dist-es/types/EndpointError.js
var EndpointError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "EndpointError";
  }
};

// node_modules/@aws-sdk/util-endpoints/dist-es/lib/index.js
var lib_exports = {};
__export(lib_exports, {
  aws: () => aws_exports,
  booleanEquals: () => booleanEquals,
  getAttr: () => getAttr,
  isSet: () => isSet,
  isValidHostLabel: () => isValidHostLabel,
  not: () => not,
  parseURL: () => parseURL,
  stringEquals: () => stringEquals,
  substring: () => substring,
  uriEncode: () => uriEncode
});

// node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/index.js
var aws_exports = {};
__export(aws_exports, {
  getUserAgentPrefix: () => getUserAgentPrefix,
  isVirtualHostableS3Bucket: () => isVirtualHostableS3Bucket,
  parseArn: () => parseArn,
  partition: () => partition,
  setPartitionInfo: () => setPartitionInfo,
  useDefaultPartitionInfo: () => useDefaultPartitionInfo
});

// node_modules/@aws-sdk/util-endpoints/dist-es/lib/isIpAddress.js
var IP_V4_REGEX = new RegExp(`^(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}$`);
var isIpAddress = (value) => IP_V4_REGEX.test(value) || value.startsWith("[") && value.endsWith("]");

// node_modules/@aws-sdk/util-endpoints/dist-es/lib/isValidHostLabel.js
var VALID_HOST_LABEL_REGEX = new RegExp(`^(?!.*-$)(?!-)[a-zA-Z0-9-]{1,63}$`);
var isValidHostLabel = (value, allowSubDomains = false) => {
  if (!allowSubDomains) {
    return VALID_HOST_LABEL_REGEX.test(value);
  }
  const labels = value.split(".");
  for (const label of labels) {
    if (!isValidHostLabel(label)) {
      return false;
    }
  }
  return true;
};

// node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/isVirtualHostableS3Bucket.js
var isVirtualHostableS3Bucket = (value, allowSubDomains = false) => {
  if (allowSubDomains) {
    for (const label of value.split(".")) {
      if (!isVirtualHostableS3Bucket(label)) {
        return false;
      }
    }
    return true;
  }
  if (!isValidHostLabel(value)) {
    return false;
  }
  if (value.length < 3 || value.length > 63) {
    return false;
  }
  if (value !== value.toLowerCase()) {
    return false;
  }
  if (isIpAddress(value)) {
    return false;
  }
  return true;
};

// node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/parseArn.js
var parseArn = (value) => {
  const segments = value.split(":");
  if (segments.length < 6)
    return null;
  const [arn, partition2, service, region, accountId, ...resourceId] = segments;
  if (arn !== "arn" || partition2 === "" || service === "" || resourceId[0] === "")
    return null;
  return {
    partition: partition2,
    service,
    region,
    accountId,
    resourceId: resourceId[0].includes("/") ? resourceId[0].split("/") : resourceId
  };
};

// node_modules/@aws-sdk/util-endpoints/dist-es/lib/booleanEquals.js
var booleanEquals = (value1, value2) => value1 === value2;

// node_modules/@aws-sdk/util-endpoints/dist-es/lib/getAttrPathList.js
var getAttrPathList = (path2) => {
  const parts = path2.split(".");
  const pathList = [];
  for (const part of parts) {
    const squareBracketIndex = part.indexOf("[");
    if (squareBracketIndex !== -1) {
      if (part.indexOf("]") !== part.length - 1) {
        throw new EndpointError(`Path: '${path2}' does not end with ']'`);
      }
      const arrayIndex = part.slice(squareBracketIndex + 1, -1);
      if (Number.isNaN(parseInt(arrayIndex))) {
        throw new EndpointError(`Invalid array index: '${arrayIndex}' in path: '${path2}'`);
      }
      if (squareBracketIndex !== 0) {
        pathList.push(part.slice(0, squareBracketIndex));
      }
      pathList.push(arrayIndex);
    } else {
      pathList.push(part);
    }
  }
  return pathList;
};

// node_modules/@aws-sdk/util-endpoints/dist-es/lib/getAttr.js
var getAttr = (value, path2) => getAttrPathList(path2).reduce((acc, index) => {
  if (typeof acc !== "object") {
    throw new EndpointError(`Index '${index}' in '${path2}' not found in '${JSON.stringify(value)}'`);
  } else if (Array.isArray(acc)) {
    return acc[parseInt(index)];
  }
  return acc[index];
}, value);

// node_modules/@aws-sdk/util-endpoints/dist-es/lib/isSet.js
var isSet = (value) => value != null;

// node_modules/@aws-sdk/util-endpoints/dist-es/lib/not.js
var not = (value) => !value;

// node_modules/@aws-sdk/types/dist-es/auth.js
var HttpAuthLocation2;
(function(HttpAuthLocation3) {
  HttpAuthLocation3["HEADER"] = "header";
  HttpAuthLocation3["QUERY"] = "query";
})(HttpAuthLocation2 || (HttpAuthLocation2 = {}));

// node_modules/@aws-sdk/types/dist-es/dns.js
var HostAddressType;
(function(HostAddressType2) {
  HostAddressType2["AAAA"] = "AAAA";
  HostAddressType2["A"] = "A";
})(HostAddressType || (HostAddressType = {}));

// node_modules/@aws-sdk/types/dist-es/endpoint.js
var EndpointURLScheme2;
(function(EndpointURLScheme3) {
  EndpointURLScheme3["HTTP"] = "http";
  EndpointURLScheme3["HTTPS"] = "https";
})(EndpointURLScheme2 || (EndpointURLScheme2 = {}));

// node_modules/@aws-sdk/types/dist-es/transfer.js
var RequestHandlerProtocol2;
(function(RequestHandlerProtocol3) {
  RequestHandlerProtocol3["HTTP_0_9"] = "http/0.9";
  RequestHandlerProtocol3["HTTP_1_0"] = "http/1.0";
  RequestHandlerProtocol3["TDS_8_0"] = "tds/8.0";
})(RequestHandlerProtocol2 || (RequestHandlerProtocol2 = {}));

// node_modules/@aws-sdk/util-endpoints/dist-es/lib/parseURL.js
var DEFAULT_PORTS = {
  [EndpointURLScheme2.HTTP]: 80,
  [EndpointURLScheme2.HTTPS]: 443
};
var parseURL = (value) => {
  const whatwgURL = (() => {
    try {
      if (value instanceof URL) {
        return value;
      }
      if (typeof value === "object" && "hostname" in value) {
        const { hostname: hostname2, port, protocol: protocol2 = "", path: path2 = "", query = {} } = value;
        const url = new URL(`${protocol2}//${hostname2}${port ? `:${port}` : ""}${path2}`);
        url.search = Object.entries(query).map(([k2, v2]) => `${k2}=${v2}`).join("&");
        return url;
      }
      return new URL(value);
    } catch (error) {
      return null;
    }
  })();
  if (!whatwgURL) {
    console.error(`Unable to parse ${JSON.stringify(value)} as a whatwg URL.`);
    return null;
  }
  const urlString = whatwgURL.href;
  const { host, hostname, pathname, protocol, search } = whatwgURL;
  if (search) {
    return null;
  }
  const scheme = protocol.slice(0, -1);
  if (!Object.values(EndpointURLScheme2).includes(scheme)) {
    return null;
  }
  const isIp = isIpAddress(hostname);
  const inputContainsDefaultPort = urlString.includes(`${host}:${DEFAULT_PORTS[scheme]}`) || typeof value === "string" && value.includes(`${host}:${DEFAULT_PORTS[scheme]}`);
  const authority = `${host}${inputContainsDefaultPort ? `:${DEFAULT_PORTS[scheme]}` : ``}`;
  return {
    scheme,
    authority,
    path: pathname,
    normalizedPath: pathname.endsWith("/") ? pathname : `${pathname}/`,
    isIp
  };
};

// node_modules/@aws-sdk/util-endpoints/dist-es/lib/stringEquals.js
var stringEquals = (value1, value2) => value1 === value2;

// node_modules/@aws-sdk/util-endpoints/dist-es/lib/substring.js
var substring = (input, start, stop, reverse) => {
  if (start >= stop || input.length < stop) {
    return null;
  }
  if (!reverse) {
    return input.substring(start, stop);
  }
  return input.substring(input.length - stop, input.length - start);
};

// node_modules/@aws-sdk/util-endpoints/dist-es/lib/uriEncode.js
var uriEncode = (value) => encodeURIComponent(value).replace(/[!*'()]/g, (c3) => `%${c3.charCodeAt(0).toString(16).toUpperCase()}`);

// node_modules/@aws-sdk/util-endpoints/dist-es/utils/evaluateTemplate.js
var evaluateTemplate = (template, options) => {
  const evaluatedTemplateArr = [];
  const templateContext = {
    ...options.endpointParams,
    ...options.referenceRecord
  };
  let currentIndex = 0;
  while (currentIndex < template.length) {
    const openingBraceIndex = template.indexOf("{", currentIndex);
    if (openingBraceIndex === -1) {
      evaluatedTemplateArr.push(template.slice(currentIndex));
      break;
    }
    evaluatedTemplateArr.push(template.slice(currentIndex, openingBraceIndex));
    const closingBraceIndex = template.indexOf("}", openingBraceIndex);
    if (closingBraceIndex === -1) {
      evaluatedTemplateArr.push(template.slice(openingBraceIndex));
      break;
    }
    if (template[openingBraceIndex + 1] === "{" && template[closingBraceIndex + 1] === "}") {
      evaluatedTemplateArr.push(template.slice(openingBraceIndex + 1, closingBraceIndex));
      currentIndex = closingBraceIndex + 2;
    }
    const parameterName = template.substring(openingBraceIndex + 1, closingBraceIndex);
    if (parameterName.includes("#")) {
      const [refName, attrName] = parameterName.split("#");
      evaluatedTemplateArr.push(getAttr(templateContext[refName], attrName));
    } else {
      evaluatedTemplateArr.push(templateContext[parameterName]);
    }
    currentIndex = closingBraceIndex + 1;
  }
  return evaluatedTemplateArr.join("");
};

// node_modules/@aws-sdk/util-endpoints/dist-es/utils/getReferenceValue.js
var getReferenceValue = ({ ref }, options) => {
  const referenceRecord = {
    ...options.endpointParams,
    ...options.referenceRecord
  };
  return referenceRecord[ref];
};

// node_modules/@aws-sdk/util-endpoints/dist-es/utils/evaluateExpression.js
var evaluateExpression = (obj, keyName, options) => {
  if (typeof obj === "string") {
    return evaluateTemplate(obj, options);
  } else if (obj["fn"]) {
    return callFunction(obj, options);
  } else if (obj["ref"]) {
    return getReferenceValue(obj, options);
  }
  throw new EndpointError(`'${keyName}': ${String(obj)} is not a string, function or reference.`);
};

// node_modules/@aws-sdk/util-endpoints/dist-es/utils/callFunction.js
var callFunction = ({ fn, argv }, options) => {
  const evaluatedArgs = argv.map((arg) => ["boolean", "number"].includes(typeof arg) ? arg : evaluateExpression(arg, "arg", options));
  return fn.split(".").reduce((acc, key) => acc[key], lib_exports)(...evaluatedArgs);
};

// node_modules/@aws-sdk/util-endpoints/dist-es/utils/evaluateCondition.js
var evaluateCondition = ({ assign, ...fnArgs }, options) => {
  var _a, _b;
  if (assign && assign in options.referenceRecord) {
    throw new EndpointError(`'${assign}' is already defined in Reference Record.`);
  }
  const value = callFunction(fnArgs, options);
  (_b = (_a = options.logger) == null ? void 0 : _a.debug) == null ? void 0 : _b.call(_a, debugId, `evaluateCondition: ${toDebugString(fnArgs)} = ${toDebugString(value)}`);
  return {
    result: value === "" ? true : !!value,
    ...assign != null && { toAssign: { name: assign, value } }
  };
};

// node_modules/@aws-sdk/util-endpoints/dist-es/utils/evaluateConditions.js
var evaluateConditions = (conditions = [], options) => {
  var _a, _b;
  const conditionsReferenceRecord = {};
  for (const condition of conditions) {
    const { result, toAssign } = evaluateCondition(condition, {
      ...options,
      referenceRecord: {
        ...options.referenceRecord,
        ...conditionsReferenceRecord
      }
    });
    if (!result) {
      return { result };
    }
    if (toAssign) {
      conditionsReferenceRecord[toAssign.name] = toAssign.value;
      (_b = (_a = options.logger) == null ? void 0 : _a.debug) == null ? void 0 : _b.call(_a, debugId, `assign: ${toAssign.name} := ${toDebugString(toAssign.value)}`);
    }
  }
  return { result: true, referenceRecord: conditionsReferenceRecord };
};

// node_modules/@aws-sdk/util-endpoints/dist-es/utils/getEndpointHeaders.js
var getEndpointHeaders = (headers, options) => Object.entries(headers).reduce((acc, [headerKey, headerVal]) => ({
  ...acc,
  [headerKey]: headerVal.map((headerValEntry) => {
    const processedExpr = evaluateExpression(headerValEntry, "Header value entry", options);
    if (typeof processedExpr !== "string") {
      throw new EndpointError(`Header '${headerKey}' value '${processedExpr}' is not a string`);
    }
    return processedExpr;
  })
}), {});

// node_modules/@aws-sdk/util-endpoints/dist-es/utils/getEndpointProperty.js
var getEndpointProperty = (property, options) => {
  if (Array.isArray(property)) {
    return property.map((propertyEntry) => getEndpointProperty(propertyEntry, options));
  }
  switch (typeof property) {
    case "string":
      return evaluateTemplate(property, options);
    case "object":
      if (property === null) {
        throw new EndpointError(`Unexpected endpoint property: ${property}`);
      }
      return getEndpointProperties(property, options);
    case "boolean":
      return property;
    default:
      throw new EndpointError(`Unexpected endpoint property type: ${typeof property}`);
  }
};

// node_modules/@aws-sdk/util-endpoints/dist-es/utils/getEndpointProperties.js
var getEndpointProperties = (properties, options) => Object.entries(properties).reduce((acc, [propertyKey, propertyVal]) => ({
  ...acc,
  [propertyKey]: getEndpointProperty(propertyVal, options)
}), {});

// node_modules/@aws-sdk/util-endpoints/dist-es/utils/getEndpointUrl.js
var getEndpointUrl = (endpointUrl, options) => {
  const expression = evaluateExpression(endpointUrl, "Endpoint URL", options);
  if (typeof expression === "string") {
    try {
      return new URL(expression);
    } catch (error) {
      console.error(`Failed to construct URL with ${expression}`, error);
      throw error;
    }
  }
  throw new EndpointError(`Endpoint URL must be a string, got ${typeof expression}`);
};

// node_modules/@aws-sdk/util-endpoints/dist-es/utils/evaluateEndpointRule.js
var evaluateEndpointRule = (endpointRule, options) => {
  var _a, _b;
  const { conditions, endpoint } = endpointRule;
  const { result, referenceRecord } = evaluateConditions(conditions, options);
  if (!result) {
    return;
  }
  const endpointRuleOptions = {
    ...options,
    referenceRecord: { ...options.referenceRecord, ...referenceRecord }
  };
  const { url, properties, headers } = endpoint;
  (_b = (_a = options.logger) == null ? void 0 : _a.debug) == null ? void 0 : _b.call(_a, debugId, `Resolving endpoint from template: ${toDebugString(endpoint)}`);
  return {
    ...headers != void 0 && {
      headers: getEndpointHeaders(headers, endpointRuleOptions)
    },
    ...properties != void 0 && {
      properties: getEndpointProperties(properties, endpointRuleOptions)
    },
    url: getEndpointUrl(url, endpointRuleOptions)
  };
};

// node_modules/@aws-sdk/util-endpoints/dist-es/utils/evaluateErrorRule.js
var evaluateErrorRule = (errorRule, options) => {
  const { conditions, error } = errorRule;
  const { result, referenceRecord } = evaluateConditions(conditions, options);
  if (!result) {
    return;
  }
  throw new EndpointError(evaluateExpression(error, "Error", {
    ...options,
    referenceRecord: { ...options.referenceRecord, ...referenceRecord }
  }));
};

// node_modules/@aws-sdk/util-endpoints/dist-es/utils/evaluateTreeRule.js
var evaluateTreeRule = (treeRule, options) => {
  const { conditions, rules } = treeRule;
  const { result, referenceRecord } = evaluateConditions(conditions, options);
  if (!result) {
    return;
  }
  return evaluateRules(rules, {
    ...options,
    referenceRecord: { ...options.referenceRecord, ...referenceRecord }
  });
};

// node_modules/@aws-sdk/util-endpoints/dist-es/utils/evaluateRules.js
var evaluateRules = (rules, options) => {
  for (const rule of rules) {
    if (rule.type === "endpoint") {
      const endpointOrUndefined = evaluateEndpointRule(rule, options);
      if (endpointOrUndefined) {
        return endpointOrUndefined;
      }
    } else if (rule.type === "error") {
      evaluateErrorRule(rule, options);
    } else if (rule.type === "tree") {
      const endpointOrUndefined = evaluateTreeRule(rule, options);
      if (endpointOrUndefined) {
        return endpointOrUndefined;
      }
    } else {
      throw new EndpointError(`Unknown endpoint rule: ${rule}`);
    }
  }
  throw new EndpointError(`Rules evaluation failed`);
};

// node_modules/@aws-sdk/util-endpoints/dist-es/resolveEndpoint.js
var resolveEndpoint = (ruleSetObject, options) => {
  var _a, _b, _c, _d, _e, _f;
  const { endpointParams, logger } = options;
  const { parameters, rules } = ruleSetObject;
  (_b = (_a = options.logger) == null ? void 0 : _a.debug) == null ? void 0 : _b.call(_a, debugId, `Initial EndpointParams: ${toDebugString(endpointParams)}`);
  const paramsWithDefault = Object.entries(parameters).filter(([, v2]) => v2.default != null).map(([k2, v2]) => [k2, v2.default]);
  if (paramsWithDefault.length > 0) {
    for (const [paramKey, paramDefaultValue] of paramsWithDefault) {
      endpointParams[paramKey] = (_c = endpointParams[paramKey]) != null ? _c : paramDefaultValue;
    }
  }
  const requiredParams = Object.entries(parameters).filter(([, v2]) => v2.required).map(([k2]) => k2);
  for (const requiredParam of requiredParams) {
    if (endpointParams[requiredParam] == null) {
      throw new EndpointError(`Missing required parameter: '${requiredParam}'`);
    }
  }
  const endpoint = evaluateRules(rules, { endpointParams, logger, referenceRecord: {} });
  if ((_d = options.endpointParams) == null ? void 0 : _d.Endpoint) {
    try {
      const givenEndpoint = new URL(options.endpointParams.Endpoint);
      const { protocol, port } = givenEndpoint;
      endpoint.url.protocol = protocol;
      endpoint.url.port = port;
    } catch (e3) {
    }
  }
  (_f = (_e = options.logger) == null ? void 0 : _e.debug) == null ? void 0 : _f.call(_e, debugId, `Resolved endpoint: ${toDebugString(endpoint)}`);
  return endpoint;
};

// node_modules/@aws-sdk/middleware-user-agent/dist-es/constants.js
var USER_AGENT = "user-agent";
var X_AMZ_USER_AGENT = "x-amz-user-agent";
var SPACE2 = " ";
var UA_ESCAPE_REGEX = /[^\!\#\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w]/g;

// node_modules/@aws-sdk/middleware-user-agent/dist-es/user-agent-middleware.js
var userAgentMiddleware = (options) => (next, context) => async (args) => {
  var _a, _b;
  const { request } = args;
  if (!HttpRequest.isInstance(request))
    return next(args);
  const { headers } = request;
  const userAgent = ((_a = context == null ? void 0 : context.userAgent) == null ? void 0 : _a.map(escapeUserAgent)) || [];
  const defaultUserAgent2 = (await options.defaultUserAgentProvider()).map(escapeUserAgent);
  const customUserAgent = ((_b = options == null ? void 0 : options.customUserAgent) == null ? void 0 : _b.map(escapeUserAgent)) || [];
  const prefix = getUserAgentPrefix();
  const sdkUserAgentValue = (prefix ? [prefix] : []).concat([...defaultUserAgent2, ...userAgent, ...customUserAgent]).join(SPACE2);
  const normalUAValue = [
    ...defaultUserAgent2.filter((section) => section.startsWith("aws-sdk-")),
    ...customUserAgent
  ].join(SPACE2);
  if (options.runtime !== "browser") {
    if (normalUAValue) {
      headers[X_AMZ_USER_AGENT] = headers[X_AMZ_USER_AGENT] ? `${headers[USER_AGENT]} ${normalUAValue}` : normalUAValue;
    }
    headers[USER_AGENT] = sdkUserAgentValue;
  } else {
    headers[X_AMZ_USER_AGENT] = sdkUserAgentValue;
  }
  return next({
    ...args,
    request
  });
};
var escapeUserAgent = ([name, version]) => {
  const prefixSeparatorIndex = name.indexOf("/");
  const prefix = name.substring(0, prefixSeparatorIndex);
  let uaName = name.substring(prefixSeparatorIndex + 1);
  if (prefix === "api") {
    uaName = uaName.toLowerCase();
  }
  return [prefix, uaName, version].filter((item) => item && item.length > 0).map((item) => item == null ? void 0 : item.replace(UA_ESCAPE_REGEX, "_")).join("/");
};
var getUserAgentMiddlewareOptions = {
  name: "getUserAgentMiddleware",
  step: "build",
  priority: "low",
  tags: ["SET_USER_AGENT", "USER_AGENT"],
  override: true
};
var getUserAgentPlugin = (config) => ({
  applyToStack: (clientStack) => {
    clientStack.add(userAgentMiddleware(config), getUserAgentMiddlewareOptions);
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/endpoint/EndpointParameters.js
var resolveClientEndpointParameters = (options) => {
  var _a, _b, _c, _d, _e;
  return {
    ...options,
    useFipsEndpoint: (_a = options.useFipsEndpoint) != null ? _a : false,
    useDualstackEndpoint: (_b = options.useDualstackEndpoint) != null ? _b : false,
    useAccelerateEndpoint: (_c = options.useAccelerateEndpoint) != null ? _c : false,
    useGlobalEndpoint: (_d = options.useGlobalEndpoint) != null ? _d : false,
    disableMultiregionAccessPoints: (_e = options.disableMultiregionAccessPoints) != null ? _e : false,
    defaultSigningName: "s3"
  };
};

// node_modules/@aws-sdk/client-s3/package.json
var package_default = {
  name: "@aws-sdk/client-s3",
  description: "AWS SDK for JavaScript S3 Client for Node.js, Browser and React Native",
  version: "3.317.0",
  scripts: {
    build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "tsc -p tsconfig.cjs.json",
    "build:docs": "typedoc",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "extract:docs": "api-extractor run --local",
    "generate:client": "node ../../scripts/generate-clients/single-service --solo s3",
    test: "yarn test:unit",
    "test:e2e": "ts-mocha test/**/*.ispec.ts && karma start karma.conf.js",
    "test:unit": "ts-mocha test/**/*.spec.ts"
  },
  main: "./dist-cjs/index.js",
  types: "./dist-types/index.d.ts",
  module: "./dist-es/index.js",
  sideEffects: false,
  dependencies: {
    "@aws-crypto/sha1-browser": "3.0.0",
    "@aws-crypto/sha256-browser": "3.0.0",
    "@aws-crypto/sha256-js": "3.0.0",
    "@aws-sdk/client-sts": "3.316.0",
    "@aws-sdk/config-resolver": "3.310.0",
    "@aws-sdk/credential-provider-node": "3.316.0",
    "@aws-sdk/eventstream-serde-browser": "3.310.0",
    "@aws-sdk/eventstream-serde-config-resolver": "3.310.0",
    "@aws-sdk/eventstream-serde-node": "3.310.0",
    "@aws-sdk/fetch-http-handler": "3.310.0",
    "@aws-sdk/hash-blob-browser": "3.310.0",
    "@aws-sdk/hash-node": "3.310.0",
    "@aws-sdk/hash-stream-node": "3.310.0",
    "@aws-sdk/invalid-dependency": "3.310.0",
    "@aws-sdk/md5-js": "3.310.0",
    "@aws-sdk/middleware-bucket-endpoint": "3.310.0",
    "@aws-sdk/middleware-content-length": "3.310.0",
    "@aws-sdk/middleware-endpoint": "3.310.0",
    "@aws-sdk/middleware-expect-continue": "3.310.0",
    "@aws-sdk/middleware-flexible-checksums": "3.310.0",
    "@aws-sdk/middleware-host-header": "3.310.0",
    "@aws-sdk/middleware-location-constraint": "3.310.0",
    "@aws-sdk/middleware-logger": "3.310.0",
    "@aws-sdk/middleware-recursion-detection": "3.310.0",
    "@aws-sdk/middleware-retry": "3.310.0",
    "@aws-sdk/middleware-sdk-s3": "3.310.0",
    "@aws-sdk/middleware-serde": "3.310.0",
    "@aws-sdk/middleware-signing": "3.310.0",
    "@aws-sdk/middleware-ssec": "3.310.0",
    "@aws-sdk/middleware-stack": "3.310.0",
    "@aws-sdk/middleware-user-agent": "3.310.0",
    "@aws-sdk/node-config-provider": "3.310.0",
    "@aws-sdk/node-http-handler": "3.310.0",
    "@aws-sdk/protocol-http": "3.310.0",
    "@aws-sdk/signature-v4-multi-region": "3.310.0",
    "@aws-sdk/smithy-client": "3.316.0",
    "@aws-sdk/types": "3.310.0",
    "@aws-sdk/url-parser": "3.310.0",
    "@aws-sdk/util-base64": "3.310.0",
    "@aws-sdk/util-body-length-browser": "3.310.0",
    "@aws-sdk/util-body-length-node": "3.310.0",
    "@aws-sdk/util-defaults-mode-browser": "3.316.0",
    "@aws-sdk/util-defaults-mode-node": "3.316.0",
    "@aws-sdk/util-endpoints": "3.310.0",
    "@aws-sdk/util-retry": "3.310.0",
    "@aws-sdk/util-stream-browser": "3.310.0",
    "@aws-sdk/util-stream-node": "3.310.0",
    "@aws-sdk/util-user-agent-browser": "3.310.0",
    "@aws-sdk/util-user-agent-node": "3.310.0",
    "@aws-sdk/util-utf8": "3.310.0",
    "@aws-sdk/util-waiter": "3.310.0",
    "@aws-sdk/xml-builder": "3.310.0",
    "fast-xml-parser": "4.1.2",
    tslib: "^2.5.0"
  },
  devDependencies: {
    "@aws-sdk/service-client-documentation-generator": "3.310.0",
    "@tsconfig/node14": "1.0.3",
    "@types/chai": "^4.2.11",
    "@types/mocha": "^8.0.4",
    "@types/node": "^14.14.31",
    concurrently: "7.0.0",
    "downlevel-dts": "0.10.1",
    rimraf: "3.0.2",
    typedoc: "0.23.23",
    typescript: "~4.9.5"
  },
  engines: {
    node: ">=14.0.0"
  },
  typesVersions: {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  files: [
    "dist-*/**"
  ],
  author: {
    name: "AWS SDK for JavaScript Team",
    url: "https://aws.amazon.com/javascript/"
  },
  license: "Apache-2.0",
  browser: {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
  },
  "react-native": {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
  },
  homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-s3",
  repository: {
    type: "git",
    url: "https://github.com/aws/aws-sdk-js-v3.git",
    directory: "clients/client-s3"
  }
};

// node_modules/@aws-sdk/client-s3/dist-es/runtimeConfig.browser.js
var import_sha1_browser = __toESM(require_build6());
var import_sha256_browser = __toESM(require_build8());

// node_modules/@aws-sdk/eventstream-codec/dist-es/EventStreamCodec.js
var import_crc323 = __toESM(require_build2());

// node_modules/@aws-sdk/eventstream-codec/dist-es/Int64.js
var Int64 = class {
  constructor(bytes) {
    this.bytes = bytes;
    if (bytes.byteLength !== 8) {
      throw new Error("Int64 buffers must be exactly 8 bytes");
    }
  }
  static fromNumber(number) {
    if (number > 9223372036854776e3 || number < -9223372036854776e3) {
      throw new Error(`${number} is too large (or, if negative, too small) to represent as an Int64`);
    }
    const bytes = new Uint8Array(8);
    for (let i3 = 7, remaining = Math.abs(Math.round(number)); i3 > -1 && remaining > 0; i3--, remaining /= 256) {
      bytes[i3] = remaining;
    }
    if (number < 0) {
      negate(bytes);
    }
    return new Int64(bytes);
  }
  valueOf() {
    const bytes = this.bytes.slice(0);
    const negative = bytes[0] & 128;
    if (negative) {
      negate(bytes);
    }
    return parseInt(toHex(bytes), 16) * (negative ? -1 : 1);
  }
  toString() {
    return String(this.valueOf());
  }
};
function negate(bytes) {
  for (let i3 = 0; i3 < 8; i3++) {
    bytes[i3] ^= 255;
  }
  for (let i3 = 7; i3 > -1; i3--) {
    bytes[i3]++;
    if (bytes[i3] !== 0)
      break;
  }
}

// node_modules/@aws-sdk/eventstream-codec/dist-es/HeaderMarshaller.js
var HeaderMarshaller = class {
  constructor(toUtf82, fromUtf82) {
    this.toUtf8 = toUtf82;
    this.fromUtf8 = fromUtf82;
  }
  format(headers) {
    const chunks = [];
    for (const headerName of Object.keys(headers)) {
      const bytes = this.fromUtf8(headerName);
      chunks.push(Uint8Array.from([bytes.byteLength]), bytes, this.formatHeaderValue(headers[headerName]));
    }
    const out = new Uint8Array(chunks.reduce((carry, bytes) => carry + bytes.byteLength, 0));
    let position = 0;
    for (const chunk of chunks) {
      out.set(chunk, position);
      position += chunk.byteLength;
    }
    return out;
  }
  formatHeaderValue(header) {
    switch (header.type) {
      case "boolean":
        return Uint8Array.from([header.value ? 0 : 1]);
      case "byte":
        return Uint8Array.from([2, header.value]);
      case "short":
        const shortView = new DataView(new ArrayBuffer(3));
        shortView.setUint8(0, 3);
        shortView.setInt16(1, header.value, false);
        return new Uint8Array(shortView.buffer);
      case "integer":
        const intView = new DataView(new ArrayBuffer(5));
        intView.setUint8(0, 4);
        intView.setInt32(1, header.value, false);
        return new Uint8Array(intView.buffer);
      case "long":
        const longBytes = new Uint8Array(9);
        longBytes[0] = 5;
        longBytes.set(header.value.bytes, 1);
        return longBytes;
      case "binary":
        const binView = new DataView(new ArrayBuffer(3 + header.value.byteLength));
        binView.setUint8(0, 6);
        binView.setUint16(1, header.value.byteLength, false);
        const binBytes = new Uint8Array(binView.buffer);
        binBytes.set(header.value, 3);
        return binBytes;
      case "string":
        const utf8Bytes = this.fromUtf8(header.value);
        const strView = new DataView(new ArrayBuffer(3 + utf8Bytes.byteLength));
        strView.setUint8(0, 7);
        strView.setUint16(1, utf8Bytes.byteLength, false);
        const strBytes = new Uint8Array(strView.buffer);
        strBytes.set(utf8Bytes, 3);
        return strBytes;
      case "timestamp":
        const tsBytes = new Uint8Array(9);
        tsBytes[0] = 8;
        tsBytes.set(Int64.fromNumber(header.value.valueOf()).bytes, 1);
        return tsBytes;
      case "uuid":
        if (!UUID_PATTERN.test(header.value)) {
          throw new Error(`Invalid UUID received: ${header.value}`);
        }
        const uuidBytes = new Uint8Array(17);
        uuidBytes[0] = 9;
        uuidBytes.set(fromHex(header.value.replace(/\-/g, "")), 1);
        return uuidBytes;
    }
  }
  parse(headers) {
    const out = {};
    let position = 0;
    while (position < headers.byteLength) {
      const nameLength = headers.getUint8(position++);
      const name = this.toUtf8(new Uint8Array(headers.buffer, headers.byteOffset + position, nameLength));
      position += nameLength;
      switch (headers.getUint8(position++)) {
        case 0:
          out[name] = {
            type: BOOLEAN_TAG,
            value: true
          };
          break;
        case 1:
          out[name] = {
            type: BOOLEAN_TAG,
            value: false
          };
          break;
        case 2:
          out[name] = {
            type: BYTE_TAG,
            value: headers.getInt8(position++)
          };
          break;
        case 3:
          out[name] = {
            type: SHORT_TAG,
            value: headers.getInt16(position, false)
          };
          position += 2;
          break;
        case 4:
          out[name] = {
            type: INT_TAG,
            value: headers.getInt32(position, false)
          };
          position += 4;
          break;
        case 5:
          out[name] = {
            type: LONG_TAG,
            value: new Int64(new Uint8Array(headers.buffer, headers.byteOffset + position, 8))
          };
          position += 8;
          break;
        case 6:
          const binaryLength = headers.getUint16(position, false);
          position += 2;
          out[name] = {
            type: BINARY_TAG,
            value: new Uint8Array(headers.buffer, headers.byteOffset + position, binaryLength)
          };
          position += binaryLength;
          break;
        case 7:
          const stringLength = headers.getUint16(position, false);
          position += 2;
          out[name] = {
            type: STRING_TAG,
            value: this.toUtf8(new Uint8Array(headers.buffer, headers.byteOffset + position, stringLength))
          };
          position += stringLength;
          break;
        case 8:
          out[name] = {
            type: TIMESTAMP_TAG,
            value: new Date(new Int64(new Uint8Array(headers.buffer, headers.byteOffset + position, 8)).valueOf())
          };
          position += 8;
          break;
        case 9:
          const uuidBytes = new Uint8Array(headers.buffer, headers.byteOffset + position, 16);
          position += 16;
          out[name] = {
            type: UUID_TAG,
            value: `${toHex(uuidBytes.subarray(0, 4))}-${toHex(uuidBytes.subarray(4, 6))}-${toHex(uuidBytes.subarray(6, 8))}-${toHex(uuidBytes.subarray(8, 10))}-${toHex(uuidBytes.subarray(10))}`
          };
          break;
        default:
          throw new Error(`Unrecognized header type tag`);
      }
    }
    return out;
  }
};
var HEADER_VALUE_TYPE;
(function(HEADER_VALUE_TYPE2) {
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["boolTrue"] = 0] = "boolTrue";
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["boolFalse"] = 1] = "boolFalse";
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["byte"] = 2] = "byte";
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["short"] = 3] = "short";
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["integer"] = 4] = "integer";
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["long"] = 5] = "long";
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["byteArray"] = 6] = "byteArray";
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["string"] = 7] = "string";
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["timestamp"] = 8] = "timestamp";
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["uuid"] = 9] = "uuid";
})(HEADER_VALUE_TYPE || (HEADER_VALUE_TYPE = {}));
var BOOLEAN_TAG = "boolean";
var BYTE_TAG = "byte";
var SHORT_TAG = "short";
var INT_TAG = "integer";
var LONG_TAG = "long";
var BINARY_TAG = "binary";
var STRING_TAG = "string";
var TIMESTAMP_TAG = "timestamp";
var UUID_TAG = "uuid";
var UUID_PATTERN = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;

// node_modules/@aws-sdk/eventstream-codec/dist-es/splitMessage.js
var import_crc322 = __toESM(require_build2());
var PRELUDE_MEMBER_LENGTH = 4;
var PRELUDE_LENGTH = PRELUDE_MEMBER_LENGTH * 2;
var CHECKSUM_LENGTH = 4;
var MINIMUM_MESSAGE_LENGTH = PRELUDE_LENGTH + CHECKSUM_LENGTH * 2;
function splitMessage({ byteLength, byteOffset, buffer }) {
  if (byteLength < MINIMUM_MESSAGE_LENGTH) {
    throw new Error("Provided message too short to accommodate event stream message overhead");
  }
  const view = new DataView(buffer, byteOffset, byteLength);
  const messageLength = view.getUint32(0, false);
  if (byteLength !== messageLength) {
    throw new Error("Reported message length does not match received message length");
  }
  const headerLength = view.getUint32(PRELUDE_MEMBER_LENGTH, false);
  const expectedPreludeChecksum = view.getUint32(PRELUDE_LENGTH, false);
  const expectedMessageChecksum = view.getUint32(byteLength - CHECKSUM_LENGTH, false);
  const checksummer = new import_crc322.Crc32().update(new Uint8Array(buffer, byteOffset, PRELUDE_LENGTH));
  if (expectedPreludeChecksum !== checksummer.digest()) {
    throw new Error(`The prelude checksum specified in the message (${expectedPreludeChecksum}) does not match the calculated CRC32 checksum (${checksummer.digest()})`);
  }
  checksummer.update(new Uint8Array(buffer, byteOffset + PRELUDE_LENGTH, byteLength - (PRELUDE_LENGTH + CHECKSUM_LENGTH)));
  if (expectedMessageChecksum !== checksummer.digest()) {
    throw new Error(`The message checksum (${checksummer.digest()}) did not match the expected value of ${expectedMessageChecksum}`);
  }
  return {
    headers: new DataView(buffer, byteOffset + PRELUDE_LENGTH + CHECKSUM_LENGTH, headerLength),
    body: new Uint8Array(buffer, byteOffset + PRELUDE_LENGTH + CHECKSUM_LENGTH + headerLength, messageLength - headerLength - (PRELUDE_LENGTH + CHECKSUM_LENGTH + CHECKSUM_LENGTH))
  };
}

// node_modules/@aws-sdk/eventstream-codec/dist-es/EventStreamCodec.js
var EventStreamCodec = class {
  constructor(toUtf82, fromUtf82) {
    this.headerMarshaller = new HeaderMarshaller(toUtf82, fromUtf82);
  }
  encode({ headers: rawHeaders, body }) {
    const headers = this.headerMarshaller.format(rawHeaders);
    const length = headers.byteLength + body.byteLength + 16;
    const out = new Uint8Array(length);
    const view = new DataView(out.buffer, out.byteOffset, out.byteLength);
    const checksum = new import_crc323.Crc32();
    view.setUint32(0, length, false);
    view.setUint32(4, headers.byteLength, false);
    view.setUint32(8, checksum.update(out.subarray(0, 8)).digest(), false);
    out.set(headers, 12);
    out.set(body, headers.byteLength + 12);
    view.setUint32(length - 4, checksum.update(out.subarray(8, length - 4)).digest(), false);
    return out;
  }
  decode(message) {
    const { headers, body } = splitMessage(message);
    return { headers: this.headerMarshaller.parse(headers), body };
  }
  formatHeaders(rawHeaders) {
    return this.headerMarshaller.format(rawHeaders);
  }
};

// node_modules/@aws-sdk/eventstream-serde-universal/dist-es/getChunkedStream.js
function getChunkedStream(source) {
  let currentMessageTotalLength = 0;
  let currentMessagePendingLength = 0;
  let currentMessage = null;
  let messageLengthBuffer = null;
  const allocateMessage = (size) => {
    if (typeof size !== "number") {
      throw new Error("Attempted to allocate an event message where size was not a number: " + size);
    }
    currentMessageTotalLength = size;
    currentMessagePendingLength = 4;
    currentMessage = new Uint8Array(size);
    const currentMessageView = new DataView(currentMessage.buffer);
    currentMessageView.setUint32(0, size, false);
  };
  const iterator = async function* () {
    const sourceIterator = source[Symbol.asyncIterator]();
    while (true) {
      const { value, done } = await sourceIterator.next();
      if (done) {
        if (!currentMessageTotalLength) {
          return;
        } else if (currentMessageTotalLength === currentMessagePendingLength) {
          yield currentMessage;
        } else {
          throw new Error("Truncated event message received.");
        }
        return;
      }
      const chunkLength = value.length;
      let currentOffset = 0;
      while (currentOffset < chunkLength) {
        if (!currentMessage) {
          const bytesRemaining = chunkLength - currentOffset;
          if (!messageLengthBuffer) {
            messageLengthBuffer = new Uint8Array(4);
          }
          const numBytesForTotal = Math.min(4 - currentMessagePendingLength, bytesRemaining);
          messageLengthBuffer.set(value.slice(currentOffset, currentOffset + numBytesForTotal), currentMessagePendingLength);
          currentMessagePendingLength += numBytesForTotal;
          currentOffset += numBytesForTotal;
          if (currentMessagePendingLength < 4) {
            break;
          }
          allocateMessage(new DataView(messageLengthBuffer.buffer).getUint32(0, false));
          messageLengthBuffer = null;
        }
        const numBytesToWrite = Math.min(currentMessageTotalLength - currentMessagePendingLength, chunkLength - currentOffset);
        currentMessage.set(value.slice(currentOffset, currentOffset + numBytesToWrite), currentMessagePendingLength);
        currentMessagePendingLength += numBytesToWrite;
        currentOffset += numBytesToWrite;
        if (currentMessageTotalLength && currentMessageTotalLength === currentMessagePendingLength) {
          yield currentMessage;
          currentMessage = null;
          currentMessageTotalLength = 0;
          currentMessagePendingLength = 0;
        }
      }
    }
  };
  return {
    [Symbol.asyncIterator]: iterator
  };
}

// node_modules/@aws-sdk/eventstream-serde-universal/dist-es/getUnmarshalledStream.js
function getUnmarshalledStream(source, options) {
  return {
    [Symbol.asyncIterator]: async function* () {
      for await (const chunk of source) {
        const message = options.eventStreamCodec.decode(chunk);
        const { value: messageType } = message.headers[":message-type"];
        if (messageType === "error") {
          const unmodeledError = new Error(message.headers[":error-message"].value || "UnknownError");
          unmodeledError.name = message.headers[":error-code"].value;
          throw unmodeledError;
        } else if (messageType === "exception") {
          const code = message.headers[":exception-type"].value;
          const exception = { [code]: message };
          const deserializedException = await options.deserializer(exception);
          if (deserializedException.$unknown) {
            const error = new Error(options.toUtf8(message.body));
            error.name = code;
            throw error;
          }
          throw deserializedException[code];
        } else if (messageType === "event") {
          const event = {
            [message.headers[":event-type"].value]: message
          };
          const deserialized = await options.deserializer(event);
          if (deserialized.$unknown)
            continue;
          yield deserialized;
        } else {
          throw Error(`Unrecognizable event type: ${message.headers[":event-type"].value}`);
        }
      }
    }
  };
}

// node_modules/@aws-sdk/eventstream-serde-universal/dist-es/EventStreamMarshaller.js
var EventStreamMarshaller = class {
  constructor({ utf8Encoder, utf8Decoder }) {
    this.eventStreamCodec = new EventStreamCodec(utf8Encoder, utf8Decoder);
    this.utfEncoder = utf8Encoder;
  }
  deserialize(body, deserializer) {
    const chunkedStream = getChunkedStream(body);
    const unmarshalledStream = getUnmarshalledStream(chunkedStream, {
      eventStreamCodec: this.eventStreamCodec,
      deserializer,
      toUtf8: this.utfEncoder
    });
    return unmarshalledStream;
  }
  serialize(input, serializer) {
    const self2 = this;
    const serializedIterator = async function* () {
      for await (const chunk of input) {
        const payloadBuf = self2.eventStreamCodec.encode(serializer(chunk));
        yield payloadBuf;
      }
      yield new Uint8Array(0);
    };
    return {
      [Symbol.asyncIterator]: serializedIterator
    };
  }
};

// node_modules/@aws-sdk/eventstream-serde-browser/dist-es/utils.js
var readableStreamtoIterable = (readableStream) => ({
  [Symbol.asyncIterator]: async function* () {
    const reader = readableStream.getReader();
    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done)
          return;
        yield value;
      }
    } finally {
      reader.releaseLock();
    }
  }
});
var iterableToReadableStream = (asyncIterable) => {
  const iterator = asyncIterable[Symbol.asyncIterator]();
  return new ReadableStream({
    async pull(controller) {
      const { done, value } = await iterator.next();
      if (done) {
        return controller.close();
      }
      controller.enqueue(value);
    }
  });
};

// node_modules/@aws-sdk/eventstream-serde-browser/dist-es/EventStreamMarshaller.js
var EventStreamMarshaller2 = class {
  constructor({ utf8Encoder, utf8Decoder }) {
    this.universalMarshaller = new EventStreamMarshaller({
      utf8Decoder,
      utf8Encoder
    });
  }
  deserialize(body, deserializer) {
    const bodyIterable = isReadableStream(body) ? readableStreamtoIterable(body) : body;
    return this.universalMarshaller.deserialize(bodyIterable, deserializer);
  }
  serialize(input, serializer) {
    const serialziedIterable = this.universalMarshaller.serialize(input, serializer);
    return typeof ReadableStream === "function" ? iterableToReadableStream(serialziedIterable) : serialziedIterable;
  }
};
var isReadableStream = (body) => typeof ReadableStream === "function" && body instanceof ReadableStream;

// node_modules/@aws-sdk/eventstream-serde-browser/dist-es/provider.js
var eventStreamSerdeProvider = (options) => new EventStreamMarshaller2(options);

// node_modules/@aws-sdk/fetch-http-handler/dist-es/request-timeout.js
function requestTimeout2(timeoutInMs = 0) {
  return new Promise((resolve, reject) => {
    if (timeoutInMs) {
      setTimeout(() => {
        const timeoutError = new Error(`Request did not complete within ${timeoutInMs} ms`);
        timeoutError.name = "TimeoutError";
        reject(timeoutError);
      }, timeoutInMs);
    }
  });
}

// node_modules/@aws-sdk/fetch-http-handler/dist-es/fetch-http-handler.js
var FetchHttpHandler2 = class {
  constructor(options) {
    if (typeof options === "function") {
      this.configProvider = options().then((opts) => opts || {});
    } else {
      this.config = options != null ? options : {};
      this.configProvider = Promise.resolve(this.config);
    }
  }
  destroy() {
  }
  async handle(request, { abortSignal } = {}) {
    if (!this.config) {
      this.config = await this.configProvider;
    }
    const requestTimeoutInMs = this.config.requestTimeout;
    if (abortSignal == null ? void 0 : abortSignal.aborted) {
      const abortError = new Error("Request aborted");
      abortError.name = "AbortError";
      return Promise.reject(abortError);
    }
    let path2 = request.path;
    if (request.query) {
      const queryString = buildQueryString(request.query);
      if (queryString) {
        path2 += `?${queryString}`;
      }
    }
    const { port, method } = request;
    const url = `${request.protocol}//${request.hostname}${port ? `:${port}` : ""}${path2}`;
    const body = method === "GET" || method === "HEAD" ? void 0 : request.body;
    const requestOptions = {
      body,
      headers: new Headers(request.headers),
      method
    };
    if (typeof AbortController !== "undefined") {
      requestOptions["signal"] = abortSignal;
    }
    const fetchRequest = new Request(url, requestOptions);
    const raceOfPromises = [
      fetch(fetchRequest).then((response) => {
        const fetchHeaders = response.headers;
        const transformedHeaders = {};
        for (const pair of fetchHeaders.entries()) {
          transformedHeaders[pair[0]] = pair[1];
        }
        const hasReadableStream = response.body !== void 0;
        if (!hasReadableStream) {
          return response.blob().then((body2) => ({
            response: new HttpResponse({
              headers: transformedHeaders,
              statusCode: response.status,
              body: body2
            })
          }));
        }
        return {
          response: new HttpResponse({
            headers: transformedHeaders,
            statusCode: response.status,
            body: response.body
          })
        };
      }),
      requestTimeout2(requestTimeoutInMs)
    ];
    if (abortSignal) {
      raceOfPromises.push(new Promise((resolve, reject) => {
        abortSignal.onabort = () => {
          const abortError = new Error("Request aborted");
          abortError.name = "AbortError";
          reject(abortError);
        };
      }));
    }
    return Promise.race(raceOfPromises);
  }
};

// node_modules/@aws-sdk/util-base64/dist-es/constants.browser.js
var alphabetByEncoding2 = {};
var alphabetByValue2 = new Array(64);
for (let i3 = 0, start = "A".charCodeAt(0), limit = "Z".charCodeAt(0); i3 + start <= limit; i3++) {
  const char = String.fromCharCode(i3 + start);
  alphabetByEncoding2[char] = i3;
  alphabetByValue2[i3] = char;
}
for (let i3 = 0, start = "a".charCodeAt(0), limit = "z".charCodeAt(0); i3 + start <= limit; i3++) {
  const char = String.fromCharCode(i3 + start);
  const index = i3 + 26;
  alphabetByEncoding2[char] = index;
  alphabetByValue2[index] = char;
}
for (let i3 = 0; i3 < 10; i3++) {
  alphabetByEncoding2[i3.toString(10)] = i3 + 52;
  const char = i3.toString(10);
  const index = i3 + 52;
  alphabetByEncoding2[char] = index;
  alphabetByValue2[index] = char;
}
alphabetByEncoding2["+"] = 62;
alphabetByValue2[62] = "+";
alphabetByEncoding2["/"] = 63;
alphabetByValue2[63] = "/";
var bitsPerLetter2 = 6;
var bitsPerByte2 = 8;
var maxLetterValue2 = 63;

// node_modules/@aws-sdk/util-base64/dist-es/fromBase64.browser.js
var fromBase642 = (input) => {
  let totalByteLength = input.length / 4 * 3;
  if (input.slice(-2) === "==") {
    totalByteLength -= 2;
  } else if (input.slice(-1) === "=") {
    totalByteLength--;
  }
  const out = new ArrayBuffer(totalByteLength);
  const dataView = new DataView(out);
  for (let i3 = 0; i3 < input.length; i3 += 4) {
    let bits = 0;
    let bitLength = 0;
    for (let j2 = i3, limit = i3 + 3; j2 <= limit; j2++) {
      if (input[j2] !== "=") {
        if (!(input[j2] in alphabetByEncoding2)) {
          throw new TypeError(`Invalid character ${input[j2]} in base64 string.`);
        }
        bits |= alphabetByEncoding2[input[j2]] << (limit - j2) * bitsPerLetter2;
        bitLength += bitsPerLetter2;
      } else {
        bits >>= bitsPerLetter2;
      }
    }
    const chunkOffset = i3 / 4 * 3;
    bits >>= bitLength % bitsPerByte2;
    const byteLength = Math.floor(bitLength / bitsPerByte2);
    for (let k2 = 0; k2 < byteLength; k2++) {
      const offset = (byteLength - k2 - 1) * bitsPerByte2;
      dataView.setUint8(chunkOffset + k2, (bits & 255 << offset) >> offset);
    }
  }
  return new Uint8Array(out);
};

// node_modules/@aws-sdk/util-base64/dist-es/toBase64.browser.js
function toBase64(input) {
  let str = "";
  for (let i3 = 0; i3 < input.length; i3 += 3) {
    let bits = 0;
    let bitLength = 0;
    for (let j2 = i3, limit = Math.min(i3 + 3, input.length); j2 < limit; j2++) {
      bits |= input[j2] << (limit - j2 - 1) * bitsPerByte2;
      bitLength += bitsPerByte2;
    }
    const bitClusterCount = Math.ceil(bitLength / bitsPerLetter2);
    bits <<= bitClusterCount * bitsPerLetter2 - bitLength;
    for (let k2 = 1; k2 <= bitClusterCount; k2++) {
      const offset = (bitClusterCount - k2) * bitsPerLetter2;
      str += alphabetByValue2[(bits & maxLetterValue2 << offset) >> offset];
    }
    str += "==".slice(0, 4 - bitClusterCount);
  }
  return str;
}

// node_modules/@aws-sdk/fetch-http-handler/dist-es/stream-collector.js
var streamCollector = (stream) => {
  if (typeof Blob === "function" && stream instanceof Blob) {
    return collectBlob(stream);
  }
  return collectStream(stream);
};
async function collectBlob(blob) {
  const base64 = await readToBase64(blob);
  const arrayBuffer = fromBase642(base64);
  return new Uint8Array(arrayBuffer);
}
async function collectStream(stream) {
  let res = new Uint8Array(0);
  const reader = stream.getReader();
  let isDone = false;
  while (!isDone) {
    const { done, value } = await reader.read();
    if (value) {
      const prior = res;
      res = new Uint8Array(prior.length + value.length);
      res.set(prior);
      res.set(value, prior.length);
    }
    isDone = done;
  }
  return res;
}
function readToBase64(blob) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onloadend = () => {
      var _a;
      if (reader.readyState !== 2) {
        return reject(new Error("Reader aborted too early"));
      }
      const result = (_a = reader.result) != null ? _a : "";
      const commaIndex = result.indexOf(",");
      const dataOffset = commaIndex > -1 ? commaIndex + 1 : result.length;
      resolve(result.substring(dataOffset));
    };
    reader.onabort = () => reject(new Error("Read aborted"));
    reader.onerror = () => reject(reader.error);
    reader.readAsDataURL(blob);
  });
}

// node_modules/@aws-sdk/chunked-blob-reader/dist-es/index.js
function blobReader(blob, onChunk, chunkSize = 1024 * 1024) {
  return new Promise((resolve, reject) => {
    const fileReader = new FileReader();
    fileReader.addEventListener("error", reject);
    fileReader.addEventListener("abort", reject);
    const size = blob.size;
    let totalBytesRead = 0;
    function read() {
      if (totalBytesRead >= size) {
        resolve();
        return;
      }
      fileReader.readAsArrayBuffer(blob.slice(totalBytesRead, Math.min(size, totalBytesRead + chunkSize)));
    }
    fileReader.addEventListener("load", (event) => {
      const result = event.target.result;
      onChunk(new Uint8Array(result));
      totalBytesRead += result.byteLength;
      read();
    });
    read();
  });
}

// node_modules/@aws-sdk/hash-blob-browser/dist-es/index.js
var blobHasher = async function blobHasher2(hashCtor, blob) {
  const hash = new hashCtor();
  await blobReader(blob, (chunk) => {
    hash.update(chunk);
  });
  return hash.digest();
};

// node_modules/@aws-sdk/invalid-dependency/dist-es/invalidProvider.js
var invalidProvider = (message) => () => Promise.reject(message);

// node_modules/@aws-sdk/md5-js/dist-es/constants.js
var BLOCK_SIZE = 64;
var DIGEST_LENGTH = 16;
var INIT = [1732584193, 4023233417, 2562383102, 271733878];

// node_modules/@aws-sdk/md5-js/dist-es/index.js
var Md5 = class {
  constructor() {
    this.reset();
  }
  update(sourceData) {
    if (isEmptyData(sourceData)) {
      return;
    } else if (this.finished) {
      throw new Error("Attempted to update an already finished hash.");
    }
    const data = convertToBuffer(sourceData);
    let position = 0;
    let { byteLength } = data;
    this.bytesHashed += byteLength;
    while (byteLength > 0) {
      this.buffer.setUint8(this.bufferLength++, data[position++]);
      byteLength--;
      if (this.bufferLength === BLOCK_SIZE) {
        this.hashBuffer();
        this.bufferLength = 0;
      }
    }
  }
  async digest() {
    if (!this.finished) {
      const { buffer, bufferLength: undecoratedLength, bytesHashed } = this;
      const bitsHashed = bytesHashed * 8;
      buffer.setUint8(this.bufferLength++, 128);
      if (undecoratedLength % BLOCK_SIZE >= BLOCK_SIZE - 8) {
        for (let i3 = this.bufferLength; i3 < BLOCK_SIZE; i3++) {
          buffer.setUint8(i3, 0);
        }
        this.hashBuffer();
        this.bufferLength = 0;
      }
      for (let i3 = this.bufferLength; i3 < BLOCK_SIZE - 8; i3++) {
        buffer.setUint8(i3, 0);
      }
      buffer.setUint32(BLOCK_SIZE - 8, bitsHashed >>> 0, true);
      buffer.setUint32(BLOCK_SIZE - 4, Math.floor(bitsHashed / 4294967296), true);
      this.hashBuffer();
      this.finished = true;
    }
    const out = new DataView(new ArrayBuffer(DIGEST_LENGTH));
    for (let i3 = 0; i3 < 4; i3++) {
      out.setUint32(i3 * 4, this.state[i3], true);
    }
    return new Uint8Array(out.buffer, out.byteOffset, out.byteLength);
  }
  hashBuffer() {
    const { buffer, state } = this;
    let a3 = state[0], b2 = state[1], c3 = state[2], d2 = state[3];
    a3 = ff(a3, b2, c3, d2, buffer.getUint32(0, true), 7, 3614090360);
    d2 = ff(d2, a3, b2, c3, buffer.getUint32(4, true), 12, 3905402710);
    c3 = ff(c3, d2, a3, b2, buffer.getUint32(8, true), 17, 606105819);
    b2 = ff(b2, c3, d2, a3, buffer.getUint32(12, true), 22, 3250441966);
    a3 = ff(a3, b2, c3, d2, buffer.getUint32(16, true), 7, 4118548399);
    d2 = ff(d2, a3, b2, c3, buffer.getUint32(20, true), 12, 1200080426);
    c3 = ff(c3, d2, a3, b2, buffer.getUint32(24, true), 17, 2821735955);
    b2 = ff(b2, c3, d2, a3, buffer.getUint32(28, true), 22, 4249261313);
    a3 = ff(a3, b2, c3, d2, buffer.getUint32(32, true), 7, 1770035416);
    d2 = ff(d2, a3, b2, c3, buffer.getUint32(36, true), 12, 2336552879);
    c3 = ff(c3, d2, a3, b2, buffer.getUint32(40, true), 17, 4294925233);
    b2 = ff(b2, c3, d2, a3, buffer.getUint32(44, true), 22, 2304563134);
    a3 = ff(a3, b2, c3, d2, buffer.getUint32(48, true), 7, 1804603682);
    d2 = ff(d2, a3, b2, c3, buffer.getUint32(52, true), 12, 4254626195);
    c3 = ff(c3, d2, a3, b2, buffer.getUint32(56, true), 17, 2792965006);
    b2 = ff(b2, c3, d2, a3, buffer.getUint32(60, true), 22, 1236535329);
    a3 = gg(a3, b2, c3, d2, buffer.getUint32(4, true), 5, 4129170786);
    d2 = gg(d2, a3, b2, c3, buffer.getUint32(24, true), 9, 3225465664);
    c3 = gg(c3, d2, a3, b2, buffer.getUint32(44, true), 14, 643717713);
    b2 = gg(b2, c3, d2, a3, buffer.getUint32(0, true), 20, 3921069994);
    a3 = gg(a3, b2, c3, d2, buffer.getUint32(20, true), 5, 3593408605);
    d2 = gg(d2, a3, b2, c3, buffer.getUint32(40, true), 9, 38016083);
    c3 = gg(c3, d2, a3, b2, buffer.getUint32(60, true), 14, 3634488961);
    b2 = gg(b2, c3, d2, a3, buffer.getUint32(16, true), 20, 3889429448);
    a3 = gg(a3, b2, c3, d2, buffer.getUint32(36, true), 5, 568446438);
    d2 = gg(d2, a3, b2, c3, buffer.getUint32(56, true), 9, 3275163606);
    c3 = gg(c3, d2, a3, b2, buffer.getUint32(12, true), 14, 4107603335);
    b2 = gg(b2, c3, d2, a3, buffer.getUint32(32, true), 20, 1163531501);
    a3 = gg(a3, b2, c3, d2, buffer.getUint32(52, true), 5, 2850285829);
    d2 = gg(d2, a3, b2, c3, buffer.getUint32(8, true), 9, 4243563512);
    c3 = gg(c3, d2, a3, b2, buffer.getUint32(28, true), 14, 1735328473);
    b2 = gg(b2, c3, d2, a3, buffer.getUint32(48, true), 20, 2368359562);
    a3 = hh(a3, b2, c3, d2, buffer.getUint32(20, true), 4, 4294588738);
    d2 = hh(d2, a3, b2, c3, buffer.getUint32(32, true), 11, 2272392833);
    c3 = hh(c3, d2, a3, b2, buffer.getUint32(44, true), 16, 1839030562);
    b2 = hh(b2, c3, d2, a3, buffer.getUint32(56, true), 23, 4259657740);
    a3 = hh(a3, b2, c3, d2, buffer.getUint32(4, true), 4, 2763975236);
    d2 = hh(d2, a3, b2, c3, buffer.getUint32(16, true), 11, 1272893353);
    c3 = hh(c3, d2, a3, b2, buffer.getUint32(28, true), 16, 4139469664);
    b2 = hh(b2, c3, d2, a3, buffer.getUint32(40, true), 23, 3200236656);
    a3 = hh(a3, b2, c3, d2, buffer.getUint32(52, true), 4, 681279174);
    d2 = hh(d2, a3, b2, c3, buffer.getUint32(0, true), 11, 3936430074);
    c3 = hh(c3, d2, a3, b2, buffer.getUint32(12, true), 16, 3572445317);
    b2 = hh(b2, c3, d2, a3, buffer.getUint32(24, true), 23, 76029189);
    a3 = hh(a3, b2, c3, d2, buffer.getUint32(36, true), 4, 3654602809);
    d2 = hh(d2, a3, b2, c3, buffer.getUint32(48, true), 11, 3873151461);
    c3 = hh(c3, d2, a3, b2, buffer.getUint32(60, true), 16, 530742520);
    b2 = hh(b2, c3, d2, a3, buffer.getUint32(8, true), 23, 3299628645);
    a3 = ii(a3, b2, c3, d2, buffer.getUint32(0, true), 6, 4096336452);
    d2 = ii(d2, a3, b2, c3, buffer.getUint32(28, true), 10, 1126891415);
    c3 = ii(c3, d2, a3, b2, buffer.getUint32(56, true), 15, 2878612391);
    b2 = ii(b2, c3, d2, a3, buffer.getUint32(20, true), 21, 4237533241);
    a3 = ii(a3, b2, c3, d2, buffer.getUint32(48, true), 6, 1700485571);
    d2 = ii(d2, a3, b2, c3, buffer.getUint32(12, true), 10, 2399980690);
    c3 = ii(c3, d2, a3, b2, buffer.getUint32(40, true), 15, 4293915773);
    b2 = ii(b2, c3, d2, a3, buffer.getUint32(4, true), 21, 2240044497);
    a3 = ii(a3, b2, c3, d2, buffer.getUint32(32, true), 6, 1873313359);
    d2 = ii(d2, a3, b2, c3, buffer.getUint32(60, true), 10, 4264355552);
    c3 = ii(c3, d2, a3, b2, buffer.getUint32(24, true), 15, 2734768916);
    b2 = ii(b2, c3, d2, a3, buffer.getUint32(52, true), 21, 1309151649);
    a3 = ii(a3, b2, c3, d2, buffer.getUint32(16, true), 6, 4149444226);
    d2 = ii(d2, a3, b2, c3, buffer.getUint32(44, true), 10, 3174756917);
    c3 = ii(c3, d2, a3, b2, buffer.getUint32(8, true), 15, 718787259);
    b2 = ii(b2, c3, d2, a3, buffer.getUint32(36, true), 21, 3951481745);
    state[0] = a3 + state[0] & 4294967295;
    state[1] = b2 + state[1] & 4294967295;
    state[2] = c3 + state[2] & 4294967295;
    state[3] = d2 + state[3] & 4294967295;
  }
  reset() {
    this.state = Uint32Array.from(INIT);
    this.buffer = new DataView(new ArrayBuffer(BLOCK_SIZE));
    this.bufferLength = 0;
    this.bytesHashed = 0;
    this.finished = false;
  }
};
function cmn(q2, a3, b2, x2, s3, t3) {
  a3 = (a3 + q2 & 4294967295) + (x2 + t3 & 4294967295) & 4294967295;
  return (a3 << s3 | a3 >>> 32 - s3) + b2 & 4294967295;
}
function ff(a3, b2, c3, d2, x2, s3, t3) {
  return cmn(b2 & c3 | ~b2 & d2, a3, b2, x2, s3, t3);
}
function gg(a3, b2, c3, d2, x2, s3, t3) {
  return cmn(b2 & d2 | c3 & ~d2, a3, b2, x2, s3, t3);
}
function hh(a3, b2, c3, d2, x2, s3, t3) {
  return cmn(b2 ^ c3 ^ d2, a3, b2, x2, s3, t3);
}
function ii(a3, b2, c3, d2, x2, s3, t3) {
  return cmn(c3 ^ (b2 | ~d2), a3, b2, x2, s3, t3);
}
function isEmptyData(data) {
  if (typeof data === "string") {
    return data.length === 0;
  }
  return data.byteLength === 0;
}
function convertToBuffer(data) {
  if (typeof data === "string") {
    return fromUtf8(data);
  }
  if (ArrayBuffer.isView(data)) {
    return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
  }
  return new Uint8Array(data);
}

// node_modules/@aws-sdk/util-body-length-browser/dist-es/calculateBodyLength.js
var calculateBodyLength = (body) => {
  if (typeof body === "string") {
    let len = body.length;
    for (let i3 = len - 1; i3 >= 0; i3--) {
      const code = body.charCodeAt(i3);
      if (code > 127 && code <= 2047)
        len++;
      else if (code > 2047 && code <= 65535)
        len += 2;
      if (code >= 56320 && code <= 57343)
        i3--;
    }
    return len;
  } else if (typeof body.byteLength === "number") {
    return body.byteLength;
  } else if (typeof body.size === "number") {
    return body.size;
  }
  throw new Error(`Body Length computation failed for ${body}`);
};

// node_modules/@aws-sdk/util-stream-browser/dist-es/getAwsChunkedEncodingStream.js
var getAwsChunkedEncodingStream = (readableStream, options) => {
  const { base64Encoder, bodyLengthChecker, checksumAlgorithmFn, checksumLocationName, streamHasher } = options;
  const checksumRequired = base64Encoder !== void 0 && bodyLengthChecker !== void 0 && checksumAlgorithmFn !== void 0 && checksumLocationName !== void 0 && streamHasher !== void 0;
  const digest = checksumRequired ? streamHasher(checksumAlgorithmFn, readableStream) : void 0;
  const reader = readableStream.getReader();
  return new ReadableStream({
    async pull(controller) {
      const { value, done } = await reader.read();
      if (done) {
        controller.enqueue(`0\r
`);
        if (checksumRequired) {
          const checksum = base64Encoder(await digest);
          controller.enqueue(`${checksumLocationName}:${checksum}\r
`);
          controller.enqueue(`\r
`);
        }
        controller.close();
      } else {
        controller.enqueue(`${(bodyLengthChecker(value) || 0).toString(16)}\r
${value}\r
`);
      }
    }
  });
};

// node_modules/@aws-sdk/util-stream-browser/dist-es/sdk-stream-mixin.js
var ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED = "The stream has already been transformed.";
var sdkStreamMixin = (stream) => {
  var _a, _b;
  if (!isBlobInstance(stream) && !isReadableStreamInstance(stream)) {
    const name = ((_b = (_a = stream == null ? void 0 : stream.__proto__) == null ? void 0 : _a.constructor) == null ? void 0 : _b.name) || stream;
    throw new Error(`Unexpected stream implementation, expect Blob or ReadableStream, got ${name}`);
  }
  let transformed = false;
  const transformToByteArray = async () => {
    if (transformed) {
      throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
    }
    transformed = true;
    return await streamCollector(stream);
  };
  const blobToWebStream = (blob) => {
    if (typeof blob.stream !== "function") {
      throw new Error("Cannot transform payload Blob to web stream. Please make sure the Blob.stream() is polyfilled.\nIf you are using React Native, this API is not yet supported, see: https://react-native.canny.io/feature-requests/p/fetch-streaming-body");
    }
    return blob.stream();
  };
  return Object.assign(stream, {
    transformToByteArray,
    transformToString: async (encoding) => {
      const buf = await transformToByteArray();
      if (encoding === "base64") {
        return toBase64(buf);
      } else if (encoding === "hex") {
        return toHex(buf);
      } else if (encoding === void 0 || encoding === "utf8" || encoding === "utf-8") {
        return toUtf8(buf);
      } else if (typeof TextDecoder === "function") {
        return new TextDecoder(encoding).decode(buf);
      } else {
        throw new Error("TextDecoder is not available, please make sure polyfill is provided.");
      }
    },
    transformToWebStream: () => {
      if (transformed) {
        throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
      }
      transformed = true;
      if (isBlobInstance(stream)) {
        return blobToWebStream(stream);
      } else if (isReadableStreamInstance(stream)) {
        return stream;
      } else {
        throw new Error(`Cannot transform payload to web stream, got ${stream}`);
      }
    }
  });
};
var isBlobInstance = (stream) => typeof Blob === "function" && stream instanceof Blob;
var isReadableStreamInstance = (stream) => typeof ReadableStream === "function" && stream instanceof ReadableStream;

// node_modules/@aws-sdk/util-user-agent-browser/dist-es/index.js
var import_bowser = __toESM(require_es5());
var defaultUserAgent = ({ serviceId, clientVersion }) => async () => {
  var _a, _b, _c, _d, _e, _f, _g;
  const parsedUA = typeof window !== "undefined" && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) ? import_bowser.default.parse(window.navigator.userAgent) : void 0;
  const sections = [
    ["aws-sdk-js", clientVersion],
    [`os/${((_b = parsedUA == null ? void 0 : parsedUA.os) == null ? void 0 : _b.name) || "other"}`, (_c = parsedUA == null ? void 0 : parsedUA.os) == null ? void 0 : _c.version],
    ["lang/js"],
    ["md/browser", `${(_e = (_d = parsedUA == null ? void 0 : parsedUA.browser) == null ? void 0 : _d.name) != null ? _e : "unknown"}_${(_g = (_f = parsedUA == null ? void 0 : parsedUA.browser) == null ? void 0 : _f.version) != null ? _g : "unknown"}`]
  ];
  if (serviceId) {
    sections.push([`api/${serviceId}`, clientVersion]);
  }
  return sections;
};

// node_modules/@aws-sdk/signature-v4-multi-region/dist-es/SignatureV4MultiRegion.js
var SignatureV4MultiRegion = class {
  constructor(options) {
    this.sigv4Signer = new SignatureV4(options);
    this.signerOptions = options;
  }
  async sign(requestToSign, options = {}) {
    if (options.signingRegion === "*") {
      if (this.signerOptions.runtime !== "node")
        throw new Error("This request requires signing with SigV4Asymmetric algorithm. It's only available in Node.js");
      return this.getSigv4aSigner().sign(requestToSign, options);
    }
    return this.sigv4Signer.sign(requestToSign, options);
  }
  async presign(originalRequest, options = {}) {
    if (options.signingRegion === "*") {
      if (this.signerOptions.runtime !== "node")
        throw new Error("This request requires signing with SigV4Asymmetric algorithm. It's only available in Node.js");
      return this.getSigv4aSigner().presign(originalRequest, options);
    }
    return this.sigv4Signer.presign(originalRequest, options);
  }
  getSigv4aSigner() {
    if (!this.sigv4aSigner) {
      let CrtSignerV4;
      try {
        CrtSignerV4 = typeof require === "function" && require_signature_v4_crt().CrtSignerV4;
        if (typeof CrtSignerV4 !== "function")
          throw new Error();
      } catch (e3) {
        e3.message = `${e3.message}
Please check if you have installed "@aws-sdk/signature-v4-crt" package explicitly. 
For more information please go to https://github.com/aws/aws-sdk-js-v3#functionality-requiring-aws-common-runtime-crt`;
        throw e3;
      }
      this.sigv4aSigner = new CrtSignerV4({
        ...this.signerOptions,
        signingAlgorithm: 1
      });
    }
    return this.sigv4aSigner;
  }
};

// node_modules/@aws-sdk/client-s3/dist-es/endpoint/ruleset.js
var bV = "required";
var bW = "type";
var bX = "rules";
var bY = "conditions";
var bZ = "fn";
var ca = "argv";
var cb = "ref";
var cc = "assign";
var cd = "url";
var ce = "properties";
var cf = "authSchemes";
var cg = "disableDoubleEncoding";
var ch = "signingName";
var ci = "signingRegion";
var cj = "headers";
var a = false;
var b = true;
var c = "tree";
var d = "isSet";
var e = "substring";
var f = "hardwareType";
var g = "regionPrefix";
var h = "abbaSuffix";
var i = "outpostId";
var j = "aws.partition";
var k = "stringEquals";
var l = "isValidHostLabel";
var m = "not";
var n = "error";
var o = "parseURL";
var p = "s3-outposts";
var q = "endpoint";
var r = "booleanEquals";
var s = "aws.parseArn";
var t = "s3";
var u = "aws.isVirtualHostableS3Bucket";
var v = "getAttr";
var w = "name";
var x = "Host override cannot be combined with Dualstack, FIPS, or S3 Accelerate";
var y = "https://{Bucket}.s3.{partitionResult#dnsSuffix}";
var z = "bucketArn";
var A = "arnType";
var B = "";
var C = "s3-object-lambda";
var D = "accesspoint";
var E = "accessPointName";
var F = "{url#scheme}://{accessPointName}-{bucketArn#accountId}.{url#authority}{url#path}";
var G = "mrapPartition";
var H = "outpostType";
var I = "arnPrefix";
var J = "{url#scheme}://{url#authority}{url#path}";
var K = "https://s3.{partitionResult#dnsSuffix}";
var L = { [bV]: false, [bW]: "String" };
var M = { [bV]: true, "default": false, [bW]: "Boolean" };
var N = { [bV]: false, [bW]: "Boolean" };
var O = { [bZ]: d, [ca]: [{ [cb]: "Bucket" }] };
var P = { [cb]: "Bucket" };
var Q = { [cb]: f };
var R = { [bY]: [{ [bZ]: m, [ca]: [{ [bZ]: d, [ca]: [{ [cb]: "Endpoint" }] }] }], [n]: "Expected a endpoint to be specified but no endpoint was found", [bW]: n };
var S2 = { [bZ]: m, [ca]: [{ [bZ]: d, [ca]: [{ [cb]: "Endpoint" }] }] };
var T = { [bZ]: d, [ca]: [{ [cb]: "Endpoint" }] };
var U = { [bZ]: o, [ca]: [{ [cb]: "Endpoint" }], [cc]: "url" };
var V = { [cf]: [{ [cg]: true, [w]: "sigv4", [ch]: p, [ci]: "{Region}" }] };
var W = {};
var X = { [cb]: "ForcePathStyle" };
var Y = { [bY]: [{ [bZ]: "uriEncode", [ca]: [P], [cc]: "uri_encoded_bucket" }], [bW]: c, [bX]: [{ [bY]: [{ [bZ]: r, [ca]: [{ [cb]: "UseDualStack" }, true] }, T], [n]: "Cannot set dual-stack in combination with a custom endpoint.", [bW]: n }, { [bW]: c, [bX]: [{ [bY]: [{ [bZ]: j, [ca]: [{ [cb]: "Region" }], [cc]: "partitionResult" }], [bW]: c, [bX]: [{ [bW]: c, [bX]: [{ [bY]: [{ [bZ]: r, [ca]: [{ [cb]: "Accelerate" }, false] }], [bW]: c, [bX]: [{ [bW]: c, [bX]: [{ [bY]: [{ [bZ]: r, [ca]: [{ [cb]: "UseDualStack" }, true] }, S2, { [bZ]: r, [ca]: [{ [cb]: "UseFIPS" }, true] }, { [bZ]: k, [ca]: [{ [cb]: "Region" }, "aws-global"] }], [q]: { [cd]: "https://s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [ce]: { [cf]: [{ [cg]: true, [w]: "sigv4", [ch]: t, [ci]: "us-east-1" }] }, [cj]: {} }, [bW]: q }, { [bY]: [{ [bZ]: r, [ca]: [{ [cb]: "UseDualStack" }, true] }, S2, { [bZ]: r, [ca]: [{ [cb]: "UseFIPS" }, true] }, { [bZ]: k, [ca]: [{ [cb]: "Region" }, "aws-global"] }], [q]: { [cd]: "https://s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [ce]: { [cf]: [{ [cg]: true, [w]: "sigv4", [ch]: t, [ci]: "us-east-1" }] }, [cj]: {} }, [bW]: q }, { [bY]: [{ [bZ]: r, [ca]: [{ [cb]: "UseDualStack" }, true] }, S2, { [bZ]: r, [ca]: [{ [cb]: "UseFIPS" }, true] }, { [bZ]: m, [ca]: [{ [bZ]: k, [ca]: [{ [cb]: "Region" }, "aws-global"] }] }, { [bZ]: r, [ca]: [{ [cb]: "UseGlobalEndpoint" }, true] }], [bW]: c, [bX]: [{ [q]: { [cd]: "https://s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [ce]: { [cf]: [{ [cg]: true, [w]: "sigv4", [ch]: t, [ci]: "{Region}" }] }, [cj]: {} }, [bW]: q }] }, { [bY]: [{ [bZ]: r, [ca]: [{ [cb]: "UseDualStack" }, true] }, S2, { [bZ]: r, [ca]: [{ [cb]: "UseFIPS" }, true] }, { [bZ]: m, [ca]: [{ [bZ]: k, [ca]: [{ [cb]: "Region" }, "aws-global"] }] }, { [bZ]: r, [ca]: [{ [cb]: "UseGlobalEndpoint" }, false] }], [q]: { [cd]: "https://s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [ce]: { [cf]: [{ [cg]: true, [w]: "sigv4", [ch]: t, [ci]: "{Region}" }] }, [cj]: {} }, [bW]: q }, { [bY]: [{ [bZ]: r, [ca]: [{ [cb]: "UseDualStack" }, false] }, T, U, { [bZ]: r, [ca]: [{ [cb]: "UseFIPS" }, true] }, { [bZ]: k, [ca]: [{ [cb]: "Region" }, "aws-global"] }], [q]: { [cd]: "{url#scheme}://{url#authority}{url#normalizedPath}{uri_encoded_bucket}", [ce]: { [cf]: [{ [cg]: true, [w]: "sigv4", [ch]: t, [ci]: "us-east-1" }] }, [cj]: {} }, [bW]: q }, { [bY]: [{ [bZ]: r, [ca]: [{ [cb]: "UseDualStack" }, false] }, T, U, { [bZ]: r, [ca]: [{ [cb]: "UseFIPS" }, true] }, { [bZ]: k, [ca]: [{ [cb]: "Region" }, "aws-global"] }], [q]: { [cd]: "{url#scheme}://{url#authority}{url#normalizedPath}{uri_encoded_bucket}", [ce]: { [cf]: [{ [cg]: true, [w]: "sigv4", [ch]: t, [ci]: "us-east-1" }] }, [cj]: {} }, [bW]: q }, { [bY]: [{ [bZ]: r, [ca]: [{ [cb]: "UseDualStack" }, false] }, T, U, { [bZ]: r, [ca]: [{ [cb]: "UseFIPS" }, true] }, { [bZ]: m, [ca]: [{ [bZ]: k, [ca]: [{ [cb]: "Region" }, "aws-global"] }] }, { [bZ]: r, [ca]: [{ [cb]: "UseGlobalEndpoint" }, true] }], [bW]: c, [bX]: [{ [q]: { [cd]: "{url#scheme}://{url#authority}{url#normalizedPath}{uri_encoded_bucket}", [ce]: { [cf]: [{ [cg]: true, [w]: "sigv4", [ch]: t, [ci]: "{Region}" }] }, [cj]: {} }, [bW]: q }] }, { [bY]: [{ [bZ]: r, [ca]: [{ [cb]: "UseDualStack" }, false] }, T, U, { [bZ]: r, [ca]: [{ [cb]: "UseFIPS" }, true] }, { [bZ]: m, [ca]: [{ [bZ]: k, [ca]: [{ [cb]: "Region" }, "aws-global"] }] }, { [bZ]: r, [ca]: [{ [cb]: "UseGlobalEndpoint" }, false] }], [q]: { [cd]: "{url#scheme}://{url#authority}{url#normalizedPath}{uri_encoded_bucket}", [ce]: { [cf]: [{ [cg]: true, [w]: "sigv4", [ch]: t, [ci]: "{Region}" }] }, [cj]: {} }, [bW]: q }, { [bY]: [{ [bZ]: r, [ca]: [{ [cb]: "UseDualStack" }, false] }, S2, { [bZ]: r, [ca]: [{ [cb]: "UseFIPS" }, true] }, { [bZ]: k, [ca]: [{ [cb]: "Region" }, "aws-global"] }], [q]: { [cd]: "https://s3-fips.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [ce]: { [cf]: [{ [cg]: true, [w]: "sigv4", [ch]: t, [ci]: "us-east-1" }] }, [cj]: {} }, [bW]: q }, { [bY]: [{ [bZ]: r, [ca]: [{ [cb]: "UseDualStack" }, false] }, S2, { [bZ]: r, [ca]: [{ [cb]: "UseFIPS" }, true] }, { [bZ]: k, [ca]: [{ [cb]: "Region" }, "aws-global"] }], [q]: { [cd]: "https://s3-fips.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [ce]: { [cf]: [{ [cg]: true, [w]: "sigv4", [ch]: t, [ci]: "us-east-1" }] }, [cj]: {} }, [bW]: q }, { [bY]: [{ [bZ]: r, [ca]: [{ [cb]: "UseDualStack" }, false] }, S2, { [bZ]: r, [ca]: [{ [cb]: "UseFIPS" }, true] }, { [bZ]: m, [ca]: [{ [bZ]: k, [ca]: [{ [cb]: "Region" }, "aws-global"] }] }, { [bZ]: r, [ca]: [{ [cb]: "UseGlobalEndpoint" }, true] }], [bW]: c, [bX]: [{ [q]: { [cd]: "https://s3-fips.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [ce]: { [cf]: [{ [cg]: true, [w]: "sigv4", [ch]: t, [ci]: "{Region}" }] }, [cj]: {} }, [bW]: q }] }, { [bY]: [{ [bZ]: r, [ca]: [{ [cb]: "UseDualStack" }, false] }, S2, { [bZ]: r, [ca]: [{ [cb]: "UseFIPS" }, true] }, { [bZ]: m, [ca]: [{ [bZ]: k, [ca]: [{ [cb]: "Region" }, "aws-global"] }] }, { [bZ]: r, [ca]: [{ [cb]: "UseGlobalEndpoint" }, false] }], [q]: { [cd]: "https://s3-fips.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [ce]: { [cf]: [{ [cg]: true, [w]: "sigv4", [ch]: t, [ci]: "{Region}" }] }, [cj]: {} }, [bW]: q }, { [bY]: [{ [bZ]: r, [ca]: [{ [cb]: "UseDualStack" }, true] }, S2, { [bZ]: r, [ca]: [{ [cb]: "UseFIPS" }, false] }, { [bZ]: k, [ca]: [{ [cb]: "Region" }, "aws-global"] }], [q]: { [cd]: "https://s3.dualstack.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [ce]: { [cf]: [{ [cg]: true, [w]: "sigv4", [ch]: t, [ci]: "us-east-1" }] }, [cj]: {} }, [bW]: q }, { [bY]: [{ [bZ]: r, [ca]: [{ [cb]: "UseDualStack" }, true] }, S2, { [bZ]: r, [ca]: [{ [cb]: "UseFIPS" }, false] }, { [bZ]: k, [ca]: [{ [cb]: "Region" }, "aws-global"] }], [q]: { [cd]: "https://s3.dualstack.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [ce]: { [cf]: [{ [cg]: true, [w]: "sigv4", [ch]: t, [ci]: "us-east-1" }] }, [cj]: {} }, [bW]: q }, { [bY]: [{ [bZ]: r, [ca]: [{ [cb]: "UseDualStack" }, true] }, S2, { [bZ]: r, [ca]: [{ [cb]: "UseFIPS" }, false] }, { [bZ]: m, [ca]: [{ [bZ]: k, [ca]: [{ [cb]: "Region" }, "aws-global"] }] }, { [bZ]: r, [ca]: [{ [cb]: "UseGlobalEndpoint" }, true] }], [bW]: c, [bX]: [{ [q]: { [cd]: "https://s3.dualstack.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [ce]: { [cf]: [{ [cg]: true, [w]: "sigv4", [ch]: t, [ci]: "{Region}" }] }, [cj]: {} }, [bW]: q }] }, { [bY]: [{ [bZ]: r, [ca]: [{ [cb]: "UseDualStack" }, true] }, S2, { [bZ]: r, [ca]: [{ [cb]: "UseFIPS" }, false] }, { [bZ]: m, [ca]: [{ [bZ]: k, [ca]: [{ [cb]: "Region" }, "aws-global"] }] }, { [bZ]: r, [ca]: [{ [cb]: "UseGlobalEndpoint" }, false] }], [q]: { [cd]: "https://s3.dualstack.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [ce]: { [cf]: [{ [cg]: true, [w]: "sigv4", [ch]: t, [ci]: "{Region}" }] }, [cj]: {} }, [bW]: q }, { [bY]: [{ [bZ]: r, [ca]: [{ [cb]: "UseDualStack" }, false] }, T, U, { [bZ]: r, [ca]: [{ [cb]: "UseFIPS" }, false] }, { [bZ]: k, [ca]: [{ [cb]: "Region" }, "aws-global"] }], [q]: { [cd]: "{url#scheme}://{url#authority}{url#normalizedPath}{uri_encoded_bucket}", [ce]: { [cf]: [{ [cg]: true, [w]: "sigv4", [ch]: t, [ci]: "us-east-1" }] }, [cj]: {} }, [bW]: q }, { [bY]: [{ [bZ]: r, [ca]: [{ [cb]: "UseDualStack" }, false] }, T, U, { [bZ]: r, [ca]: [{ [cb]: "UseFIPS" }, false] }, { [bZ]: k, [ca]: [{ [cb]: "Region" }, "aws-global"] }], [q]: { [cd]: "{url#scheme}://{url#authority}{url#normalizedPath}{uri_encoded_bucket}", [ce]: { [cf]: [{ [cg]: true, [w]: "sigv4", [ch]: t, [ci]: "us-east-1" }] }, [cj]: {} }, [bW]: q }, { [bY]: [{ [bZ]: r, [ca]: [{ [cb]: "UseDualStack" }, false] }, T, U, { [bZ]: r, [ca]: [{ [cb]: "UseFIPS" }, false] }, { [bZ]: m, [ca]: [{ [bZ]: k, [ca]: [{ [cb]: "Region" }, "aws-global"] }] }, { [bZ]: r, [ca]: [{ [cb]: "UseGlobalEndpoint" }, true] }], [bW]: c, [bX]: [{ [bY]: [{ [bZ]: k, [ca]: [{ [cb]: "Region" }, "us-east-1"] }], [q]: { [cd]: "{url#scheme}://{url#authority}{url#normalizedPath}{uri_encoded_bucket}", [ce]: { [cf]: [{ [cg]: true, [w]: "sigv4", [ch]: t, [ci]: "{Region}" }] }, [cj]: {} }, [bW]: q }, { [q]: { [cd]: "{url#scheme}://{url#authority}{url#normalizedPath}{uri_encoded_bucket}", [ce]: { [cf]: [{ [cg]: true, [w]: "sigv4", [ch]: t, [ci]: "{Region}" }] }, [cj]: {} }, [bW]: q }] }, { [bY]: [{ [bZ]: r, [ca]: [{ [cb]: "UseDualStack" }, false] }, T, U, { [bZ]: r, [ca]: [{ [cb]: "UseFIPS" }, false] }, { [bZ]: m, [ca]: [{ [bZ]: k, [ca]: [{ [cb]: "Region" }, "aws-global"] }] }, { [bZ]: r, [ca]: [{ [cb]: "UseGlobalEndpoint" }, false] }], [q]: { [cd]: "{url#scheme}://{url#authority}{url#normalizedPath}{uri_encoded_bucket}", [ce]: { [cf]: [{ [cg]: true, [w]: "sigv4", [ch]: t, [ci]: "{Region}" }] }, [cj]: {} }, [bW]: q }, { [bY]: [{ [bZ]: r, [ca]: [{ [cb]: "UseDualStack" }, false] }, S2, { [bZ]: r, [ca]: [{ [cb]: "UseFIPS" }, false] }, { [bZ]: k, [ca]: [{ [cb]: "Region" }, "aws-global"] }], [q]: { [cd]: "https://s3.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [ce]: { [cf]: [{ [cg]: true, [w]: "sigv4", [ch]: t, [ci]: "us-east-1" }] }, [cj]: {} }, [bW]: q }, { [bY]: [{ [bZ]: r, [ca]: [{ [cb]: "UseDualStack" }, false] }, S2, { [bZ]: r, [ca]: [{ [cb]: "UseFIPS" }, false] }, { [bZ]: k, [ca]: [{ [cb]: "Region" }, "aws-global"] }], [q]: { [cd]: "https://s3.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [ce]: { [cf]: [{ [cg]: true, [w]: "sigv4", [ch]: t, [ci]: "us-east-1" }] }, [cj]: {} }, [bW]: q }, { [bY]: [{ [bZ]: r, [ca]: [{ [cb]: "UseDualStack" }, false] }, S2, { [bZ]: r, [ca]: [{ [cb]: "UseFIPS" }, false] }, { [bZ]: m, [ca]: [{ [bZ]: k, [ca]: [{ [cb]: "Region" }, "aws-global"] }] }, { [bZ]: r, [ca]: [{ [cb]: "UseGlobalEndpoint" }, true] }], [bW]: c, [bX]: [{ [bY]: [{ [bZ]: k, [ca]: [{ [cb]: "Region" }, "us-east-1"] }], [q]: { [cd]: "https://s3.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [ce]: { [cf]: [{ [cg]: true, [w]: "sigv4", [ch]: t, [ci]: "{Region}" }] }, [cj]: {} }, [bW]: q }, { [q]: { [cd]: "https://s3.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [ce]: { [cf]: [{ [cg]: true, [w]: "sigv4", [ch]: t, [ci]: "{Region}" }] }, [cj]: {} }, [bW]: q }] }, { [bY]: [{ [bZ]: r, [ca]: [{ [cb]: "UseDualStack" }, false] }, S2, { [bZ]: r, [ca]: [{ [cb]: "UseFIPS" }, false] }, { [bZ]: m, [ca]: [{ [bZ]: k, [ca]: [{ [cb]: "Region" }, "aws-global"] }] }, { [bZ]: r, [ca]: [{ [cb]: "UseGlobalEndpoint" }, false] }], [q]: { [cd]: "https://s3.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [ce]: { [cf]: [{ [cg]: true, [w]: "sigv4", [ch]: t, [ci]: "{Region}" }] }, [cj]: {} }, [bW]: q }] }] }, { [n]: "Path-style addressing cannot be used with S3 Accelerate", [bW]: n }] }] }, { [n]: "A valid partition could not be determined", [bW]: n }] }] };
var Z = { [bZ]: r, [ca]: [{ [cb]: "UseDualStack" }, true] };
var aa = { [bZ]: r, [ca]: [{ [cb]: "Accelerate" }, false] };
var ab = { [bZ]: r, [ca]: [{ [cb]: "UseFIPS" }, true] };
var ac = { [bZ]: m, [ca]: [{ [bZ]: k, [ca]: [{ [cb]: "Region" }, "aws-global"] }] };
var ad = { [bZ]: r, [ca]: [{ [cb]: "UseGlobalEndpoint" }, true] };
var ae = { [cf]: [{ [cg]: true, [w]: "sigv4", [ch]: t, [ci]: "{Region}" }] };
var af = { [bZ]: r, [ca]: [{ [cb]: "UseGlobalEndpoint" }, false] };
var ag = { [bZ]: r, [ca]: [{ [cb]: "UseDualStack" }, false] };
var ah = { [bZ]: r, [ca]: [{ [cb]: "UseFIPS" }, false] };
var ai = { [n]: "A valid partition could not be determined", [bW]: n };
var aj = { [bY]: [ab, { [bZ]: k, [ca]: [{ [bZ]: v, [ca]: [{ [cb]: "partitionResult" }, w] }, "aws-cn"] }], [n]: "Partition does not support FIPS", [bW]: n };
var ak = { [bZ]: k, [ca]: [{ [bZ]: v, [ca]: [{ [cb]: "partitionResult" }, w] }, "aws-cn"] };
var al = { [bZ]: r, [ca]: [{ [cb]: "Accelerate" }, true] };
var am = { [bY]: [Z, ab, aa, S2, { [bZ]: k, [ca]: [{ [cb]: "Region" }, "aws-global"] }], [q]: { [cd]: "https://{Bucket}.s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}", [ce]: { [cf]: [{ [cg]: true, [w]: "sigv4", [ch]: t, [ci]: "us-east-1" }] }, [cj]: {} }, [bW]: q };
var an = { [cd]: "https://{Bucket}.s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}", [ce]: ae, [cj]: {} };
var ao = { [bY]: [ag, ab, aa, S2, { [bZ]: k, [ca]: [{ [cb]: "Region" }, "aws-global"] }], [q]: { [cd]: "https://{Bucket}.s3-fips.us-east-1.{partitionResult#dnsSuffix}", [ce]: { [cf]: [{ [cg]: true, [w]: "sigv4", [ch]: t, [ci]: "us-east-1" }] }, [cj]: {} }, [bW]: q };
var ap = { [cd]: "https://{Bucket}.s3-fips.{Region}.{partitionResult#dnsSuffix}", [ce]: ae, [cj]: {} };
var aq = { [bY]: [Z, ah, al, S2, { [bZ]: k, [ca]: [{ [cb]: "Region" }, "aws-global"] }], [q]: { [cd]: "https://{Bucket}.s3-accelerate.dualstack.us-east-1.{partitionResult#dnsSuffix}", [ce]: { [cf]: [{ [cg]: true, [w]: "sigv4", [ch]: t, [ci]: "us-east-1" }] }, [cj]: {} }, [bW]: q };
var ar = { [cd]: "https://{Bucket}.s3-accelerate.dualstack.{partitionResult#dnsSuffix}", [ce]: ae, [cj]: {} };
var as = { [bY]: [Z, ah, aa, S2, { [bZ]: k, [ca]: [{ [cb]: "Region" }, "aws-global"] }], [q]: { [cd]: "https://{Bucket}.s3.dualstack.us-east-1.{partitionResult#dnsSuffix}", [ce]: { [cf]: [{ [cg]: true, [w]: "sigv4", [ch]: t, [ci]: "us-east-1" }] }, [cj]: {} }, [bW]: q };
var at = { [cd]: "https://{Bucket}.s3.dualstack.{Region}.{partitionResult#dnsSuffix}", [ce]: ae, [cj]: {} };
var au = { [bY]: [ag, ah, aa, T, U, { [bZ]: r, [ca]: [{ [bZ]: v, [ca]: [{ [cb]: "url" }, "isIp"] }, true] }, { [bZ]: k, [ca]: [{ [cb]: "Region" }, "aws-global"] }], [q]: { [cd]: "{url#scheme}://{url#authority}{url#normalizedPath}{Bucket}", [ce]: { [cf]: [{ [cg]: true, [w]: "sigv4", [ch]: t, [ci]: "us-east-1" }] }, [cj]: {} }, [bW]: q };
var av = { [bZ]: r, [ca]: [{ [bZ]: v, [ca]: [{ [cb]: "url" }, "isIp"] }, true] };
var aw = { [cb]: "url" };
var ax = { [bY]: [ag, ah, aa, T, U, { [bZ]: r, [ca]: [{ [bZ]: v, [ca]: [aw, "isIp"] }, false] }, { [bZ]: k, [ca]: [{ [cb]: "Region" }, "aws-global"] }], [q]: { [cd]: "{url#scheme}://{Bucket}.{url#authority}{url#path}", [ce]: { [cf]: [{ [cg]: true, [w]: "sigv4", [ch]: t, [ci]: "us-east-1" }] }, [cj]: {} }, [bW]: q };
var ay = { [bZ]: r, [ca]: [{ [bZ]: v, [ca]: [aw, "isIp"] }, false] };
var az = { [cd]: "{url#scheme}://{url#authority}{url#normalizedPath}{Bucket}", [ce]: ae, [cj]: {} };
var aA = { [cd]: "{url#scheme}://{Bucket}.{url#authority}{url#path}", [ce]: ae, [cj]: {} };
var aB = { [q]: aA, [bW]: q };
var aC = { [bY]: [ag, ah, al, S2, { [bZ]: k, [ca]: [{ [cb]: "Region" }, "aws-global"] }], [q]: { [cd]: "https://{Bucket}.s3-accelerate.{partitionResult#dnsSuffix}", [ce]: { [cf]: [{ [cg]: true, [w]: "sigv4", [ch]: t, [ci]: "us-east-1" }] }, [cj]: {} }, [bW]: q };
var aD = { [cd]: "https://{Bucket}.s3-accelerate.{partitionResult#dnsSuffix}", [ce]: ae, [cj]: {} };
var aE = { [bY]: [ag, ah, aa, S2, { [bZ]: k, [ca]: [{ [cb]: "Region" }, "aws-global"] }], [q]: { [cd]: y, [ce]: { [cf]: [{ [cg]: true, [w]: "sigv4", [ch]: t, [ci]: "us-east-1" }] }, [cj]: {} }, [bW]: q };
var aF = { [cd]: "https://{Bucket}.s3.{Region}.{partitionResult#dnsSuffix}", [ce]: ae, [cj]: {} };
var aG = { [n]: "Invalid region: region was not a valid DNS name.", [bW]: n };
var aH = { [cb]: z };
var aI = { [cb]: A };
var aJ = { [bZ]: v, [ca]: [aH, "service"] };
var aK = { [cb]: E };
var aL = { [bY]: [Z], [n]: "S3 Object Lambda does not support Dual-stack", [bW]: n };
var aM = { [bY]: [al], [n]: "S3 Object Lambda does not support S3 Accelerate", [bW]: n };
var aN = { [bY]: [{ [bZ]: d, [ca]: [{ [cb]: "DisableAccessPoints" }] }, { [bZ]: r, [ca]: [{ [cb]: "DisableAccessPoints" }, true] }], [n]: "Access points are not supported for this operation", [bW]: n };
var aO = { [bY]: [{ [bZ]: d, [ca]: [{ [cb]: "UseArnRegion" }] }, { [bZ]: r, [ca]: [{ [cb]: "UseArnRegion" }, false] }, { [bZ]: m, [ca]: [{ [bZ]: k, [ca]: [{ [bZ]: v, [ca]: [aH, "region"] }, "{Region}"] }] }], [n]: "Invalid configuration: region from ARN `{bucketArn#region}` does not match client region `{Region}` and UseArnRegion is `false`", [bW]: n };
var aP = { [bZ]: v, [ca]: [{ [cb]: "bucketPartition" }, w] };
var aQ = { [bZ]: v, [ca]: [aH, "accountId"] };
var aR = { [bY]: [ab, { [bZ]: k, [ca]: [aP, "aws-cn"] }], [n]: "Partition does not support FIPS", [bW]: n };
var aS = { [cf]: [{ [cg]: true, [w]: "sigv4", [ch]: C, [ci]: "{bucketArn#region}" }] };
var aT = { [n]: "Invalid ARN: The access point name may only contain a-z, A-Z, 0-9 and `-`. Found: `{accessPointName}`", [bW]: n };
var aU = { [n]: "Invalid ARN: The account id may only contain a-z, A-Z, 0-9 and `-`. Found: `{bucketArn#accountId}`", [bW]: n };
var aV = { [n]: "Invalid region in ARN: `{bucketArn#region}` (invalid DNS name)", [bW]: n };
var aW = { [n]: "Client was configured for partition `{partitionResult#name}` but ARN (`{Bucket}`) has `{bucketPartition#name}`", [bW]: n };
var aX = { [n]: "Could not load partition for ARN region `{bucketArn#region}`", [bW]: n };
var aY = { [n]: "Invalid ARN: The ARN may only contain a single resource component after `accesspoint`.", [bW]: n };
var aZ = { [n]: "Invalid ARN: bucket ARN is missing a region", [bW]: n };
var ba = { [n]: "Invalid ARN: Expected a resource of the format `accesspoint:<accesspoint name>` but no name was provided", [bW]: n };
var bb = { [cf]: [{ [cg]: true, [w]: "sigv4", [ch]: t, [ci]: "{bucketArn#region}" }] };
var bc = { [cf]: [{ [cg]: true, [w]: "sigv4", [ch]: p, [ci]: "{bucketArn#region}" }] };
var bd = { [cb]: "UseObjectLambdaEndpoint" };
var be = { [cf]: [{ [cg]: true, [w]: "sigv4", [ch]: C, [ci]: "{Region}" }] };
var bf = { [bY]: [ab, Z, T, U, { [bZ]: k, [ca]: [{ [cb]: "Region" }, "aws-global"] }], [q]: { [cd]: J, [ce]: { [cf]: [{ [cg]: true, [w]: "sigv4", [ch]: t, [ci]: "us-east-1" }] }, [cj]: {} }, [bW]: q };
var bg = { [q]: { [cd]: J, [ce]: ae, [cj]: {} }, [bW]: q };
var bh = { [cd]: J, [ce]: ae, [cj]: {} };
var bi = { [bY]: [ab, Z, S2, { [bZ]: k, [ca]: [{ [cb]: "Region" }, "aws-global"] }], [q]: { [cd]: "https://s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}", [ce]: { [cf]: [{ [cg]: true, [w]: "sigv4", [ch]: t, [ci]: "us-east-1" }] }, [cj]: {} }, [bW]: q };
var bj = { [cd]: "https://s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}", [ce]: ae, [cj]: {} };
var bk = { [bY]: [ab, ag, T, U, { [bZ]: k, [ca]: [{ [cb]: "Region" }, "aws-global"] }], [q]: { [cd]: J, [ce]: { [cf]: [{ [cg]: true, [w]: "sigv4", [ch]: t, [ci]: "us-east-1" }] }, [cj]: {} }, [bW]: q };
var bl = { [bY]: [ab, ag, S2, { [bZ]: k, [ca]: [{ [cb]: "Region" }, "aws-global"] }], [q]: { [cd]: "https://s3-fips.us-east-1.{partitionResult#dnsSuffix}", [ce]: { [cf]: [{ [cg]: true, [w]: "sigv4", [ch]: t, [ci]: "us-east-1" }] }, [cj]: {} }, [bW]: q };
var bm = { [cd]: "https://s3-fips.{Region}.{partitionResult#dnsSuffix}", [ce]: ae, [cj]: {} };
var bn = { [bY]: [ah, Z, T, U, { [bZ]: k, [ca]: [{ [cb]: "Region" }, "aws-global"] }], [q]: { [cd]: J, [ce]: { [cf]: [{ [cg]: true, [w]: "sigv4", [ch]: t, [ci]: "us-east-1" }] }, [cj]: {} }, [bW]: q };
var bo = { [bY]: [ah, Z, S2, { [bZ]: k, [ca]: [{ [cb]: "Region" }, "aws-global"] }], [q]: { [cd]: "https://s3.dualstack.us-east-1.{partitionResult#dnsSuffix}", [ce]: { [cf]: [{ [cg]: true, [w]: "sigv4", [ch]: t, [ci]: "us-east-1" }] }, [cj]: {} }, [bW]: q };
var bp = { [cd]: "https://s3.dualstack.{Region}.{partitionResult#dnsSuffix}", [ce]: ae, [cj]: {} };
var bq = { [bY]: [ah, ag, T, U, { [bZ]: k, [ca]: [{ [cb]: "Region" }, "aws-global"] }], [q]: { [cd]: J, [ce]: { [cf]: [{ [cg]: true, [w]: "sigv4", [ch]: t, [ci]: "us-east-1" }] }, [cj]: {} }, [bW]: q };
var br = { [bY]: [ah, ag, S2, { [bZ]: k, [ca]: [{ [cb]: "Region" }, "aws-global"] }], [q]: { [cd]: K, [ce]: { [cf]: [{ [cg]: true, [w]: "sigv4", [ch]: t, [ci]: "us-east-1" }] }, [cj]: {} }, [bW]: q };
var bs = { [cd]: "https://s3.{Region}.{partitionResult#dnsSuffix}", [ce]: ae, [cj]: {} };
var bt = [{ [cb]: "Region" }];
var bu = [P];
var bv = [{ [bZ]: l, [ca]: [{ [cb]: i }, false] }];
var bw = [{ [bZ]: k, [ca]: [{ [cb]: g }, "beta"] }];
var bx = [{ [cb]: "Endpoint" }];
var by = [T, U];
var bz = [O];
var bA = [{ [bZ]: s, [ca]: [P] }];
var bB = [Z, T];
var bC = [{ [bZ]: j, [ca]: bt, [cc]: "partitionResult" }];
var bD = [{ [bZ]: k, [ca]: [{ [cb]: "Region" }, "us-east-1"] }];
var bE = [{ [bZ]: l, [ca]: [{ [cb]: "Region" }, false] }];
var bF = [{ [bZ]: k, [ca]: [aI, D] }];
var bG = [{ [bZ]: v, [ca]: [aH, "resourceId[1]"], [cc]: E }, { [bZ]: m, [ca]: [{ [bZ]: k, [ca]: [aK, B] }] }];
var bH = [aH, "resourceId[1]"];
var bI = [Z];
var bJ = [al];
var bK = [{ [bZ]: m, [ca]: [{ [bZ]: k, [ca]: [{ [bZ]: v, [ca]: [aH, "region"] }, B] }] }];
var bL = [{ [bZ]: m, [ca]: [{ [bZ]: d, [ca]: [{ [bZ]: v, [ca]: [aH, "resourceId[2]"] }] }] }];
var bM = [aH, "resourceId[2]"];
var bN = [{ [bZ]: j, [ca]: [{ [bZ]: v, [ca]: [aH, "region"] }], [cc]: "bucketPartition" }];
var bO = [{ [bZ]: k, [ca]: [aP, { [bZ]: v, [ca]: [{ [cb]: "partitionResult" }, w] }] }];
var bP = [{ [bZ]: l, [ca]: [{ [bZ]: v, [ca]: [aH, "region"] }, true] }];
var bQ = [{ [bZ]: l, [ca]: [aQ, false] }];
var bR = [{ [bZ]: l, [ca]: [aK, false] }];
var bS = [ab];
var bT = [{ [bZ]: l, [ca]: [{ [cb]: "Region" }, true] }];
var bU = [bg];
var _data = { version: "1.0", parameters: { Bucket: L, Region: L, UseFIPS: M, UseDualStack: M, Endpoint: L, ForcePathStyle: N, Accelerate: M, UseGlobalEndpoint: M, UseObjectLambdaEndpoint: N, DisableAccessPoints: N, DisableMultiRegionAccessPoints: M, UseArnRegion: N }, [bX]: [{ [bW]: c, [bX]: [{ [bY]: [{ [bZ]: d, [ca]: bt }], [bW]: c, [bX]: [{ [bW]: c, [bX]: [{ [bY]: [O, { [bZ]: e, [ca]: [P, 49, 50, b], [cc]: f }, { [bZ]: e, [ca]: [P, 8, 12, b], [cc]: g }, { [bZ]: e, [ca]: [P, 0, 7, b], [cc]: h }, { [bZ]: e, [ca]: [P, 32, 49, b], [cc]: i }, { [bZ]: j, [ca]: bt, [cc]: "regionPartition" }, { [bZ]: k, [ca]: [{ [cb]: h }, "--op-s3"] }], [bW]: c, [bX]: [{ [bY]: bv, [bW]: c, [bX]: [{ [bW]: c, [bX]: [{ [bY]: [{ [bZ]: k, [ca]: [Q, "e"] }], [bW]: c, [bX]: [{ [bY]: bw, [bW]: c, [bX]: [R, { [bY]: by, endpoint: { [cd]: "https://{Bucket}.ec2.{url#authority}", [ce]: V, [cj]: W }, [bW]: q }] }, { endpoint: { [cd]: "https://{Bucket}.ec2.s3-outposts.{Region}.{regionPartition#dnsSuffix}", [ce]: V, [cj]: W }, [bW]: q }] }, { [bY]: [{ [bZ]: k, [ca]: [Q, "o"] }], [bW]: c, [bX]: [{ [bY]: bw, [bW]: c, [bX]: [R, { [bY]: by, endpoint: { [cd]: "https://{Bucket}.op-{outpostId}.{url#authority}", [ce]: V, [cj]: W }, [bW]: q }] }, { endpoint: { [cd]: "https://{Bucket}.op-{outpostId}.s3-outposts.{Region}.{regionPartition#dnsSuffix}", [ce]: V, [cj]: W }, [bW]: q }] }, { error: 'Unrecognized hardware type: "Expected hardware type o or e but got {hardwareType}"', [bW]: n }] }] }, { error: "Invalid ARN: The outpost Id must only contain a-z, A-Z, 0-9 and `-`.", [bW]: n }] }, { [bY]: bz, [bW]: c, [bX]: [{ [bY]: [T, { [bZ]: m, [ca]: [{ [bZ]: d, [ca]: [{ [bZ]: o, [ca]: bx }] }] }], error: "Custom endpoint `{Endpoint}` was not a valid URI", [bW]: n }, { [bW]: c, [bX]: [{ [bY]: [{ [bZ]: d, [ca]: [X] }, { [bZ]: r, [ca]: [X, b] }], [bW]: c, [bX]: [{ [bW]: c, [bX]: [{ [bY]: bA, error: "Path-style addressing cannot be used with ARN buckets", [bW]: n }, Y] }] }, { [bY]: [{ [bZ]: u, [ca]: [P, a] }], [bW]: c, [bX]: [{ [bY]: bC, [bW]: c, [bX]: [{ [bW]: c, [bX]: [{ [bY]: bE, [bW]: c, [bX]: [{ [bW]: c, [bX]: [aj, { [bW]: c, [bX]: [{ [bY]: [al, ab], error: "Accelerate cannot be used with FIPS", [bW]: n }, { [bW]: c, [bX]: [{ [bY]: [al, ak], error: "S3 Accelerate cannot be used in this region", [bW]: n }, { [bW]: c, [bX]: [{ [bY]: [T, Z], error: x, [bW]: n }, { [bW]: c, [bX]: [{ [bY]: [T, ab], error: x, [bW]: n }, { [bW]: c, [bX]: [{ [bY]: [T, al], error: x, [bW]: n }, { [bW]: c, [bX]: [am, am, { [bY]: [Z, ab, aa, S2, ac, ad], [bW]: c, [bX]: [{ endpoint: an, [bW]: q }] }, { [bY]: [Z, ab, aa, S2, ac, af], endpoint: an, [bW]: q }, ao, ao, { [bY]: [ag, ab, aa, S2, ac, ad], [bW]: c, [bX]: [{ endpoint: ap, [bW]: q }] }, { [bY]: [ag, ab, aa, S2, ac, af], endpoint: ap, [bW]: q }, aq, aq, { [bY]: [Z, ah, al, S2, ac, ad], [bW]: c, [bX]: [{ endpoint: ar, [bW]: q }] }, { [bY]: [Z, ah, al, S2, ac, af], endpoint: ar, [bW]: q }, as, as, { [bY]: [Z, ah, aa, S2, ac, ad], [bW]: c, [bX]: [{ endpoint: at, [bW]: q }] }, { [bY]: [Z, ah, aa, S2, ac, af], endpoint: at, [bW]: q }, au, ax, au, ax, { [bY]: [ag, ah, aa, T, U, av, ac, ad], [bW]: c, [bX]: [{ [bY]: bD, endpoint: az, [bW]: q }, { endpoint: az, [bW]: q }] }, { [bY]: [ag, ah, aa, T, U, ay, ac, ad], [bW]: c, [bX]: [{ [bY]: bD, endpoint: aA, [bW]: q }, aB] }, { [bY]: [ag, ah, aa, T, U, av, ac, af], endpoint: az, [bW]: q }, { [bY]: [ag, ah, aa, T, U, ay, ac, af], endpoint: aA, [bW]: q }, aC, aC, { [bY]: [ag, ah, al, S2, ac, ad], [bW]: c, [bX]: [{ [bY]: bD, endpoint: aD, [bW]: q }, { endpoint: aD, [bW]: q }] }, { [bY]: [ag, ah, al, S2, ac, af], endpoint: aD, [bW]: q }, aE, aE, { [bY]: [ag, ah, aa, S2, ac, ad], [bW]: c, [bX]: [{ [bY]: bD, endpoint: { [cd]: y, [ce]: ae, [cj]: W }, [bW]: q }, { endpoint: aF, [bW]: q }] }, { [bY]: [ag, ah, aa, S2, ac, af], endpoint: aF, [bW]: q }] }] }] }] }] }] }] }] }, aG] }] }, ai] }, { [bY]: [T, U, { [bZ]: k, [ca]: [{ [bZ]: v, [ca]: [aw, "scheme"] }, "http"] }, { [bZ]: u, [ca]: [P, b] }, ah, ag, aa], [bW]: c, [bX]: [{ [bY]: bC, [bW]: c, [bX]: [{ [bW]: c, [bX]: [{ [bY]: bE, [bW]: c, [bX]: [aB] }, aG] }] }, ai] }, { [bY]: [{ [bZ]: s, [ca]: bu, [cc]: z }], [bW]: c, [bX]: [{ [bY]: [{ [bZ]: v, [ca]: [aH, "resourceId[0]"], [cc]: A }, { [bZ]: m, [ca]: [{ [bZ]: k, [ca]: [aI, B] }] }], [bW]: c, [bX]: [{ [bW]: c, [bX]: [{ [bY]: [{ [bZ]: k, [ca]: [aJ, C] }], [bW]: c, [bX]: [{ [bY]: bF, [bW]: c, [bX]: [{ [bW]: c, [bX]: [{ [bY]: bG, [bW]: c, [bX]: [{ [bW]: c, [bX]: [aL, { [bW]: c, [bX]: [aM, { [bW]: c, [bX]: [{ [bY]: bK, [bW]: c, [bX]: [{ [bW]: c, [bX]: [aN, { [bW]: c, [bX]: [{ [bY]: bL, [bW]: c, [bX]: [{ [bW]: c, [bX]: [aO, { [bW]: c, [bX]: [{ [bY]: bN, [bW]: c, [bX]: [{ [bW]: c, [bX]: [{ [bY]: bC, [bW]: c, [bX]: [{ [bW]: c, [bX]: [{ [bY]: bO, [bW]: c, [bX]: [{ [bW]: c, [bX]: [{ [bY]: bP, [bW]: c, [bX]: [{ [bW]: c, [bX]: [{ [bY]: [{ [bZ]: k, [ca]: [aQ, B] }], error: "Invalid ARN: Missing account id", [bW]: n }, { [bW]: c, [bX]: [{ [bY]: bQ, [bW]: c, [bX]: [{ [bW]: c, [bX]: [{ [bY]: bR, [bW]: c, [bX]: [{ [bW]: c, [bX]: [aR, { [bW]: c, [bX]: [{ [bY]: by, endpoint: { [cd]: F, [ce]: aS, [cj]: W }, [bW]: q }, { [bY]: bS, endpoint: { [cd]: "https://{accessPointName}-{bucketArn#accountId}.s3-object-lambda-fips.{bucketArn#region}.{bucketPartition#dnsSuffix}", [ce]: aS, [cj]: W }, [bW]: q }, { endpoint: { [cd]: "https://{accessPointName}-{bucketArn#accountId}.s3-object-lambda.{bucketArn#region}.{bucketPartition#dnsSuffix}", [ce]: aS, [cj]: W }, [bW]: q }] }] }] }, aT] }] }, aU] }] }] }, aV] }] }, aW] }] }, ai] }] }, aX] }] }] }, aY] }] }] }, aZ] }] }] }] }, ba] }] }, { error: "Invalid ARN: Object Lambda ARNs only support `accesspoint` arn types, but found: `{arnType}`", [bW]: n }] }, { [bY]: bF, [bW]: c, [bX]: [{ [bY]: bG, [bW]: c, [bX]: [{ [bW]: c, [bX]: [{ [bY]: bK, [bW]: c, [bX]: [{ [bY]: bF, [bW]: c, [bX]: [{ [bY]: bK, [bW]: c, [bX]: [{ [bW]: c, [bX]: [aN, { [bW]: c, [bX]: [{ [bY]: bL, [bW]: c, [bX]: [{ [bW]: c, [bX]: [aO, { [bW]: c, [bX]: [{ [bY]: bN, [bW]: c, [bX]: [{ [bW]: c, [bX]: [{ [bY]: bC, [bW]: c, [bX]: [{ [bW]: c, [bX]: [{ [bY]: [{ [bZ]: k, [ca]: [aP, "{partitionResult#name}"] }], [bW]: c, [bX]: [{ [bW]: c, [bX]: [{ [bY]: bP, [bW]: c, [bX]: [{ [bW]: c, [bX]: [{ [bY]: [{ [bZ]: k, [ca]: [aJ, t] }], [bW]: c, [bX]: [{ [bW]: c, [bX]: [{ [bY]: bQ, [bW]: c, [bX]: [{ [bW]: c, [bX]: [{ [bY]: bR, [bW]: c, [bX]: [{ [bW]: c, [bX]: [{ [bY]: bJ, error: "Access Points do not support S3 Accelerate", [bW]: n }, { [bW]: c, [bX]: [aR, { [bW]: c, [bX]: [{ [bY]: bB, error: "DualStack cannot be combined with a Host override (PrivateLink)", [bW]: n }, { [bW]: c, [bX]: [{ [bY]: [ab, Z], endpoint: { [cd]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint-fips.dualstack.{bucketArn#region}.{bucketPartition#dnsSuffix}", [ce]: bb, [cj]: W }, [bW]: q }, { [bY]: [ab, ag], endpoint: { [cd]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint-fips.{bucketArn#region}.{bucketPartition#dnsSuffix}", [ce]: bb, [cj]: W }, [bW]: q }, { [bY]: [ah, Z], endpoint: { [cd]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint.dualstack.{bucketArn#region}.{bucketPartition#dnsSuffix}", [ce]: bb, [cj]: W }, [bW]: q }, { [bY]: [ah, ag, T, U], endpoint: { [cd]: F, [ce]: bb, [cj]: W }, [bW]: q }, { [bY]: [ah, ag], endpoint: { [cd]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint.{bucketArn#region}.{bucketPartition#dnsSuffix}", [ce]: bb, [cj]: W }, [bW]: q }] }] }] }] }] }, aT] }] }, aU] }] }, { error: "Invalid ARN: The ARN was not for the S3 service, found: {bucketArn#service}", [bW]: n }] }] }, aV] }] }, aW] }] }, ai] }] }, aX] }] }] }, aY] }] }] }, aZ] }] }, { [bW]: c, [bX]: [{ [bY]: [{ [bZ]: l, [ca]: [aK, b] }], [bW]: c, [bX]: [{ [bW]: c, [bX]: [{ [bY]: bI, error: "S3 MRAP does not support dual-stack", [bW]: n }, { [bW]: c, [bX]: [{ [bY]: bS, error: "S3 MRAP does not support FIPS", [bW]: n }, { [bW]: c, [bX]: [{ [bY]: bJ, error: "S3 MRAP does not support S3 Accelerate", [bW]: n }, { [bW]: c, [bX]: [{ [bY]: [{ [bZ]: r, [ca]: [{ [cb]: "DisableMultiRegionAccessPoints" }, b] }], error: "Invalid configuration: Multi-Region Access Point ARNs are disabled.", [bW]: n }, { [bW]: c, [bX]: [{ [bY]: [{ [bZ]: j, [ca]: bt, [cc]: G }], [bW]: c, [bX]: [{ [bW]: c, [bX]: [{ [bY]: [{ [bZ]: k, [ca]: [{ [bZ]: v, [ca]: [{ [cb]: G }, w] }, { [bZ]: v, [ca]: [aH, "partition"] }] }], [bW]: c, [bX]: [{ endpoint: { [cd]: "https://{accessPointName}.accesspoint.s3-global.{mrapPartition#dnsSuffix}", [ce]: { [cf]: [{ [cg]: b, name: "sigv4a", [ch]: t, signingRegionSet: ["*"] }] }, [cj]: W }, [bW]: q }] }, { error: "Client was configured for partition `{mrapPartition#name}` but bucket referred to partition `{bucketArn#partition}`", [bW]: n }] }] }, { error: "{Region} was not a valid region", [bW]: n }] }] }] }] }] }] }, { error: "Invalid Access Point Name", [bW]: n }] }] }] }, ba] }, { [bY]: [{ [bZ]: k, [ca]: [aJ, p] }], [bW]: c, [bX]: [{ [bY]: bI, error: "S3 Outposts does not support Dual-stack", [bW]: n }, { [bW]: c, [bX]: [{ [bY]: bS, error: "S3 Outposts does not support FIPS", [bW]: n }, { [bW]: c, [bX]: [{ [bY]: bJ, error: "S3 Outposts does not support S3 Accelerate", [bW]: n }, { [bW]: c, [bX]: [{ [bY]: [{ [bZ]: d, [ca]: [{ [bZ]: v, [ca]: [aH, "resourceId[4]"] }] }], error: "Invalid Arn: Outpost Access Point ARN contains sub resources", [bW]: n }, { [bW]: c, [bX]: [{ [bY]: [{ [bZ]: v, [ca]: bH, [cc]: i }], [bW]: c, [bX]: [{ [bW]: c, [bX]: [{ [bY]: bv, [bW]: c, [bX]: [{ [bW]: c, [bX]: [aO, { [bW]: c, [bX]: [{ [bY]: bN, [bW]: c, [bX]: [{ [bW]: c, [bX]: [{ [bY]: bC, [bW]: c, [bX]: [{ [bW]: c, [bX]: [{ [bY]: bO, [bW]: c, [bX]: [{ [bW]: c, [bX]: [{ [bY]: bP, [bW]: c, [bX]: [{ [bW]: c, [bX]: [{ [bY]: bQ, [bW]: c, [bX]: [{ [bW]: c, [bX]: [{ [bY]: [{ [bZ]: v, [ca]: bM, [cc]: H }], [bW]: c, [bX]: [{ [bW]: c, [bX]: [{ [bY]: [{ [bZ]: v, [ca]: [aH, "resourceId[3]"], [cc]: E }], [bW]: c, [bX]: [{ [bW]: c, [bX]: [{ [bY]: [{ [bZ]: k, [ca]: [{ [cb]: H }, D] }], [bW]: c, [bX]: [{ [bW]: c, [bX]: [{ [bY]: by, endpoint: { [cd]: "https://{accessPointName}-{bucketArn#accountId}.{outpostId}.{url#authority}", [ce]: bc, [cj]: W }, [bW]: q }, { endpoint: { [cd]: "https://{accessPointName}-{bucketArn#accountId}.{outpostId}.s3-outposts.{bucketArn#region}.{bucketPartition#dnsSuffix}", [ce]: bc, [cj]: W }, [bW]: q }] }] }, { error: "Expected an outpost type `accesspoint`, found {outpostType}", [bW]: n }] }] }, { error: "Invalid ARN: expected an access point name", [bW]: n }] }] }, { error: "Invalid ARN: Expected a 4-component resource", [bW]: n }] }] }, aU] }] }, aV] }] }, aW] }] }, ai] }] }, { error: "Could not load partition for ARN region {bucketArn#region}", [bW]: n }] }] }] }, { error: "Invalid ARN: The outpost Id may only contain a-z, A-Z, 0-9 and `-`. Found: `{outpostId}`", [bW]: n }] }] }, { error: "Invalid ARN: The Outpost Id was not set", [bW]: n }] }] }] }] }] }, { error: "Invalid ARN: Unrecognized format: {Bucket} (type: {arnType})", [bW]: n }] }] }, { error: "Invalid ARN: No ARN type specified", [bW]: n }] }, { [bY]: [{ [bZ]: e, [ca]: [P, 0, 4, a], [cc]: I }, { [bZ]: k, [ca]: [{ [cb]: I }, "arn:"] }, { [bZ]: m, [ca]: [{ [bZ]: d, [ca]: bA }] }], error: "Invalid ARN: `{Bucket}` was not a valid ARN", [bW]: n }, Y] }] }, { [bY]: [{ [bZ]: d, [ca]: [bd] }, { [bZ]: r, [ca]: [bd, b] }], [bW]: c, [bX]: [{ [bY]: bC, [bW]: c, [bX]: [{ [bW]: c, [bX]: [{ [bY]: bT, [bW]: c, [bX]: [{ [bW]: c, [bX]: [aL, { [bW]: c, [bX]: [aM, { [bW]: c, [bX]: [aj, { [bW]: c, [bX]: [{ [bY]: by, endpoint: { [cd]: J, [ce]: be, [cj]: W }, [bW]: q }, { [bY]: bS, endpoint: { [cd]: "https://s3-object-lambda-fips.{Region}.{partitionResult#dnsSuffix}", [ce]: be, [cj]: W }, [bW]: q }, { endpoint: { [cd]: "https://s3-object-lambda.{Region}.{partitionResult#dnsSuffix}", [ce]: be, [cj]: W }, [bW]: q }] }] }] }] }] }, aG] }] }, ai] }, { [bY]: [{ [bZ]: m, [ca]: bz }], [bW]: c, [bX]: [{ [bY]: bC, [bW]: c, [bX]: [{ [bW]: c, [bX]: [{ [bY]: bT, [bW]: c, [bX]: [{ [bW]: c, [bX]: [aj, { [bW]: c, [bX]: [bf, bf, { [bY]: [ab, Z, T, U, ac, ad], [bW]: c, [bX]: bU }, { [bY]: [ab, Z, T, U, ac, af], endpoint: bh, [bW]: q }, bi, bi, { [bY]: [ab, Z, S2, ac, ad], [bW]: c, [bX]: [{ endpoint: bj, [bW]: q }] }, { [bY]: [ab, Z, S2, ac, af], endpoint: bj, [bW]: q }, bk, bk, { [bY]: [ab, ag, T, U, ac, ad], [bW]: c, [bX]: bU }, { [bY]: [ab, ag, T, U, ac, af], endpoint: bh, [bW]: q }, bl, bl, { [bY]: [ab, ag, S2, ac, ad], [bW]: c, [bX]: [{ endpoint: bm, [bW]: q }] }, { [bY]: [ab, ag, S2, ac, af], endpoint: bm, [bW]: q }, bn, bn, { [bY]: [ah, Z, T, U, ac, ad], [bW]: c, [bX]: bU }, { [bY]: [ah, Z, T, U, ac, af], endpoint: bh, [bW]: q }, bo, bo, { [bY]: [ah, Z, S2, ac, ad], [bW]: c, [bX]: [{ endpoint: bp, [bW]: q }] }, { [bY]: [ah, Z, S2, ac, af], endpoint: bp, [bW]: q }, bq, bq, { [bY]: [ah, ag, T, U, ac, ad], [bW]: c, [bX]: [{ [bY]: bD, endpoint: bh, [bW]: q }, bg] }, { [bY]: [ah, ag, T, U, ac, af], endpoint: bh, [bW]: q }, br, br, { [bY]: [ah, ag, S2, ac, ad], [bW]: c, [bX]: [{ [bY]: bD, endpoint: { [cd]: K, [ce]: ae, [cj]: W }, [bW]: q }, { endpoint: bs, [bW]: q }] }, { [bY]: [ah, ag, S2, ac, af], endpoint: bs, [bW]: q }] }] }] }, aG] }] }, ai] }] }] }, { error: "A region must be set when sending requests to S3.", [bW]: n }] }] };
var ruleSet = _data;

// node_modules/@aws-sdk/client-s3/dist-es/endpoint/endpointResolver.js
var defaultEndpointResolver = (endpointParams, context = {}) => {
  return resolveEndpoint(ruleSet, {
    endpointParams,
    logger: context.logger
  });
};

// node_modules/@aws-sdk/client-s3/dist-es/runtimeConfig.shared.js
var getRuntimeConfig = (config) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
  return {
    apiVersion: "2006-03-01",
    base64Decoder: (_a = config == null ? void 0 : config.base64Decoder) != null ? _a : fromBase642,
    base64Encoder: (_b = config == null ? void 0 : config.base64Encoder) != null ? _b : toBase64,
    disableHostPrefix: (_c = config == null ? void 0 : config.disableHostPrefix) != null ? _c : false,
    endpointProvider: (_d = config == null ? void 0 : config.endpointProvider) != null ? _d : defaultEndpointResolver,
    logger: (_e = config == null ? void 0 : config.logger) != null ? _e : new NoOpLogger(),
    serviceId: (_f = config == null ? void 0 : config.serviceId) != null ? _f : "S3",
    signerConstructor: (_g = config == null ? void 0 : config.signerConstructor) != null ? _g : SignatureV4MultiRegion,
    signingEscapePath: (_h = config == null ? void 0 : config.signingEscapePath) != null ? _h : false,
    urlParser: (_i = config == null ? void 0 : config.urlParser) != null ? _i : parseUrl,
    useArnRegion: (_j = config == null ? void 0 : config.useArnRegion) != null ? _j : false,
    utf8Decoder: (_k = config == null ? void 0 : config.utf8Decoder) != null ? _k : fromUtf8,
    utf8Encoder: (_l = config == null ? void 0 : config.utf8Encoder) != null ? _l : toUtf8
  };
};

// node_modules/@aws-sdk/util-defaults-mode-browser/dist-es/resolveDefaultsModeConfig.js
var import_bowser2 = __toESM(require_es5());

// node_modules/@aws-sdk/util-defaults-mode-browser/dist-es/constants.js
var DEFAULTS_MODE_OPTIONS = ["in-region", "cross-region", "mobile", "standard", "legacy"];

// node_modules/@aws-sdk/util-defaults-mode-browser/dist-es/resolveDefaultsModeConfig.js
var resolveDefaultsModeConfig = ({ defaultsMode } = {}) => memoize(async () => {
  const mode = typeof defaultsMode === "function" ? await defaultsMode() : defaultsMode;
  switch (mode == null ? void 0 : mode.toLowerCase()) {
    case "auto":
      return Promise.resolve(isMobileBrowser() ? "mobile" : "standard");
    case "mobile":
    case "in-region":
    case "cross-region":
    case "standard":
    case "legacy":
      return Promise.resolve(mode == null ? void 0 : mode.toLocaleLowerCase());
    case void 0:
      return Promise.resolve("legacy");
    default:
      throw new Error(`Invalid parameter for "defaultsMode", expect ${DEFAULTS_MODE_OPTIONS.join(", ")}, got ${mode}`);
  }
});
var isMobileBrowser = () => {
  var _a, _b;
  const parsedUA = typeof window !== "undefined" && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) ? import_bowser2.default.parse(window.navigator.userAgent) : void 0;
  const platform = (_b = parsedUA == null ? void 0 : parsedUA.platform) == null ? void 0 : _b.type;
  return platform === "tablet" || platform === "mobile";
};

// node_modules/@aws-sdk/client-s3/dist-es/runtimeConfig.browser.js
var getRuntimeConfig2 = (config) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q;
  const defaultsMode = resolveDefaultsModeConfig(config);
  const defaultConfigProvider = () => defaultsMode().then(loadConfigsForDefaultMode);
  const clientSharedValues = getRuntimeConfig(config);
  return {
    ...clientSharedValues,
    ...config,
    runtime: "browser",
    defaultsMode,
    bodyLengthChecker: (_a = config == null ? void 0 : config.bodyLengthChecker) != null ? _a : calculateBodyLength,
    credentialDefaultProvider: (_b = config == null ? void 0 : config.credentialDefaultProvider) != null ? _b : (_) => () => Promise.reject(new Error("Credential is missing")),
    defaultUserAgentProvider: (_c = config == null ? void 0 : config.defaultUserAgentProvider) != null ? _c : defaultUserAgent({ serviceId: clientSharedValues.serviceId, clientVersion: package_default.version }),
    eventStreamSerdeProvider: (_d = config == null ? void 0 : config.eventStreamSerdeProvider) != null ? _d : eventStreamSerdeProvider,
    getAwsChunkedEncodingStream: (_e = config == null ? void 0 : config.getAwsChunkedEncodingStream) != null ? _e : getAwsChunkedEncodingStream,
    maxAttempts: (_f = config == null ? void 0 : config.maxAttempts) != null ? _f : DEFAULT_MAX_ATTEMPTS,
    md5: (_g = config == null ? void 0 : config.md5) != null ? _g : Md5,
    region: (_h = config == null ? void 0 : config.region) != null ? _h : invalidProvider("Region is missing"),
    requestHandler: (_i = config == null ? void 0 : config.requestHandler) != null ? _i : new FetchHttpHandler2(defaultConfigProvider),
    retryMode: (_j = config == null ? void 0 : config.retryMode) != null ? _j : async () => (await defaultConfigProvider()).retryMode || DEFAULT_RETRY_MODE,
    sdkStreamMixin: (_k = config == null ? void 0 : config.sdkStreamMixin) != null ? _k : sdkStreamMixin,
    sha1: (_l = config == null ? void 0 : config.sha1) != null ? _l : import_sha1_browser.Sha1,
    sha256: (_m = config == null ? void 0 : config.sha256) != null ? _m : import_sha256_browser.Sha256,
    streamCollector: (_n = config == null ? void 0 : config.streamCollector) != null ? _n : streamCollector,
    streamHasher: (_o = config == null ? void 0 : config.streamHasher) != null ? _o : blobHasher,
    useDualstackEndpoint: (_p = config == null ? void 0 : config.useDualstackEndpoint) != null ? _p : () => Promise.resolve(DEFAULT_USE_DUALSTACK_ENDPOINT),
    useFipsEndpoint: (_q = config == null ? void 0 : config.useFipsEndpoint) != null ? _q : () => Promise.resolve(DEFAULT_USE_FIPS_ENDPOINT)
  };
};

// node_modules/@aws-sdk/client-s3/dist-es/S3Client.js
var S3Client = class extends Client {
  constructor(configuration) {
    const _config_0 = getRuntimeConfig2(configuration);
    const _config_1 = resolveClientEndpointParameters(_config_0);
    const _config_2 = resolveRegionConfig(_config_1);
    const _config_3 = resolveEndpointConfig(_config_2);
    const _config_4 = resolveRetryConfig(_config_3);
    const _config_5 = resolveHostHeaderConfig(_config_4);
    const _config_6 = resolveAwsAuthConfig(_config_5);
    const _config_7 = resolveS3Config(_config_6);
    const _config_8 = resolveUserAgentConfig(_config_7);
    const _config_9 = resolveEventStreamSerdeConfig(_config_8);
    super(_config_9);
    this.config = _config_9;
    this.middlewareStack.use(getRetryPlugin(this.config));
    this.middlewareStack.use(getContentLengthPlugin(this.config));
    this.middlewareStack.use(getHostHeaderPlugin(this.config));
    this.middlewareStack.use(getLoggerPlugin(this.config));
    this.middlewareStack.use(getRecursionDetectionPlugin(this.config));
    this.middlewareStack.use(getAwsAuthPlugin(this.config));
    this.middlewareStack.use(getValidateBucketNamePlugin(this.config));
    this.middlewareStack.use(getAddExpectContinuePlugin(this.config));
    this.middlewareStack.use(getUserAgentPlugin(this.config));
  }
  destroy() {
    super.destroy();
  }
};

// node_modules/browser-image-compression/dist/browser-image-compression.mjs
function _mergeNamespaces(e3, t3) {
  return t3.forEach(function(t4) {
    t4 && typeof t4 != "string" && !Array.isArray(t4) && Object.keys(t4).forEach(function(r3) {
      if (r3 !== "default" && !(r3 in e3)) {
        var i3 = Object.getOwnPropertyDescriptor(t4, r3);
        Object.defineProperty(e3, r3, i3.get ? i3 : { enumerable: true, get: function() {
          return t4[r3];
        } });
      }
    });
  }), Object.freeze(e3);
}
function copyExifWithoutOrientation(e3, t3) {
  return new Promise(function(r3, i3) {
    let o3;
    return getApp1Segment(e3).then(function(e4) {
      try {
        return o3 = e4, r3(new Blob([t3.slice(0, 2), o3, t3.slice(2)], { type: "image/jpeg" }));
      } catch (e5) {
        return i3(e5);
      }
    }, i3);
  });
}
var getApp1Segment = (e3) => new Promise((t3, r3) => {
  const i3 = new FileReader();
  i3.addEventListener("load", ({ target: { result: e4 } }) => {
    const i4 = new DataView(e4);
    let o3 = 0;
    if (i4.getUint16(o3) !== 65496)
      return r3("not a valid JPEG");
    for (o3 += 2; ; ) {
      const a3 = i4.getUint16(o3);
      if (a3 === 65498)
        break;
      const s3 = i4.getUint16(o3 + 2);
      if (a3 === 65505 && i4.getUint32(o3 + 4) === 1165519206) {
        const a4 = o3 + 10;
        let f3;
        switch (i4.getUint16(a4)) {
          case 18761:
            f3 = true;
            break;
          case 19789:
            f3 = false;
            break;
          default:
            return r3("TIFF header contains invalid endian");
        }
        if (i4.getUint16(a4 + 2, f3) !== 42)
          return r3("TIFF header contains invalid version");
        const l3 = i4.getUint32(a4 + 4, f3), c3 = a4 + l3 + 2 + 12 * i4.getUint16(a4 + l3, f3);
        for (let e5 = a4 + l3 + 2; e5 < c3; e5 += 12) {
          if (i4.getUint16(e5, f3) == 274) {
            if (i4.getUint16(e5 + 2, f3) !== 3)
              return r3("Orientation data type is invalid");
            if (i4.getUint32(e5 + 4, f3) !== 1)
              return r3("Orientation data count is invalid");
            i4.setUint16(e5 + 8, 1, f3);
            break;
          }
        }
        return t3(e4.slice(o3, o3 + 2 + s3));
      }
      o3 += 2 + s3;
    }
    return t3(new Blob());
  }), i3.readAsArrayBuffer(e3);
});
var e2 = {};
var t2 = { get exports() {
  return e2;
}, set exports(t3) {
  e2 = t3;
} };
!function(e3) {
  var r3, i3, UZIP2 = {};
  t2.exports = UZIP2, UZIP2.parse = function(e4, t3) {
    for (var r4 = UZIP2.bin.readUshort, i4 = UZIP2.bin.readUint, o3 = 0, a3 = {}, s3 = new Uint8Array(e4), f3 = s3.length - 4; i4(s3, f3) != 101010256; )
      f3--;
    o3 = f3;
    o3 += 4;
    var l3 = r4(s3, o3 += 4);
    r4(s3, o3 += 2);
    var c3 = i4(s3, o3 += 2), u2 = i4(s3, o3 += 4);
    o3 += 4, o3 = u2;
    for (var h2 = 0; h2 < l3; h2++) {
      i4(s3, o3), o3 += 4, o3 += 4, o3 += 4, i4(s3, o3 += 4);
      c3 = i4(s3, o3 += 4);
      var d2 = i4(s3, o3 += 4), A2 = r4(s3, o3 += 4), g2 = r4(s3, o3 + 2), p2 = r4(s3, o3 + 4);
      o3 += 6;
      var m2 = i4(s3, o3 += 8);
      o3 += 4, o3 += A2 + g2 + p2, UZIP2._readLocal(s3, m2, a3, c3, d2, t3);
    }
    return a3;
  }, UZIP2._readLocal = function(e4, t3, r4, i4, o3, a3) {
    var s3 = UZIP2.bin.readUshort, f3 = UZIP2.bin.readUint;
    f3(e4, t3), s3(e4, t3 += 4), s3(e4, t3 += 2);
    var l3 = s3(e4, t3 += 2);
    f3(e4, t3 += 2), f3(e4, t3 += 4), t3 += 4;
    var c3 = s3(e4, t3 += 8), u2 = s3(e4, t3 += 2);
    t3 += 2;
    var h2 = UZIP2.bin.readUTF8(e4, t3, c3);
    if (t3 += c3, t3 += u2, a3)
      r4[h2] = { size: o3, csize: i4 };
    else {
      var d2 = new Uint8Array(e4.buffer, t3);
      if (l3 == 0)
        r4[h2] = new Uint8Array(d2.buffer.slice(t3, t3 + i4));
      else {
        if (l3 != 8)
          throw "unknown compression method: " + l3;
        var A2 = new Uint8Array(o3);
        UZIP2.inflateRaw(d2, A2), r4[h2] = A2;
      }
    }
  }, UZIP2.inflateRaw = function(e4, t3) {
    return UZIP2.F.inflate(e4, t3);
  }, UZIP2.inflate = function(e4, t3) {
    return e4[0], e4[1], UZIP2.inflateRaw(new Uint8Array(e4.buffer, e4.byteOffset + 2, e4.length - 6), t3);
  }, UZIP2.deflate = function(e4, t3) {
    t3 == null && (t3 = { level: 6 });
    var r4 = 0, i4 = new Uint8Array(50 + Math.floor(1.1 * e4.length));
    i4[r4] = 120, i4[r4 + 1] = 156, r4 += 2, r4 = UZIP2.F.deflateRaw(e4, i4, r4, t3.level);
    var o3 = UZIP2.adler(e4, 0, e4.length);
    return i4[r4 + 0] = o3 >>> 24 & 255, i4[r4 + 1] = o3 >>> 16 & 255, i4[r4 + 2] = o3 >>> 8 & 255, i4[r4 + 3] = o3 >>> 0 & 255, new Uint8Array(i4.buffer, 0, r4 + 4);
  }, UZIP2.deflateRaw = function(e4, t3) {
    t3 == null && (t3 = { level: 6 });
    var r4 = new Uint8Array(50 + Math.floor(1.1 * e4.length)), i4 = UZIP2.F.deflateRaw(e4, r4, i4, t3.level);
    return new Uint8Array(r4.buffer, 0, i4);
  }, UZIP2.encode = function(e4, t3) {
    t3 == null && (t3 = false);
    var r4 = 0, i4 = UZIP2.bin.writeUint, o3 = UZIP2.bin.writeUshort, a3 = {};
    for (var s3 in e4) {
      var f3 = !UZIP2._noNeed(s3) && !t3, l3 = e4[s3], c3 = UZIP2.crc.crc(l3, 0, l3.length);
      a3[s3] = { cpr: f3, usize: l3.length, crc: c3, file: f3 ? UZIP2.deflateRaw(l3) : l3 };
    }
    for (var s3 in a3)
      r4 += a3[s3].file.length + 30 + 46 + 2 * UZIP2.bin.sizeUTF8(s3);
    r4 += 22;
    var u2 = new Uint8Array(r4), h2 = 0, d2 = [];
    for (var s3 in a3) {
      var A2 = a3[s3];
      d2.push(h2), h2 = UZIP2._writeHeader(u2, h2, s3, A2, 0);
    }
    var g2 = 0, p2 = h2;
    for (var s3 in a3) {
      A2 = a3[s3];
      d2.push(h2), h2 = UZIP2._writeHeader(u2, h2, s3, A2, 1, d2[g2++]);
    }
    var m2 = h2 - p2;
    return i4(u2, h2, 101010256), h2 += 4, o3(u2, h2 += 4, g2), o3(u2, h2 += 2, g2), i4(u2, h2 += 2, m2), i4(u2, h2 += 4, p2), h2 += 4, h2 += 2, u2.buffer;
  }, UZIP2._noNeed = function(e4) {
    var t3 = e4.split(".").pop().toLowerCase();
    return "png,jpg,jpeg,zip".indexOf(t3) != -1;
  }, UZIP2._writeHeader = function(e4, t3, r4, i4, o3, a3) {
    var s3 = UZIP2.bin.writeUint, f3 = UZIP2.bin.writeUshort, l3 = i4.file;
    return s3(e4, t3, o3 == 0 ? 67324752 : 33639248), t3 += 4, o3 == 1 && (t3 += 2), f3(e4, t3, 20), f3(e4, t3 += 2, 0), f3(e4, t3 += 2, i4.cpr ? 8 : 0), s3(e4, t3 += 2, 0), s3(e4, t3 += 4, i4.crc), s3(e4, t3 += 4, l3.length), s3(e4, t3 += 4, i4.usize), f3(e4, t3 += 4, UZIP2.bin.sizeUTF8(r4)), f3(e4, t3 += 2, 0), t3 += 2, o3 == 1 && (t3 += 2, t3 += 2, s3(e4, t3 += 6, a3), t3 += 4), t3 += UZIP2.bin.writeUTF8(e4, t3, r4), o3 == 0 && (e4.set(l3, t3), t3 += l3.length), t3;
  }, UZIP2.crc = { table: function() {
    for (var e4 = new Uint32Array(256), t3 = 0; t3 < 256; t3++) {
      for (var r4 = t3, i4 = 0; i4 < 8; i4++)
        1 & r4 ? r4 = 3988292384 ^ r4 >>> 1 : r4 >>>= 1;
      e4[t3] = r4;
    }
    return e4;
  }(), update: function(e4, t3, r4, i4) {
    for (var o3 = 0; o3 < i4; o3++)
      e4 = UZIP2.crc.table[255 & (e4 ^ t3[r4 + o3])] ^ e4 >>> 8;
    return e4;
  }, crc: function(e4, t3, r4) {
    return 4294967295 ^ UZIP2.crc.update(4294967295, e4, t3, r4);
  } }, UZIP2.adler = function(e4, t3, r4) {
    for (var i4 = 1, o3 = 0, a3 = t3, s3 = t3 + r4; a3 < s3; ) {
      for (var f3 = Math.min(a3 + 5552, s3); a3 < f3; )
        o3 += i4 += e4[a3++];
      i4 %= 65521, o3 %= 65521;
    }
    return o3 << 16 | i4;
  }, UZIP2.bin = { readUshort: function(e4, t3) {
    return e4[t3] | e4[t3 + 1] << 8;
  }, writeUshort: function(e4, t3, r4) {
    e4[t3] = 255 & r4, e4[t3 + 1] = r4 >> 8 & 255;
  }, readUint: function(e4, t3) {
    return 16777216 * e4[t3 + 3] + (e4[t3 + 2] << 16 | e4[t3 + 1] << 8 | e4[t3]);
  }, writeUint: function(e4, t3, r4) {
    e4[t3] = 255 & r4, e4[t3 + 1] = r4 >> 8 & 255, e4[t3 + 2] = r4 >> 16 & 255, e4[t3 + 3] = r4 >> 24 & 255;
  }, readASCII: function(e4, t3, r4) {
    for (var i4 = "", o3 = 0; o3 < r4; o3++)
      i4 += String.fromCharCode(e4[t3 + o3]);
    return i4;
  }, writeASCII: function(e4, t3, r4) {
    for (var i4 = 0; i4 < r4.length; i4++)
      e4[t3 + i4] = r4.charCodeAt(i4);
  }, pad: function(e4) {
    return e4.length < 2 ? "0" + e4 : e4;
  }, readUTF8: function(e4, t3, r4) {
    for (var i4, o3 = "", a3 = 0; a3 < r4; a3++)
      o3 += "%" + UZIP2.bin.pad(e4[t3 + a3].toString(16));
    try {
      i4 = decodeURIComponent(o3);
    } catch (i5) {
      return UZIP2.bin.readASCII(e4, t3, r4);
    }
    return i4;
  }, writeUTF8: function(e4, t3, r4) {
    for (var i4 = r4.length, o3 = 0, a3 = 0; a3 < i4; a3++) {
      var s3 = r4.charCodeAt(a3);
      if ((4294967168 & s3) == 0)
        e4[t3 + o3] = s3, o3++;
      else if ((4294965248 & s3) == 0)
        e4[t3 + o3] = 192 | s3 >> 6, e4[t3 + o3 + 1] = 128 | s3 >> 0 & 63, o3 += 2;
      else if ((4294901760 & s3) == 0)
        e4[t3 + o3] = 224 | s3 >> 12, e4[t3 + o3 + 1] = 128 | s3 >> 6 & 63, e4[t3 + o3 + 2] = 128 | s3 >> 0 & 63, o3 += 3;
      else {
        if ((4292870144 & s3) != 0)
          throw "e";
        e4[t3 + o3] = 240 | s3 >> 18, e4[t3 + o3 + 1] = 128 | s3 >> 12 & 63, e4[t3 + o3 + 2] = 128 | s3 >> 6 & 63, e4[t3 + o3 + 3] = 128 | s3 >> 0 & 63, o3 += 4;
      }
    }
    return o3;
  }, sizeUTF8: function(e4) {
    for (var t3 = e4.length, r4 = 0, i4 = 0; i4 < t3; i4++) {
      var o3 = e4.charCodeAt(i4);
      if ((4294967168 & o3) == 0)
        r4++;
      else if ((4294965248 & o3) == 0)
        r4 += 2;
      else if ((4294901760 & o3) == 0)
        r4 += 3;
      else {
        if ((4292870144 & o3) != 0)
          throw "e";
        r4 += 4;
      }
    }
    return r4;
  } }, UZIP2.F = {}, UZIP2.F.deflateRaw = function(e4, t3, r4, i4) {
    var o3 = [[0, 0, 0, 0, 0], [4, 4, 8, 4, 0], [4, 5, 16, 8, 0], [4, 6, 16, 16, 0], [4, 10, 16, 32, 0], [8, 16, 32, 32, 0], [8, 16, 128, 128, 0], [8, 32, 128, 256, 0], [32, 128, 258, 1024, 1], [32, 258, 258, 4096, 1]][i4], a3 = UZIP2.F.U, s3 = UZIP2.F._goodIndex;
    UZIP2.F._hash;
    var f3 = UZIP2.F._putsE, l3 = 0, c3 = r4 << 3, u2 = 0, h2 = e4.length;
    if (i4 == 0) {
      for (; l3 < h2; ) {
        f3(t3, c3, l3 + (_ = Math.min(65535, h2 - l3)) == h2 ? 1 : 0), c3 = UZIP2.F._copyExact(e4, l3, _, t3, c3 + 8), l3 += _;
      }
      return c3 >>> 3;
    }
    var d2 = a3.lits, A2 = a3.strt, g2 = a3.prev, p2 = 0, m2 = 0, w2 = 0, v2 = 0, b2 = 0, y2 = 0;
    for (h2 > 2 && (A2[y2 = UZIP2.F._hash(e4, 0)] = 0), l3 = 0; l3 < h2; l3++) {
      if (b2 = y2, l3 + 1 < h2 - 2) {
        y2 = UZIP2.F._hash(e4, l3 + 1);
        var E2 = l3 + 1 & 32767;
        g2[E2] = A2[y2], A2[y2] = E2;
      }
      if (u2 <= l3) {
        (p2 > 14e3 || m2 > 26697) && h2 - l3 > 100 && (u2 < l3 && (d2[p2] = l3 - u2, p2 += 2, u2 = l3), c3 = UZIP2.F._writeBlock(l3 == h2 - 1 || u2 == h2 ? 1 : 0, d2, p2, v2, e4, w2, l3 - w2, t3, c3), p2 = m2 = v2 = 0, w2 = l3);
        var F2 = 0;
        l3 < h2 - 2 && (F2 = UZIP2.F._bestMatch(e4, l3, g2, b2, Math.min(o3[2], h2 - l3), o3[3]));
        var _ = F2 >>> 16, B2 = 65535 & F2;
        if (F2 != 0) {
          B2 = 65535 & F2;
          var U2 = s3(_ = F2 >>> 16, a3.of0);
          a3.lhst[257 + U2]++;
          var C2 = s3(B2, a3.df0);
          a3.dhst[C2]++, v2 += a3.exb[U2] + a3.dxb[C2], d2[p2] = _ << 23 | l3 - u2, d2[p2 + 1] = B2 << 16 | U2 << 8 | C2, p2 += 2, u2 = l3 + _;
        } else
          a3.lhst[e4[l3]]++;
        m2++;
      }
    }
    for (w2 == l3 && e4.length != 0 || (u2 < l3 && (d2[p2] = l3 - u2, p2 += 2, u2 = l3), c3 = UZIP2.F._writeBlock(1, d2, p2, v2, e4, w2, l3 - w2, t3, c3), p2 = 0, m2 = 0, p2 = m2 = v2 = 0, w2 = l3); (7 & c3) != 0; )
      c3++;
    return c3 >>> 3;
  }, UZIP2.F._bestMatch = function(e4, t3, r4, i4, o3, a3) {
    var s3 = 32767 & t3, f3 = r4[s3], l3 = s3 - f3 + 32768 & 32767;
    if (f3 == s3 || i4 != UZIP2.F._hash(e4, t3 - l3))
      return 0;
    for (var c3 = 0, u2 = 0, h2 = Math.min(32767, t3); l3 <= h2 && --a3 != 0 && f3 != s3; ) {
      if (c3 == 0 || e4[t3 + c3] == e4[t3 + c3 - l3]) {
        var d2 = UZIP2.F._howLong(e4, t3, l3);
        if (d2 > c3) {
          if (u2 = l3, (c3 = d2) >= o3)
            break;
          l3 + 2 < d2 && (d2 = l3 + 2);
          for (var A2 = 0, g2 = 0; g2 < d2 - 2; g2++) {
            var p2 = t3 - l3 + g2 + 32768 & 32767, m2 = p2 - r4[p2] + 32768 & 32767;
            m2 > A2 && (A2 = m2, f3 = p2);
          }
        }
      }
      l3 += (s3 = f3) - (f3 = r4[s3]) + 32768 & 32767;
    }
    return c3 << 16 | u2;
  }, UZIP2.F._howLong = function(e4, t3, r4) {
    if (e4[t3] != e4[t3 - r4] || e4[t3 + 1] != e4[t3 + 1 - r4] || e4[t3 + 2] != e4[t3 + 2 - r4])
      return 0;
    var i4 = t3, o3 = Math.min(e4.length, t3 + 258);
    for (t3 += 3; t3 < o3 && e4[t3] == e4[t3 - r4]; )
      t3++;
    return t3 - i4;
  }, UZIP2.F._hash = function(e4, t3) {
    return (e4[t3] << 8 | e4[t3 + 1]) + (e4[t3 + 2] << 4) & 65535;
  }, UZIP2.saved = 0, UZIP2.F._writeBlock = function(e4, t3, r4, i4, o3, a3, s3, f3, l3) {
    var c3, u2, h2, d2, A2, g2, p2, m2, w2, v2 = UZIP2.F.U, b2 = UZIP2.F._putsF, y2 = UZIP2.F._putsE;
    v2.lhst[256]++, u2 = (c3 = UZIP2.F.getTrees())[0], h2 = c3[1], d2 = c3[2], A2 = c3[3], g2 = c3[4], p2 = c3[5], m2 = c3[6], w2 = c3[7];
    var E2 = 32 + ((l3 + 3 & 7) == 0 ? 0 : 8 - (l3 + 3 & 7)) + (s3 << 3), F2 = i4 + UZIP2.F.contSize(v2.fltree, v2.lhst) + UZIP2.F.contSize(v2.fdtree, v2.dhst), _ = i4 + UZIP2.F.contSize(v2.ltree, v2.lhst) + UZIP2.F.contSize(v2.dtree, v2.dhst);
    _ += 14 + 3 * p2 + UZIP2.F.contSize(v2.itree, v2.ihst) + (2 * v2.ihst[16] + 3 * v2.ihst[17] + 7 * v2.ihst[18]);
    for (var B2 = 0; B2 < 286; B2++)
      v2.lhst[B2] = 0;
    for (B2 = 0; B2 < 30; B2++)
      v2.dhst[B2] = 0;
    for (B2 = 0; B2 < 19; B2++)
      v2.ihst[B2] = 0;
    var U2 = E2 < F2 && E2 < _ ? 0 : F2 < _ ? 1 : 2;
    if (b2(f3, l3, e4), b2(f3, l3 + 1, U2), l3 += 3, U2 == 0) {
      for (; (7 & l3) != 0; )
        l3++;
      l3 = UZIP2.F._copyExact(o3, a3, s3, f3, l3);
    } else {
      var C2, I2;
      if (U2 == 1 && (C2 = v2.fltree, I2 = v2.fdtree), U2 == 2) {
        UZIP2.F.makeCodes(v2.ltree, u2), UZIP2.F.revCodes(v2.ltree, u2), UZIP2.F.makeCodes(v2.dtree, h2), UZIP2.F.revCodes(v2.dtree, h2), UZIP2.F.makeCodes(v2.itree, d2), UZIP2.F.revCodes(v2.itree, d2), C2 = v2.ltree, I2 = v2.dtree, y2(f3, l3, A2 - 257), y2(f3, l3 += 5, g2 - 1), y2(f3, l3 += 5, p2 - 4), l3 += 4;
        for (var Q2 = 0; Q2 < p2; Q2++)
          y2(f3, l3 + 3 * Q2, v2.itree[1 + (v2.ordr[Q2] << 1)]);
        l3 += 3 * p2, l3 = UZIP2.F._codeTiny(m2, v2.itree, f3, l3), l3 = UZIP2.F._codeTiny(w2, v2.itree, f3, l3);
      }
      for (var M2 = a3, x2 = 0; x2 < r4; x2 += 2) {
        for (var S3 = t3[x2], R2 = S3 >>> 23, T2 = M2 + (8388607 & S3); M2 < T2; )
          l3 = UZIP2.F._writeLit(o3[M2++], C2, f3, l3);
        if (R2 != 0) {
          var O2 = t3[x2 + 1], P2 = O2 >> 16, H2 = O2 >> 8 & 255, L2 = 255 & O2;
          y2(f3, l3 = UZIP2.F._writeLit(257 + H2, C2, f3, l3), R2 - v2.of0[H2]), l3 += v2.exb[H2], b2(f3, l3 = UZIP2.F._writeLit(L2, I2, f3, l3), P2 - v2.df0[L2]), l3 += v2.dxb[L2], M2 += R2;
        }
      }
      l3 = UZIP2.F._writeLit(256, C2, f3, l3);
    }
    return l3;
  }, UZIP2.F._copyExact = function(e4, t3, r4, i4, o3) {
    var a3 = o3 >>> 3;
    return i4[a3] = r4, i4[a3 + 1] = r4 >>> 8, i4[a3 + 2] = 255 - i4[a3], i4[a3 + 3] = 255 - i4[a3 + 1], a3 += 4, i4.set(new Uint8Array(e4.buffer, t3, r4), a3), o3 + (r4 + 4 << 3);
  }, UZIP2.F.getTrees = function() {
    for (var e4 = UZIP2.F.U, t3 = UZIP2.F._hufTree(e4.lhst, e4.ltree, 15), r4 = UZIP2.F._hufTree(e4.dhst, e4.dtree, 15), i4 = [], o3 = UZIP2.F._lenCodes(e4.ltree, i4), a3 = [], s3 = UZIP2.F._lenCodes(e4.dtree, a3), f3 = 0; f3 < i4.length; f3 += 2)
      e4.ihst[i4[f3]]++;
    for (f3 = 0; f3 < a3.length; f3 += 2)
      e4.ihst[a3[f3]]++;
    for (var l3 = UZIP2.F._hufTree(e4.ihst, e4.itree, 7), c3 = 19; c3 > 4 && e4.itree[1 + (e4.ordr[c3 - 1] << 1)] == 0; )
      c3--;
    return [t3, r4, l3, o3, s3, c3, i4, a3];
  }, UZIP2.F.getSecond = function(e4) {
    for (var t3 = [], r4 = 0; r4 < e4.length; r4 += 2)
      t3.push(e4[r4 + 1]);
    return t3;
  }, UZIP2.F.nonZero = function(e4) {
    for (var t3 = "", r4 = 0; r4 < e4.length; r4 += 2)
      e4[r4 + 1] != 0 && (t3 += (r4 >> 1) + ",");
    return t3;
  }, UZIP2.F.contSize = function(e4, t3) {
    for (var r4 = 0, i4 = 0; i4 < t3.length; i4++)
      r4 += t3[i4] * e4[1 + (i4 << 1)];
    return r4;
  }, UZIP2.F._codeTiny = function(e4, t3, r4, i4) {
    for (var o3 = 0; o3 < e4.length; o3 += 2) {
      var a3 = e4[o3], s3 = e4[o3 + 1];
      i4 = UZIP2.F._writeLit(a3, t3, r4, i4);
      var f3 = a3 == 16 ? 2 : a3 == 17 ? 3 : 7;
      a3 > 15 && (UZIP2.F._putsE(r4, i4, s3, f3), i4 += f3);
    }
    return i4;
  }, UZIP2.F._lenCodes = function(e4, t3) {
    for (var r4 = e4.length; r4 != 2 && e4[r4 - 1] == 0; )
      r4 -= 2;
    for (var i4 = 0; i4 < r4; i4 += 2) {
      var o3 = e4[i4 + 1], a3 = i4 + 3 < r4 ? e4[i4 + 3] : -1, s3 = i4 + 5 < r4 ? e4[i4 + 5] : -1, f3 = i4 == 0 ? -1 : e4[i4 - 1];
      if (o3 == 0 && a3 == o3 && s3 == o3) {
        for (var l3 = i4 + 5; l3 + 2 < r4 && e4[l3 + 2] == o3; )
          l3 += 2;
        (c3 = Math.min(l3 + 1 - i4 >>> 1, 138)) < 11 ? t3.push(17, c3 - 3) : t3.push(18, c3 - 11), i4 += 2 * c3 - 2;
      } else if (o3 == f3 && a3 == o3 && s3 == o3) {
        for (l3 = i4 + 5; l3 + 2 < r4 && e4[l3 + 2] == o3; )
          l3 += 2;
        var c3 = Math.min(l3 + 1 - i4 >>> 1, 6);
        t3.push(16, c3 - 3), i4 += 2 * c3 - 2;
      } else
        t3.push(o3, 0);
    }
    return r4 >>> 1;
  }, UZIP2.F._hufTree = function(e4, t3, r4) {
    var i4 = [], o3 = e4.length, a3 = t3.length, s3 = 0;
    for (s3 = 0; s3 < a3; s3 += 2)
      t3[s3] = 0, t3[s3 + 1] = 0;
    for (s3 = 0; s3 < o3; s3++)
      e4[s3] != 0 && i4.push({ lit: s3, f: e4[s3] });
    var f3 = i4.length, l3 = i4.slice(0);
    if (f3 == 0)
      return 0;
    if (f3 == 1) {
      var c3 = i4[0].lit;
      l3 = c3 == 0 ? 1 : 0;
      return t3[1 + (c3 << 1)] = 1, t3[1 + (l3 << 1)] = 1, 1;
    }
    i4.sort(function(e5, t4) {
      return e5.f - t4.f;
    });
    var u2 = i4[0], h2 = i4[1], d2 = 0, A2 = 1, g2 = 2;
    for (i4[0] = { lit: -1, f: u2.f + h2.f, l: u2, r: h2, d: 0 }; A2 != f3 - 1; )
      u2 = d2 != A2 && (g2 == f3 || i4[d2].f < i4[g2].f) ? i4[d2++] : i4[g2++], h2 = d2 != A2 && (g2 == f3 || i4[d2].f < i4[g2].f) ? i4[d2++] : i4[g2++], i4[A2++] = { lit: -1, f: u2.f + h2.f, l: u2, r: h2 };
    var p2 = UZIP2.F.setDepth(i4[A2 - 1], 0);
    for (p2 > r4 && (UZIP2.F.restrictDepth(l3, r4, p2), p2 = r4), s3 = 0; s3 < f3; s3++)
      t3[1 + (l3[s3].lit << 1)] = l3[s3].d;
    return p2;
  }, UZIP2.F.setDepth = function(e4, t3) {
    return e4.lit != -1 ? (e4.d = t3, t3) : Math.max(UZIP2.F.setDepth(e4.l, t3 + 1), UZIP2.F.setDepth(e4.r, t3 + 1));
  }, UZIP2.F.restrictDepth = function(e4, t3, r4) {
    var i4 = 0, o3 = 1 << r4 - t3, a3 = 0;
    for (e4.sort(function(e5, t4) {
      return t4.d == e5.d ? e5.f - t4.f : t4.d - e5.d;
    }), i4 = 0; i4 < e4.length && e4[i4].d > t3; i4++) {
      var s3 = e4[i4].d;
      e4[i4].d = t3, a3 += o3 - (1 << r4 - s3);
    }
    for (a3 >>>= r4 - t3; a3 > 0; ) {
      (s3 = e4[i4].d) < t3 ? (e4[i4].d++, a3 -= 1 << t3 - s3 - 1) : i4++;
    }
    for (; i4 >= 0; i4--)
      e4[i4].d == t3 && a3 < 0 && (e4[i4].d--, a3++);
    a3 != 0 && console.log("debt left");
  }, UZIP2.F._goodIndex = function(e4, t3) {
    var r4 = 0;
    return t3[16 | r4] <= e4 && (r4 |= 16), t3[8 | r4] <= e4 && (r4 |= 8), t3[4 | r4] <= e4 && (r4 |= 4), t3[2 | r4] <= e4 && (r4 |= 2), t3[1 | r4] <= e4 && (r4 |= 1), r4;
  }, UZIP2.F._writeLit = function(e4, t3, r4, i4) {
    return UZIP2.F._putsF(r4, i4, t3[e4 << 1]), i4 + t3[1 + (e4 << 1)];
  }, UZIP2.F.inflate = function(e4, t3) {
    var r4 = Uint8Array;
    if (e4[0] == 3 && e4[1] == 0)
      return t3 || new r4(0);
    var i4 = UZIP2.F, o3 = i4._bitsF, a3 = i4._bitsE, s3 = i4._decodeTiny, f3 = i4.makeCodes, l3 = i4.codes2map, c3 = i4._get17, u2 = i4.U, h2 = t3 == null;
    h2 && (t3 = new r4(e4.length >>> 2 << 3));
    for (var d2, A2, g2 = 0, p2 = 0, m2 = 0, w2 = 0, v2 = 0, b2 = 0, y2 = 0, E2 = 0, F2 = 0; g2 == 0; )
      if (g2 = o3(e4, F2, 1), p2 = o3(e4, F2 + 1, 2), F2 += 3, p2 != 0) {
        if (h2 && (t3 = UZIP2.F._check(t3, E2 + (1 << 17))), p2 == 1 && (d2 = u2.flmap, A2 = u2.fdmap, b2 = 511, y2 = 31), p2 == 2) {
          m2 = a3(e4, F2, 5) + 257, w2 = a3(e4, F2 + 5, 5) + 1, v2 = a3(e4, F2 + 10, 4) + 4, F2 += 14;
          for (var _ = 0; _ < 38; _ += 2)
            u2.itree[_] = 0, u2.itree[_ + 1] = 0;
          var B2 = 1;
          for (_ = 0; _ < v2; _++) {
            var U2 = a3(e4, F2 + 3 * _, 3);
            u2.itree[1 + (u2.ordr[_] << 1)] = U2, U2 > B2 && (B2 = U2);
          }
          F2 += 3 * v2, f3(u2.itree, B2), l3(u2.itree, B2, u2.imap), d2 = u2.lmap, A2 = u2.dmap, F2 = s3(u2.imap, (1 << B2) - 1, m2 + w2, e4, F2, u2.ttree);
          var C2 = i4._copyOut(u2.ttree, 0, m2, u2.ltree);
          b2 = (1 << C2) - 1;
          var I2 = i4._copyOut(u2.ttree, m2, w2, u2.dtree);
          y2 = (1 << I2) - 1, f3(u2.ltree, C2), l3(u2.ltree, C2, d2), f3(u2.dtree, I2), l3(u2.dtree, I2, A2);
        }
        for (; ; ) {
          var Q2 = d2[c3(e4, F2) & b2];
          F2 += 15 & Q2;
          var M2 = Q2 >>> 4;
          if (M2 >>> 8 == 0)
            t3[E2++] = M2;
          else {
            if (M2 == 256)
              break;
            var x2 = E2 + M2 - 254;
            if (M2 > 264) {
              var S3 = u2.ldef[M2 - 257];
              x2 = E2 + (S3 >>> 3) + a3(e4, F2, 7 & S3), F2 += 7 & S3;
            }
            var R2 = A2[c3(e4, F2) & y2];
            F2 += 15 & R2;
            var T2 = R2 >>> 4, O2 = u2.ddef[T2], P2 = (O2 >>> 4) + o3(e4, F2, 15 & O2);
            for (F2 += 15 & O2, h2 && (t3 = UZIP2.F._check(t3, E2 + (1 << 17))); E2 < x2; )
              t3[E2] = t3[E2++ - P2], t3[E2] = t3[E2++ - P2], t3[E2] = t3[E2++ - P2], t3[E2] = t3[E2++ - P2];
            E2 = x2;
          }
        }
      } else {
        (7 & F2) != 0 && (F2 += 8 - (7 & F2));
        var H2 = 4 + (F2 >>> 3), L2 = e4[H2 - 4] | e4[H2 - 3] << 8;
        h2 && (t3 = UZIP2.F._check(t3, E2 + L2)), t3.set(new r4(e4.buffer, e4.byteOffset + H2, L2), E2), F2 = H2 + L2 << 3, E2 += L2;
      }
    return t3.length == E2 ? t3 : t3.slice(0, E2);
  }, UZIP2.F._check = function(e4, t3) {
    var r4 = e4.length;
    if (t3 <= r4)
      return e4;
    var i4 = new Uint8Array(Math.max(r4 << 1, t3));
    return i4.set(e4, 0), i4;
  }, UZIP2.F._decodeTiny = function(e4, t3, r4, i4, o3, a3) {
    for (var s3 = UZIP2.F._bitsE, f3 = UZIP2.F._get17, l3 = 0; l3 < r4; ) {
      var c3 = e4[f3(i4, o3) & t3];
      o3 += 15 & c3;
      var u2 = c3 >>> 4;
      if (u2 <= 15)
        a3[l3] = u2, l3++;
      else {
        var h2 = 0, d2 = 0;
        u2 == 16 ? (d2 = 3 + s3(i4, o3, 2), o3 += 2, h2 = a3[l3 - 1]) : u2 == 17 ? (d2 = 3 + s3(i4, o3, 3), o3 += 3) : u2 == 18 && (d2 = 11 + s3(i4, o3, 7), o3 += 7);
        for (var A2 = l3 + d2; l3 < A2; )
          a3[l3] = h2, l3++;
      }
    }
    return o3;
  }, UZIP2.F._copyOut = function(e4, t3, r4, i4) {
    for (var o3 = 0, a3 = 0, s3 = i4.length >>> 1; a3 < r4; ) {
      var f3 = e4[a3 + t3];
      i4[a3 << 1] = 0, i4[1 + (a3 << 1)] = f3, f3 > o3 && (o3 = f3), a3++;
    }
    for (; a3 < s3; )
      i4[a3 << 1] = 0, i4[1 + (a3 << 1)] = 0, a3++;
    return o3;
  }, UZIP2.F.makeCodes = function(e4, t3) {
    for (var r4, i4, o3, a3, s3 = UZIP2.F.U, f3 = e4.length, l3 = s3.bl_count, c3 = 0; c3 <= t3; c3++)
      l3[c3] = 0;
    for (c3 = 1; c3 < f3; c3 += 2)
      l3[e4[c3]]++;
    var u2 = s3.next_code;
    for (r4 = 0, l3[0] = 0, i4 = 1; i4 <= t3; i4++)
      r4 = r4 + l3[i4 - 1] << 1, u2[i4] = r4;
    for (o3 = 0; o3 < f3; o3 += 2)
      (a3 = e4[o3 + 1]) != 0 && (e4[o3] = u2[a3], u2[a3]++);
  }, UZIP2.F.codes2map = function(e4, t3, r4) {
    for (var i4 = e4.length, o3 = UZIP2.F.U.rev15, a3 = 0; a3 < i4; a3 += 2)
      if (e4[a3 + 1] != 0)
        for (var s3 = a3 >> 1, f3 = e4[a3 + 1], l3 = s3 << 4 | f3, c3 = t3 - f3, u2 = e4[a3] << c3, h2 = u2 + (1 << c3); u2 != h2; ) {
          r4[o3[u2] >>> 15 - t3] = l3, u2++;
        }
  }, UZIP2.F.revCodes = function(e4, t3) {
    for (var r4 = UZIP2.F.U.rev15, i4 = 15 - t3, o3 = 0; o3 < e4.length; o3 += 2) {
      var a3 = e4[o3] << t3 - e4[o3 + 1];
      e4[o3] = r4[a3] >>> i4;
    }
  }, UZIP2.F._putsE = function(e4, t3, r4) {
    r4 <<= 7 & t3;
    var i4 = t3 >>> 3;
    e4[i4] |= r4, e4[i4 + 1] |= r4 >>> 8;
  }, UZIP2.F._putsF = function(e4, t3, r4) {
    r4 <<= 7 & t3;
    var i4 = t3 >>> 3;
    e4[i4] |= r4, e4[i4 + 1] |= r4 >>> 8, e4[i4 + 2] |= r4 >>> 16;
  }, UZIP2.F._bitsE = function(e4, t3, r4) {
    return (e4[t3 >>> 3] | e4[1 + (t3 >>> 3)] << 8) >>> (7 & t3) & (1 << r4) - 1;
  }, UZIP2.F._bitsF = function(e4, t3, r4) {
    return (e4[t3 >>> 3] | e4[1 + (t3 >>> 3)] << 8 | e4[2 + (t3 >>> 3)] << 16) >>> (7 & t3) & (1 << r4) - 1;
  }, UZIP2.F._get17 = function(e4, t3) {
    return (e4[t3 >>> 3] | e4[1 + (t3 >>> 3)] << 8 | e4[2 + (t3 >>> 3)] << 16) >>> (7 & t3);
  }, UZIP2.F._get25 = function(e4, t3) {
    return (e4[t3 >>> 3] | e4[1 + (t3 >>> 3)] << 8 | e4[2 + (t3 >>> 3)] << 16 | e4[3 + (t3 >>> 3)] << 24) >>> (7 & t3);
  }, UZIP2.F.U = (r3 = Uint16Array, i3 = Uint32Array, { next_code: new r3(16), bl_count: new r3(16), ordr: [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], of0: [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 999, 999, 999], exb: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0], ldef: new r3(32), df0: [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 65535, 65535], dxb: [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0], ddef: new i3(32), flmap: new r3(512), fltree: [], fdmap: new r3(32), fdtree: [], lmap: new r3(32768), ltree: [], ttree: [], dmap: new r3(32768), dtree: [], imap: new r3(512), itree: [], rev15: new r3(32768), lhst: new i3(286), dhst: new i3(30), ihst: new i3(19), lits: new i3(15e3), strt: new r3(65536), prev: new r3(32768) }), function() {
    for (var e4 = UZIP2.F.U, t3 = 0; t3 < 32768; t3++) {
      var r4 = t3;
      r4 = (4278255360 & (r4 = (4042322160 & (r4 = (3435973836 & (r4 = (2863311530 & r4) >>> 1 | (1431655765 & r4) << 1)) >>> 2 | (858993459 & r4) << 2)) >>> 4 | (252645135 & r4) << 4)) >>> 8 | (16711935 & r4) << 8, e4.rev15[t3] = (r4 >>> 16 | r4 << 16) >>> 17;
    }
    function pushV(e5, t4, r5) {
      for (; t4-- != 0; )
        e5.push(0, r5);
    }
    for (t3 = 0; t3 < 32; t3++)
      e4.ldef[t3] = e4.of0[t3] << 3 | e4.exb[t3], e4.ddef[t3] = e4.df0[t3] << 4 | e4.dxb[t3];
    pushV(e4.fltree, 144, 8), pushV(e4.fltree, 112, 9), pushV(e4.fltree, 24, 7), pushV(e4.fltree, 8, 8), UZIP2.F.makeCodes(e4.fltree, 9), UZIP2.F.codes2map(e4.fltree, 9, e4.flmap), UZIP2.F.revCodes(e4.fltree, 9), pushV(e4.fdtree, 32, 5), UZIP2.F.makeCodes(e4.fdtree, 5), UZIP2.F.codes2map(e4.fdtree, 5, e4.fdmap), UZIP2.F.revCodes(e4.fdtree, 5), pushV(e4.itree, 19, 0), pushV(e4.ltree, 286, 0), pushV(e4.dtree, 30, 0), pushV(e4.ttree, 320, 0);
  }();
}();
var UZIP = _mergeNamespaces({ __proto__: null, default: e2 }, [e2]);
var UPNG = function() {
  var e3 = { nextZero(e4, t4) {
    for (; e4[t4] != 0; )
      t4++;
    return t4;
  }, readUshort: (e4, t4) => e4[t4] << 8 | e4[t4 + 1], writeUshort(e4, t4, r3) {
    e4[t4] = r3 >> 8 & 255, e4[t4 + 1] = 255 & r3;
  }, readUint: (e4, t4) => 16777216 * e4[t4] + (e4[t4 + 1] << 16 | e4[t4 + 2] << 8 | e4[t4 + 3]), writeUint(e4, t4, r3) {
    e4[t4] = r3 >> 24 & 255, e4[t4 + 1] = r3 >> 16 & 255, e4[t4 + 2] = r3 >> 8 & 255, e4[t4 + 3] = 255 & r3;
  }, readASCII(e4, t4, r3) {
    let i3 = "";
    for (let o3 = 0; o3 < r3; o3++)
      i3 += String.fromCharCode(e4[t4 + o3]);
    return i3;
  }, writeASCII(e4, t4, r3) {
    for (let i3 = 0; i3 < r3.length; i3++)
      e4[t4 + i3] = r3.charCodeAt(i3);
  }, readBytes(e4, t4, r3) {
    const i3 = [];
    for (let o3 = 0; o3 < r3; o3++)
      i3.push(e4[t4 + o3]);
    return i3;
  }, pad: (e4) => e4.length < 2 ? `0${e4}` : e4, readUTF8(t4, r3, i3) {
    let o3, a3 = "";
    for (let o4 = 0; o4 < i3; o4++)
      a3 += `%${e3.pad(t4[r3 + o4].toString(16))}`;
    try {
      o3 = decodeURIComponent(a3);
    } catch (o4) {
      return e3.readASCII(t4, r3, i3);
    }
    return o3;
  } };
  function decodeImage(t4, r3, i3, o3) {
    const a3 = r3 * i3, s3 = _getBPP(o3), f3 = Math.ceil(r3 * s3 / 8), l3 = new Uint8Array(4 * a3), c3 = new Uint32Array(l3.buffer), { ctype: u2 } = o3, { depth: h2 } = o3, d2 = e3.readUshort;
    if (u2 == 6) {
      const e4 = a3 << 2;
      if (h2 == 8)
        for (var A2 = 0; A2 < e4; A2 += 4)
          l3[A2] = t4[A2], l3[A2 + 1] = t4[A2 + 1], l3[A2 + 2] = t4[A2 + 2], l3[A2 + 3] = t4[A2 + 3];
      if (h2 == 16)
        for (A2 = 0; A2 < e4; A2++)
          l3[A2] = t4[A2 << 1];
    } else if (u2 == 2) {
      const e4 = o3.tabs.tRNS;
      if (e4 == null) {
        if (h2 == 8)
          for (A2 = 0; A2 < a3; A2++) {
            var g2 = 3 * A2;
            c3[A2] = 255 << 24 | t4[g2 + 2] << 16 | t4[g2 + 1] << 8 | t4[g2];
          }
        if (h2 == 16)
          for (A2 = 0; A2 < a3; A2++) {
            g2 = 6 * A2;
            c3[A2] = 255 << 24 | t4[g2 + 4] << 16 | t4[g2 + 2] << 8 | t4[g2];
          }
      } else {
        var p2 = e4[0];
        const r4 = e4[1], i4 = e4[2];
        if (h2 == 8)
          for (A2 = 0; A2 < a3; A2++) {
            var m2 = A2 << 2;
            g2 = 3 * A2;
            c3[A2] = 255 << 24 | t4[g2 + 2] << 16 | t4[g2 + 1] << 8 | t4[g2], t4[g2] == p2 && t4[g2 + 1] == r4 && t4[g2 + 2] == i4 && (l3[m2 + 3] = 0);
          }
        if (h2 == 16)
          for (A2 = 0; A2 < a3; A2++) {
            m2 = A2 << 2, g2 = 6 * A2;
            c3[A2] = 255 << 24 | t4[g2 + 4] << 16 | t4[g2 + 2] << 8 | t4[g2], d2(t4, g2) == p2 && d2(t4, g2 + 2) == r4 && d2(t4, g2 + 4) == i4 && (l3[m2 + 3] = 0);
          }
      }
    } else if (u2 == 3) {
      const e4 = o3.tabs.PLTE, s4 = o3.tabs.tRNS, c4 = s4 ? s4.length : 0;
      if (h2 == 1)
        for (var w2 = 0; w2 < i3; w2++) {
          var v2 = w2 * f3, b2 = w2 * r3;
          for (A2 = 0; A2 < r3; A2++) {
            m2 = b2 + A2 << 2;
            var y2 = 3 * (E2 = t4[v2 + (A2 >> 3)] >> 7 - ((7 & A2) << 0) & 1);
            l3[m2] = e4[y2], l3[m2 + 1] = e4[y2 + 1], l3[m2 + 2] = e4[y2 + 2], l3[m2 + 3] = E2 < c4 ? s4[E2] : 255;
          }
        }
      if (h2 == 2)
        for (w2 = 0; w2 < i3; w2++)
          for (v2 = w2 * f3, b2 = w2 * r3, A2 = 0; A2 < r3; A2++) {
            m2 = b2 + A2 << 2, y2 = 3 * (E2 = t4[v2 + (A2 >> 2)] >> 6 - ((3 & A2) << 1) & 3);
            l3[m2] = e4[y2], l3[m2 + 1] = e4[y2 + 1], l3[m2 + 2] = e4[y2 + 2], l3[m2 + 3] = E2 < c4 ? s4[E2] : 255;
          }
      if (h2 == 4)
        for (w2 = 0; w2 < i3; w2++)
          for (v2 = w2 * f3, b2 = w2 * r3, A2 = 0; A2 < r3; A2++) {
            m2 = b2 + A2 << 2, y2 = 3 * (E2 = t4[v2 + (A2 >> 1)] >> 4 - ((1 & A2) << 2) & 15);
            l3[m2] = e4[y2], l3[m2 + 1] = e4[y2 + 1], l3[m2 + 2] = e4[y2 + 2], l3[m2 + 3] = E2 < c4 ? s4[E2] : 255;
          }
      if (h2 == 8)
        for (A2 = 0; A2 < a3; A2++) {
          var E2;
          m2 = A2 << 2, y2 = 3 * (E2 = t4[A2]);
          l3[m2] = e4[y2], l3[m2 + 1] = e4[y2 + 1], l3[m2 + 2] = e4[y2 + 2], l3[m2 + 3] = E2 < c4 ? s4[E2] : 255;
        }
    } else if (u2 == 4) {
      if (h2 == 8)
        for (A2 = 0; A2 < a3; A2++) {
          m2 = A2 << 2;
          var F2 = t4[_ = A2 << 1];
          l3[m2] = F2, l3[m2 + 1] = F2, l3[m2 + 2] = F2, l3[m2 + 3] = t4[_ + 1];
        }
      if (h2 == 16)
        for (A2 = 0; A2 < a3; A2++) {
          var _;
          m2 = A2 << 2, F2 = t4[_ = A2 << 2];
          l3[m2] = F2, l3[m2 + 1] = F2, l3[m2 + 2] = F2, l3[m2 + 3] = t4[_ + 2];
        }
    } else if (u2 == 0)
      for (p2 = o3.tabs.tRNS ? o3.tabs.tRNS : -1, w2 = 0; w2 < i3; w2++) {
        const e4 = w2 * f3, i4 = w2 * r3;
        if (h2 == 1)
          for (var B2 = 0; B2 < r3; B2++) {
            var U2 = (F2 = 255 * (t4[e4 + (B2 >>> 3)] >>> 7 - (7 & B2) & 1)) == 255 * p2 ? 0 : 255;
            c3[i4 + B2] = U2 << 24 | F2 << 16 | F2 << 8 | F2;
          }
        else if (h2 == 2)
          for (B2 = 0; B2 < r3; B2++) {
            U2 = (F2 = 85 * (t4[e4 + (B2 >>> 2)] >>> 6 - ((3 & B2) << 1) & 3)) == 85 * p2 ? 0 : 255;
            c3[i4 + B2] = U2 << 24 | F2 << 16 | F2 << 8 | F2;
          }
        else if (h2 == 4)
          for (B2 = 0; B2 < r3; B2++) {
            U2 = (F2 = 17 * (t4[e4 + (B2 >>> 1)] >>> 4 - ((1 & B2) << 2) & 15)) == 17 * p2 ? 0 : 255;
            c3[i4 + B2] = U2 << 24 | F2 << 16 | F2 << 8 | F2;
          }
        else if (h2 == 8)
          for (B2 = 0; B2 < r3; B2++) {
            U2 = (F2 = t4[e4 + B2]) == p2 ? 0 : 255;
            c3[i4 + B2] = U2 << 24 | F2 << 16 | F2 << 8 | F2;
          }
        else if (h2 == 16)
          for (B2 = 0; B2 < r3; B2++) {
            F2 = t4[e4 + (B2 << 1)], U2 = d2(t4, e4 + (B2 << 1)) == p2 ? 0 : 255;
            c3[i4 + B2] = U2 << 24 | F2 << 16 | F2 << 8 | F2;
          }
      }
    return l3;
  }
  function _decompress(e4, r3, i3, o3) {
    const a3 = _getBPP(e4), s3 = Math.ceil(i3 * a3 / 8), f3 = new Uint8Array((s3 + 1 + e4.interlace) * o3);
    return r3 = e4.tabs.CgBI ? t3(r3, f3) : _inflate(r3, f3), e4.interlace == 0 ? r3 = _filterZero(r3, e4, 0, i3, o3) : e4.interlace == 1 && (r3 = function _readInterlace(e5, t4) {
      const r4 = t4.width, i4 = t4.height, o4 = _getBPP(t4), a4 = o4 >> 3, s4 = Math.ceil(r4 * o4 / 8), f4 = new Uint8Array(i4 * s4);
      let l3 = 0;
      const c3 = [0, 0, 4, 0, 2, 0, 1], u2 = [0, 4, 0, 2, 0, 1, 0], h2 = [8, 8, 8, 4, 4, 2, 2], d2 = [8, 8, 4, 4, 2, 2, 1];
      let A2 = 0;
      for (; A2 < 7; ) {
        const p2 = h2[A2], m2 = d2[A2];
        let w2 = 0, v2 = 0, b2 = c3[A2];
        for (; b2 < i4; )
          b2 += p2, v2++;
        let y2 = u2[A2];
        for (; y2 < r4; )
          y2 += m2, w2++;
        const E2 = Math.ceil(w2 * o4 / 8);
        _filterZero(e5, t4, l3, w2, v2);
        let F2 = 0, _ = c3[A2];
        for (; _ < i4; ) {
          let t5 = u2[A2], i5 = l3 + F2 * E2 << 3;
          for (; t5 < r4; ) {
            var g2;
            if (o4 == 1)
              g2 = (g2 = e5[i5 >> 3]) >> 7 - (7 & i5) & 1, f4[_ * s4 + (t5 >> 3)] |= g2 << 7 - ((7 & t5) << 0);
            if (o4 == 2)
              g2 = (g2 = e5[i5 >> 3]) >> 6 - (7 & i5) & 3, f4[_ * s4 + (t5 >> 2)] |= g2 << 6 - ((3 & t5) << 1);
            if (o4 == 4)
              g2 = (g2 = e5[i5 >> 3]) >> 4 - (7 & i5) & 15, f4[_ * s4 + (t5 >> 1)] |= g2 << 4 - ((1 & t5) << 2);
            if (o4 >= 8) {
              const r5 = _ * s4 + t5 * a4;
              for (let t6 = 0; t6 < a4; t6++)
                f4[r5 + t6] = e5[(i5 >> 3) + t6];
            }
            i5 += o4, t5 += m2;
          }
          F2++, _ += p2;
        }
        w2 * v2 != 0 && (l3 += v2 * (1 + E2)), A2 += 1;
      }
      return f4;
    }(r3, e4)), r3;
  }
  function _inflate(e4, r3) {
    return t3(new Uint8Array(e4.buffer, 2, e4.length - 6), r3);
  }
  var t3 = function() {
    const e4 = { H: {} };
    return e4.H.N = function(t4, r3) {
      const i3 = Uint8Array;
      let o3, a3, s3 = 0, f3 = 0, l3 = 0, c3 = 0, u2 = 0, h2 = 0, d2 = 0, A2 = 0, g2 = 0;
      if (t4[0] == 3 && t4[1] == 0)
        return r3 || new i3(0);
      const p2 = e4.H, m2 = p2.b, w2 = p2.e, v2 = p2.R, b2 = p2.n, y2 = p2.A, E2 = p2.Z, F2 = p2.m, _ = r3 == null;
      for (_ && (r3 = new i3(t4.length >>> 2 << 5)); s3 == 0; )
        if (s3 = m2(t4, g2, 1), f3 = m2(t4, g2 + 1, 2), g2 += 3, f3 != 0) {
          if (_ && (r3 = e4.H.W(r3, A2 + (1 << 17))), f3 == 1 && (o3 = F2.J, a3 = F2.h, h2 = 511, d2 = 31), f3 == 2) {
            l3 = w2(t4, g2, 5) + 257, c3 = w2(t4, g2 + 5, 5) + 1, u2 = w2(t4, g2 + 10, 4) + 4, g2 += 14;
            let e5 = 1;
            for (var B2 = 0; B2 < 38; B2 += 2)
              F2.Q[B2] = 0, F2.Q[B2 + 1] = 0;
            for (B2 = 0; B2 < u2; B2++) {
              const r5 = w2(t4, g2 + 3 * B2, 3);
              F2.Q[1 + (F2.X[B2] << 1)] = r5, r5 > e5 && (e5 = r5);
            }
            g2 += 3 * u2, b2(F2.Q, e5), y2(F2.Q, e5, F2.u), o3 = F2.w, a3 = F2.d, g2 = v2(F2.u, (1 << e5) - 1, l3 + c3, t4, g2, F2.v);
            const r4 = p2.V(F2.v, 0, l3, F2.C);
            h2 = (1 << r4) - 1;
            const i4 = p2.V(F2.v, l3, c3, F2.D);
            d2 = (1 << i4) - 1, b2(F2.C, r4), y2(F2.C, r4, o3), b2(F2.D, i4), y2(F2.D, i4, a3);
          }
          for (; ; ) {
            const e5 = o3[E2(t4, g2) & h2];
            g2 += 15 & e5;
            const i4 = e5 >>> 4;
            if (i4 >>> 8 == 0)
              r3[A2++] = i4;
            else {
              if (i4 == 256)
                break;
              {
                let e6 = A2 + i4 - 254;
                if (i4 > 264) {
                  const r4 = F2.q[i4 - 257];
                  e6 = A2 + (r4 >>> 3) + w2(t4, g2, 7 & r4), g2 += 7 & r4;
                }
                const o4 = a3[E2(t4, g2) & d2];
                g2 += 15 & o4;
                const s4 = o4 >>> 4, f4 = F2.c[s4], l4 = (f4 >>> 4) + m2(t4, g2, 15 & f4);
                for (g2 += 15 & f4; A2 < e6; )
                  r3[A2] = r3[A2++ - l4], r3[A2] = r3[A2++ - l4], r3[A2] = r3[A2++ - l4], r3[A2] = r3[A2++ - l4];
                A2 = e6;
              }
            }
          }
        } else {
          (7 & g2) != 0 && (g2 += 8 - (7 & g2));
          const o4 = 4 + (g2 >>> 3), a4 = t4[o4 - 4] | t4[o4 - 3] << 8;
          _ && (r3 = e4.H.W(r3, A2 + a4)), r3.set(new i3(t4.buffer, t4.byteOffset + o4, a4), A2), g2 = o4 + a4 << 3, A2 += a4;
        }
      return r3.length == A2 ? r3 : r3.slice(0, A2);
    }, e4.H.W = function(e5, t4) {
      const r3 = e5.length;
      if (t4 <= r3)
        return e5;
      const i3 = new Uint8Array(r3 << 1);
      return i3.set(e5, 0), i3;
    }, e4.H.R = function(t4, r3, i3, o3, a3, s3) {
      const f3 = e4.H.e, l3 = e4.H.Z;
      let c3 = 0;
      for (; c3 < i3; ) {
        const e5 = t4[l3(o3, a3) & r3];
        a3 += 15 & e5;
        const i4 = e5 >>> 4;
        if (i4 <= 15)
          s3[c3] = i4, c3++;
        else {
          let e6 = 0, t5 = 0;
          i4 == 16 ? (t5 = 3 + f3(o3, a3, 2), a3 += 2, e6 = s3[c3 - 1]) : i4 == 17 ? (t5 = 3 + f3(o3, a3, 3), a3 += 3) : i4 == 18 && (t5 = 11 + f3(o3, a3, 7), a3 += 7);
          const r4 = c3 + t5;
          for (; c3 < r4; )
            s3[c3] = e6, c3++;
        }
      }
      return a3;
    }, e4.H.V = function(e5, t4, r3, i3) {
      let o3 = 0, a3 = 0;
      const s3 = i3.length >>> 1;
      for (; a3 < r3; ) {
        const r4 = e5[a3 + t4];
        i3[a3 << 1] = 0, i3[1 + (a3 << 1)] = r4, r4 > o3 && (o3 = r4), a3++;
      }
      for (; a3 < s3; )
        i3[a3 << 1] = 0, i3[1 + (a3 << 1)] = 0, a3++;
      return o3;
    }, e4.H.n = function(t4, r3) {
      const i3 = e4.H.m, o3 = t4.length;
      let a3, s3, f3;
      let l3;
      const c3 = i3.j;
      for (var u2 = 0; u2 <= r3; u2++)
        c3[u2] = 0;
      for (u2 = 1; u2 < o3; u2 += 2)
        c3[t4[u2]]++;
      const h2 = i3.K;
      for (a3 = 0, c3[0] = 0, s3 = 1; s3 <= r3; s3++)
        a3 = a3 + c3[s3 - 1] << 1, h2[s3] = a3;
      for (f3 = 0; f3 < o3; f3 += 2)
        l3 = t4[f3 + 1], l3 != 0 && (t4[f3] = h2[l3], h2[l3]++);
    }, e4.H.A = function(t4, r3, i3) {
      const o3 = t4.length, a3 = e4.H.m.r;
      for (let e5 = 0; e5 < o3; e5 += 2)
        if (t4[e5 + 1] != 0) {
          const o4 = e5 >> 1, s3 = t4[e5 + 1], f3 = o4 << 4 | s3, l3 = r3 - s3;
          let c3 = t4[e5] << l3;
          const u2 = c3 + (1 << l3);
          for (; c3 != u2; ) {
            i3[a3[c3] >>> 15 - r3] = f3, c3++;
          }
        }
    }, e4.H.l = function(t4, r3) {
      const i3 = e4.H.m.r, o3 = 15 - r3;
      for (let e5 = 0; e5 < t4.length; e5 += 2) {
        const a3 = t4[e5] << r3 - t4[e5 + 1];
        t4[e5] = i3[a3] >>> o3;
      }
    }, e4.H.M = function(e5, t4, r3) {
      r3 <<= 7 & t4;
      const i3 = t4 >>> 3;
      e5[i3] |= r3, e5[i3 + 1] |= r3 >>> 8;
    }, e4.H.I = function(e5, t4, r3) {
      r3 <<= 7 & t4;
      const i3 = t4 >>> 3;
      e5[i3] |= r3, e5[i3 + 1] |= r3 >>> 8, e5[i3 + 2] |= r3 >>> 16;
    }, e4.H.e = function(e5, t4, r3) {
      return (e5[t4 >>> 3] | e5[1 + (t4 >>> 3)] << 8) >>> (7 & t4) & (1 << r3) - 1;
    }, e4.H.b = function(e5, t4, r3) {
      return (e5[t4 >>> 3] | e5[1 + (t4 >>> 3)] << 8 | e5[2 + (t4 >>> 3)] << 16) >>> (7 & t4) & (1 << r3) - 1;
    }, e4.H.Z = function(e5, t4) {
      return (e5[t4 >>> 3] | e5[1 + (t4 >>> 3)] << 8 | e5[2 + (t4 >>> 3)] << 16) >>> (7 & t4);
    }, e4.H.i = function(e5, t4) {
      return (e5[t4 >>> 3] | e5[1 + (t4 >>> 3)] << 8 | e5[2 + (t4 >>> 3)] << 16 | e5[3 + (t4 >>> 3)] << 24) >>> (7 & t4);
    }, e4.H.m = function() {
      const e5 = Uint16Array, t4 = Uint32Array;
      return { K: new e5(16), j: new e5(16), X: [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], S: [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 999, 999, 999], T: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0], q: new e5(32), p: [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 65535, 65535], z: [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0], c: new t4(32), J: new e5(512), _: [], h: new e5(32), $: [], w: new e5(32768), C: [], v: [], d: new e5(32768), D: [], u: new e5(512), Q: [], r: new e5(32768), s: new t4(286), Y: new t4(30), a: new t4(19), t: new t4(15e3), k: new e5(65536), g: new e5(32768) };
    }(), function() {
      const t4 = e4.H.m;
      for (var r3 = 0; r3 < 32768; r3++) {
        let e5 = r3;
        e5 = (2863311530 & e5) >>> 1 | (1431655765 & e5) << 1, e5 = (3435973836 & e5) >>> 2 | (858993459 & e5) << 2, e5 = (4042322160 & e5) >>> 4 | (252645135 & e5) << 4, e5 = (4278255360 & e5) >>> 8 | (16711935 & e5) << 8, t4.r[r3] = (e5 >>> 16 | e5 << 16) >>> 17;
      }
      function n2(e5, t5, r4) {
        for (; t5-- != 0; )
          e5.push(0, r4);
      }
      for (r3 = 0; r3 < 32; r3++)
        t4.q[r3] = t4.S[r3] << 3 | t4.T[r3], t4.c[r3] = t4.p[r3] << 4 | t4.z[r3];
      n2(t4._, 144, 8), n2(t4._, 112, 9), n2(t4._, 24, 7), n2(t4._, 8, 8), e4.H.n(t4._, 9), e4.H.A(t4._, 9, t4.J), e4.H.l(t4._, 9), n2(t4.$, 32, 5), e4.H.n(t4.$, 5), e4.H.A(t4.$, 5, t4.h), e4.H.l(t4.$, 5), n2(t4.Q, 19, 0), n2(t4.C, 286, 0), n2(t4.D, 30, 0), n2(t4.v, 320, 0);
    }(), e4.H.N;
  }();
  function _getBPP(e4) {
    return [1, null, 3, 1, 2, null, 4][e4.ctype] * e4.depth;
  }
  function _filterZero(e4, t4, r3, i3, o3) {
    let a3 = _getBPP(t4);
    const s3 = Math.ceil(i3 * a3 / 8);
    let f3, l3;
    a3 = Math.ceil(a3 / 8);
    let c3 = e4[r3], u2 = 0;
    if (c3 > 1 && (e4[r3] = [0, 0, 1][c3 - 2]), c3 == 3)
      for (u2 = a3; u2 < s3; u2++)
        e4[u2 + 1] = e4[u2 + 1] + (e4[u2 + 1 - a3] >>> 1) & 255;
    for (let t5 = 0; t5 < o3; t5++)
      if (f3 = r3 + t5 * s3, l3 = f3 + t5 + 1, c3 = e4[l3 - 1], u2 = 0, c3 == 0)
        for (; u2 < s3; u2++)
          e4[f3 + u2] = e4[l3 + u2];
      else if (c3 == 1) {
        for (; u2 < a3; u2++)
          e4[f3 + u2] = e4[l3 + u2];
        for (; u2 < s3; u2++)
          e4[f3 + u2] = e4[l3 + u2] + e4[f3 + u2 - a3];
      } else if (c3 == 2)
        for (; u2 < s3; u2++)
          e4[f3 + u2] = e4[l3 + u2] + e4[f3 + u2 - s3];
      else if (c3 == 3) {
        for (; u2 < a3; u2++)
          e4[f3 + u2] = e4[l3 + u2] + (e4[f3 + u2 - s3] >>> 1);
        for (; u2 < s3; u2++)
          e4[f3 + u2] = e4[l3 + u2] + (e4[f3 + u2 - s3] + e4[f3 + u2 - a3] >>> 1);
      } else {
        for (; u2 < a3; u2++)
          e4[f3 + u2] = e4[l3 + u2] + _paeth(0, e4[f3 + u2 - s3], 0);
        for (; u2 < s3; u2++)
          e4[f3 + u2] = e4[l3 + u2] + _paeth(e4[f3 + u2 - a3], e4[f3 + u2 - s3], e4[f3 + u2 - a3 - s3]);
      }
    return e4;
  }
  function _paeth(e4, t4, r3) {
    const i3 = e4 + t4 - r3, o3 = i3 - e4, a3 = i3 - t4, s3 = i3 - r3;
    return o3 * o3 <= a3 * a3 && o3 * o3 <= s3 * s3 ? e4 : a3 * a3 <= s3 * s3 ? t4 : r3;
  }
  function _IHDR(t4, r3, i3) {
    i3.width = e3.readUint(t4, r3), r3 += 4, i3.height = e3.readUint(t4, r3), r3 += 4, i3.depth = t4[r3], r3++, i3.ctype = t4[r3], r3++, i3.compress = t4[r3], r3++, i3.filter = t4[r3], r3++, i3.interlace = t4[r3], r3++;
  }
  function _copyTile(e4, t4, r3, i3, o3, a3, s3, f3, l3) {
    const c3 = Math.min(t4, o3), u2 = Math.min(r3, a3);
    let h2 = 0, d2 = 0;
    for (let r4 = 0; r4 < u2; r4++)
      for (let a4 = 0; a4 < c3; a4++)
        if (s3 >= 0 && f3 >= 0 ? (h2 = r4 * t4 + a4 << 2, d2 = (f3 + r4) * o3 + s3 + a4 << 2) : (h2 = (-f3 + r4) * t4 - s3 + a4 << 2, d2 = r4 * o3 + a4 << 2), l3 == 0)
          i3[d2] = e4[h2], i3[d2 + 1] = e4[h2 + 1], i3[d2 + 2] = e4[h2 + 2], i3[d2 + 3] = e4[h2 + 3];
        else if (l3 == 1) {
          var A2 = e4[h2 + 3] * (1 / 255), g2 = e4[h2] * A2, p2 = e4[h2 + 1] * A2, m2 = e4[h2 + 2] * A2, w2 = i3[d2 + 3] * (1 / 255), v2 = i3[d2] * w2, b2 = i3[d2 + 1] * w2, y2 = i3[d2 + 2] * w2;
          const t5 = 1 - A2, r5 = A2 + w2 * t5, o4 = r5 == 0 ? 0 : 1 / r5;
          i3[d2 + 3] = 255 * r5, i3[d2 + 0] = (g2 + v2 * t5) * o4, i3[d2 + 1] = (p2 + b2 * t5) * o4, i3[d2 + 2] = (m2 + y2 * t5) * o4;
        } else if (l3 == 2) {
          A2 = e4[h2 + 3], g2 = e4[h2], p2 = e4[h2 + 1], m2 = e4[h2 + 2], w2 = i3[d2 + 3], v2 = i3[d2], b2 = i3[d2 + 1], y2 = i3[d2 + 2];
          A2 == w2 && g2 == v2 && p2 == b2 && m2 == y2 ? (i3[d2] = 0, i3[d2 + 1] = 0, i3[d2 + 2] = 0, i3[d2 + 3] = 0) : (i3[d2] = g2, i3[d2 + 1] = p2, i3[d2 + 2] = m2, i3[d2 + 3] = A2);
        } else if (l3 == 3) {
          A2 = e4[h2 + 3], g2 = e4[h2], p2 = e4[h2 + 1], m2 = e4[h2 + 2], w2 = i3[d2 + 3], v2 = i3[d2], b2 = i3[d2 + 1], y2 = i3[d2 + 2];
          if (A2 == w2 && g2 == v2 && p2 == b2 && m2 == y2)
            continue;
          if (A2 < 220 && w2 > 20)
            return false;
        }
    return true;
  }
  return { decode: function decode(r3) {
    const i3 = new Uint8Array(r3);
    let o3 = 8;
    const a3 = e3, s3 = a3.readUshort, f3 = a3.readUint, l3 = { tabs: {}, frames: [] }, c3 = new Uint8Array(i3.length);
    let u2, h2 = 0, d2 = 0;
    const A2 = [137, 80, 78, 71, 13, 10, 26, 10];
    for (var g2 = 0; g2 < 8; g2++)
      if (i3[g2] != A2[g2])
        throw "The input is not a PNG file!";
    for (; o3 < i3.length; ) {
      const e4 = a3.readUint(i3, o3);
      o3 += 4;
      const r4 = a3.readASCII(i3, o3, 4);
      if (o3 += 4, r4 == "IHDR")
        _IHDR(i3, o3, l3);
      else if (r4 == "iCCP") {
        for (var p2 = o3; i3[p2] != 0; )
          p2++;
        a3.readASCII(i3, o3, p2 - o3), i3[p2 + 1];
        const s4 = i3.slice(p2 + 2, o3 + e4);
        let f4 = null;
        try {
          f4 = _inflate(s4);
        } catch (e5) {
          f4 = t3(s4);
        }
        l3.tabs[r4] = f4;
      } else if (r4 == "CgBI")
        l3.tabs[r4] = i3.slice(o3, o3 + 4);
      else if (r4 == "IDAT") {
        for (g2 = 0; g2 < e4; g2++)
          c3[h2 + g2] = i3[o3 + g2];
        h2 += e4;
      } else if (r4 == "acTL")
        l3.tabs[r4] = { num_frames: f3(i3, o3), num_plays: f3(i3, o3 + 4) }, u2 = new Uint8Array(i3.length);
      else if (r4 == "fcTL") {
        if (d2 != 0)
          (E2 = l3.frames[l3.frames.length - 1]).data = _decompress(l3, u2.slice(0, d2), E2.rect.width, E2.rect.height), d2 = 0;
        const e5 = { x: f3(i3, o3 + 12), y: f3(i3, o3 + 16), width: f3(i3, o3 + 4), height: f3(i3, o3 + 8) };
        let t4 = s3(i3, o3 + 22);
        t4 = s3(i3, o3 + 20) / (t4 == 0 ? 100 : t4);
        const r5 = { rect: e5, delay: Math.round(1e3 * t4), dispose: i3[o3 + 24], blend: i3[o3 + 25] };
        l3.frames.push(r5);
      } else if (r4 == "fdAT") {
        for (g2 = 0; g2 < e4 - 4; g2++)
          u2[d2 + g2] = i3[o3 + g2 + 4];
        d2 += e4 - 4;
      } else if (r4 == "pHYs")
        l3.tabs[r4] = [a3.readUint(i3, o3), a3.readUint(i3, o3 + 4), i3[o3 + 8]];
      else if (r4 == "cHRM") {
        l3.tabs[r4] = [];
        for (g2 = 0; g2 < 8; g2++)
          l3.tabs[r4].push(a3.readUint(i3, o3 + 4 * g2));
      } else if (r4 == "tEXt" || r4 == "zTXt") {
        l3.tabs[r4] == null && (l3.tabs[r4] = {});
        var m2 = a3.nextZero(i3, o3), w2 = a3.readASCII(i3, o3, m2 - o3), v2 = o3 + e4 - m2 - 1;
        if (r4 == "tEXt")
          y2 = a3.readASCII(i3, m2 + 1, v2);
        else {
          var b2 = _inflate(i3.slice(m2 + 2, m2 + 2 + v2));
          y2 = a3.readUTF8(b2, 0, b2.length);
        }
        l3.tabs[r4][w2] = y2;
      } else if (r4 == "iTXt") {
        l3.tabs[r4] == null && (l3.tabs[r4] = {});
        m2 = 0, p2 = o3;
        m2 = a3.nextZero(i3, p2);
        w2 = a3.readASCII(i3, p2, m2 - p2);
        const t4 = i3[p2 = m2 + 1];
        var y2;
        i3[p2 + 1], p2 += 2, m2 = a3.nextZero(i3, p2), a3.readASCII(i3, p2, m2 - p2), p2 = m2 + 1, m2 = a3.nextZero(i3, p2), a3.readUTF8(i3, p2, m2 - p2);
        v2 = e4 - ((p2 = m2 + 1) - o3);
        if (t4 == 0)
          y2 = a3.readUTF8(i3, p2, v2);
        else {
          b2 = _inflate(i3.slice(p2, p2 + v2));
          y2 = a3.readUTF8(b2, 0, b2.length);
        }
        l3.tabs[r4][w2] = y2;
      } else if (r4 == "PLTE")
        l3.tabs[r4] = a3.readBytes(i3, o3, e4);
      else if (r4 == "hIST") {
        const e5 = l3.tabs.PLTE.length / 3;
        l3.tabs[r4] = [];
        for (g2 = 0; g2 < e5; g2++)
          l3.tabs[r4].push(s3(i3, o3 + 2 * g2));
      } else if (r4 == "tRNS")
        l3.ctype == 3 ? l3.tabs[r4] = a3.readBytes(i3, o3, e4) : l3.ctype == 0 ? l3.tabs[r4] = s3(i3, o3) : l3.ctype == 2 && (l3.tabs[r4] = [s3(i3, o3), s3(i3, o3 + 2), s3(i3, o3 + 4)]);
      else if (r4 == "gAMA")
        l3.tabs[r4] = a3.readUint(i3, o3) / 1e5;
      else if (r4 == "sRGB")
        l3.tabs[r4] = i3[o3];
      else if (r4 == "bKGD")
        l3.ctype == 0 || l3.ctype == 4 ? l3.tabs[r4] = [s3(i3, o3)] : l3.ctype == 2 || l3.ctype == 6 ? l3.tabs[r4] = [s3(i3, o3), s3(i3, o3 + 2), s3(i3, o3 + 4)] : l3.ctype == 3 && (l3.tabs[r4] = i3[o3]);
      else if (r4 == "IEND")
        break;
      o3 += e4, a3.readUint(i3, o3), o3 += 4;
    }
    var E2;
    return d2 != 0 && ((E2 = l3.frames[l3.frames.length - 1]).data = _decompress(l3, u2.slice(0, d2), E2.rect.width, E2.rect.height)), l3.data = _decompress(l3, c3, l3.width, l3.height), delete l3.compress, delete l3.interlace, delete l3.filter, l3;
  }, toRGBA8: function toRGBA8(e4) {
    const t4 = e4.width, r3 = e4.height;
    if (e4.tabs.acTL == null)
      return [decodeImage(e4.data, t4, r3, e4).buffer];
    const i3 = [];
    e4.frames[0].data == null && (e4.frames[0].data = e4.data);
    const o3 = t4 * r3 * 4, a3 = new Uint8Array(o3), s3 = new Uint8Array(o3), f3 = new Uint8Array(o3);
    for (let c3 = 0; c3 < e4.frames.length; c3++) {
      const u2 = e4.frames[c3], h2 = u2.rect.x, d2 = u2.rect.y, A2 = u2.rect.width, g2 = u2.rect.height, p2 = decodeImage(u2.data, A2, g2, e4);
      if (c3 != 0)
        for (var l3 = 0; l3 < o3; l3++)
          f3[l3] = a3[l3];
      if (u2.blend == 0 ? _copyTile(p2, A2, g2, a3, t4, r3, h2, d2, 0) : u2.blend == 1 && _copyTile(p2, A2, g2, a3, t4, r3, h2, d2, 1), i3.push(a3.buffer.slice(0)), u2.dispose == 0)
        ;
      else if (u2.dispose == 1)
        _copyTile(s3, A2, g2, a3, t4, r3, h2, d2, 0);
      else if (u2.dispose == 2)
        for (l3 = 0; l3 < o3; l3++)
          a3[l3] = f3[l3];
    }
    return i3;
  }, _paeth, _copyTile, _bin: e3 };
}();
!function() {
  const { _copyTile: e3 } = UPNG, { _bin: t3 } = UPNG, r3 = UPNG._paeth;
  var i3 = { table: function() {
    const e4 = new Uint32Array(256);
    for (let t4 = 0; t4 < 256; t4++) {
      let r4 = t4;
      for (let e5 = 0; e5 < 8; e5++)
        1 & r4 ? r4 = 3988292384 ^ r4 >>> 1 : r4 >>>= 1;
      e4[t4] = r4;
    }
    return e4;
  }(), update(e4, t4, r4, o4) {
    for (let a3 = 0; a3 < o4; a3++)
      e4 = i3.table[255 & (e4 ^ t4[r4 + a3])] ^ e4 >>> 8;
    return e4;
  }, crc: (e4, t4, r4) => 4294967295 ^ i3.update(4294967295, e4, t4, r4) };
  function addErr(e4, t4, r4, i4) {
    t4[r4] += e4[0] * i4 >> 4, t4[r4 + 1] += e4[1] * i4 >> 4, t4[r4 + 2] += e4[2] * i4 >> 4, t4[r4 + 3] += e4[3] * i4 >> 4;
  }
  function N2(e4) {
    return Math.max(0, Math.min(255, e4));
  }
  function D2(e4, t4) {
    const r4 = e4[0] - t4[0], i4 = e4[1] - t4[1], o4 = e4[2] - t4[2], a3 = e4[3] - t4[3];
    return r4 * r4 + i4 * i4 + o4 * o4 + a3 * a3;
  }
  function dither(e4, t4, r4, i4, o4, a3, s3) {
    s3 == null && (s3 = 1);
    const f3 = i4.length, l3 = [];
    for (var c3 = 0; c3 < f3; c3++) {
      const e5 = i4[c3];
      l3.push([e5 >>> 0 & 255, e5 >>> 8 & 255, e5 >>> 16 & 255, e5 >>> 24 & 255]);
    }
    for (c3 = 0; c3 < f3; c3++) {
      let e5 = 4294967295;
      for (var u2 = 0, h2 = 0; h2 < f3; h2++) {
        var d2 = D2(l3[c3], l3[h2]);
        h2 != c3 && d2 < e5 && (e5 = d2, u2 = h2);
      }
    }
    const A2 = new Uint32Array(o4.buffer), g2 = new Int16Array(t4 * r4 * 4), p2 = [0, 8, 2, 10, 12, 4, 14, 6, 3, 11, 1, 9, 15, 7, 13, 5];
    for (c3 = 0; c3 < p2.length; c3++)
      p2[c3] = 255 * ((p2[c3] + 0.5) / 16 - 0.5);
    for (let o5 = 0; o5 < r4; o5++)
      for (let w2 = 0; w2 < t4; w2++) {
        var m2;
        c3 = 4 * (o5 * t4 + w2);
        if (s3 != 2)
          m2 = [N2(e4[c3] + g2[c3]), N2(e4[c3 + 1] + g2[c3 + 1]), N2(e4[c3 + 2] + g2[c3 + 2]), N2(e4[c3 + 3] + g2[c3 + 3])];
        else {
          d2 = p2[4 * (3 & o5) + (3 & w2)];
          m2 = [N2(e4[c3] + d2), N2(e4[c3 + 1] + d2), N2(e4[c3 + 2] + d2), N2(e4[c3 + 3] + d2)];
        }
        u2 = 0;
        let v2 = 16777215;
        for (h2 = 0; h2 < f3; h2++) {
          const e5 = D2(m2, l3[h2]);
          e5 < v2 && (v2 = e5, u2 = h2);
        }
        const b2 = l3[u2], y2 = [m2[0] - b2[0], m2[1] - b2[1], m2[2] - b2[2], m2[3] - b2[3]];
        s3 == 1 && (w2 != t4 - 1 && addErr(y2, g2, c3 + 4, 7), o5 != r4 - 1 && (w2 != 0 && addErr(y2, g2, c3 + 4 * t4 - 4, 3), addErr(y2, g2, c3 + 4 * t4, 5), w2 != t4 - 1 && addErr(y2, g2, c3 + 4 * t4 + 4, 1))), a3[c3 >> 2] = u2, A2[c3 >> 2] = i4[u2];
      }
  }
  function _main(e4, r4, o4, a3, s3) {
    s3 == null && (s3 = {});
    const { crc: f3 } = i3, l3 = t3.writeUint, c3 = t3.writeUshort, u2 = t3.writeASCII;
    let h2 = 8;
    const d2 = e4.frames.length > 1;
    let A2, g2 = false, p2 = 33 + (d2 ? 20 : 0);
    if (s3.sRGB != null && (p2 += 13), s3.pHYs != null && (p2 += 21), s3.iCCP != null && (A2 = pako.deflate(s3.iCCP), p2 += 21 + A2.length + 4), e4.ctype == 3) {
      for (var m2 = e4.plte.length, w2 = 0; w2 < m2; w2++)
        e4.plte[w2] >>> 24 != 255 && (g2 = true);
      p2 += 8 + 3 * m2 + 4 + (g2 ? 8 + 1 * m2 + 4 : 0);
    }
    for (var v2 = 0; v2 < e4.frames.length; v2++) {
      d2 && (p2 += 38), p2 += (F2 = e4.frames[v2]).cimg.length + 12, v2 != 0 && (p2 += 4);
    }
    p2 += 12;
    const b2 = new Uint8Array(p2), y2 = [137, 80, 78, 71, 13, 10, 26, 10];
    for (w2 = 0; w2 < 8; w2++)
      b2[w2] = y2[w2];
    if (l3(b2, h2, 13), h2 += 4, u2(b2, h2, "IHDR"), h2 += 4, l3(b2, h2, r4), h2 += 4, l3(b2, h2, o4), h2 += 4, b2[h2] = e4.depth, h2++, b2[h2] = e4.ctype, h2++, b2[h2] = 0, h2++, b2[h2] = 0, h2++, b2[h2] = 0, h2++, l3(b2, h2, f3(b2, h2 - 17, 17)), h2 += 4, s3.sRGB != null && (l3(b2, h2, 1), h2 += 4, u2(b2, h2, "sRGB"), h2 += 4, b2[h2] = s3.sRGB, h2++, l3(b2, h2, f3(b2, h2 - 5, 5)), h2 += 4), s3.iCCP != null) {
      const e5 = 13 + A2.length;
      l3(b2, h2, e5), h2 += 4, u2(b2, h2, "iCCP"), h2 += 4, u2(b2, h2, "ICC profile"), h2 += 11, h2 += 2, b2.set(A2, h2), h2 += A2.length, l3(b2, h2, f3(b2, h2 - (e5 + 4), e5 + 4)), h2 += 4;
    }
    if (s3.pHYs != null && (l3(b2, h2, 9), h2 += 4, u2(b2, h2, "pHYs"), h2 += 4, l3(b2, h2, s3.pHYs[0]), h2 += 4, l3(b2, h2, s3.pHYs[1]), h2 += 4, b2[h2] = s3.pHYs[2], h2++, l3(b2, h2, f3(b2, h2 - 13, 13)), h2 += 4), d2 && (l3(b2, h2, 8), h2 += 4, u2(b2, h2, "acTL"), h2 += 4, l3(b2, h2, e4.frames.length), h2 += 4, l3(b2, h2, s3.loop != null ? s3.loop : 0), h2 += 4, l3(b2, h2, f3(b2, h2 - 12, 12)), h2 += 4), e4.ctype == 3) {
      l3(b2, h2, 3 * (m2 = e4.plte.length)), h2 += 4, u2(b2, h2, "PLTE"), h2 += 4;
      for (w2 = 0; w2 < m2; w2++) {
        const t4 = 3 * w2, r5 = e4.plte[w2], i4 = 255 & r5, o5 = r5 >>> 8 & 255, a4 = r5 >>> 16 & 255;
        b2[h2 + t4 + 0] = i4, b2[h2 + t4 + 1] = o5, b2[h2 + t4 + 2] = a4;
      }
      if (h2 += 3 * m2, l3(b2, h2, f3(b2, h2 - 3 * m2 - 4, 3 * m2 + 4)), h2 += 4, g2) {
        l3(b2, h2, m2), h2 += 4, u2(b2, h2, "tRNS"), h2 += 4;
        for (w2 = 0; w2 < m2; w2++)
          b2[h2 + w2] = e4.plte[w2] >>> 24 & 255;
        h2 += m2, l3(b2, h2, f3(b2, h2 - m2 - 4, m2 + 4)), h2 += 4;
      }
    }
    let E2 = 0;
    for (v2 = 0; v2 < e4.frames.length; v2++) {
      var F2 = e4.frames[v2];
      d2 && (l3(b2, h2, 26), h2 += 4, u2(b2, h2, "fcTL"), h2 += 4, l3(b2, h2, E2++), h2 += 4, l3(b2, h2, F2.rect.width), h2 += 4, l3(b2, h2, F2.rect.height), h2 += 4, l3(b2, h2, F2.rect.x), h2 += 4, l3(b2, h2, F2.rect.y), h2 += 4, c3(b2, h2, a3[v2]), h2 += 2, c3(b2, h2, 1e3), h2 += 2, b2[h2] = F2.dispose, h2++, b2[h2] = F2.blend, h2++, l3(b2, h2, f3(b2, h2 - 30, 30)), h2 += 4);
      const t4 = F2.cimg;
      l3(b2, h2, (m2 = t4.length) + (v2 == 0 ? 0 : 4)), h2 += 4;
      const r5 = h2;
      u2(b2, h2, v2 == 0 ? "IDAT" : "fdAT"), h2 += 4, v2 != 0 && (l3(b2, h2, E2++), h2 += 4), b2.set(t4, h2), h2 += m2, l3(b2, h2, f3(b2, r5, h2 - r5)), h2 += 4;
    }
    return l3(b2, h2, 0), h2 += 4, u2(b2, h2, "IEND"), h2 += 4, l3(b2, h2, f3(b2, h2 - 4, 4)), h2 += 4, b2.buffer;
  }
  function compressPNG(e4, t4, r4) {
    for (let i4 = 0; i4 < e4.frames.length; i4++) {
      const o4 = e4.frames[i4];
      o4.rect.width;
      const a3 = o4.rect.height, s3 = new Uint8Array(a3 * o4.bpl + a3);
      o4.cimg = _filterZero(o4.img, a3, o4.bpp, o4.bpl, s3, t4, r4);
    }
  }
  function compress2(t4, r4, i4, o4, a3) {
    const s3 = a3[0], f3 = a3[1], l3 = a3[2], c3 = a3[3], u2 = a3[4], h2 = a3[5];
    let d2 = 6, A2 = 8, g2 = 255;
    for (var p2 = 0; p2 < t4.length; p2++) {
      const e4 = new Uint8Array(t4[p2]);
      for (var m2 = e4.length, w2 = 0; w2 < m2; w2 += 4)
        g2 &= e4[w2 + 3];
    }
    const v2 = g2 != 255, b2 = function framize(t5, r5, i5, o5, a4, s4) {
      const f4 = [];
      for (var l4 = 0; l4 < t5.length; l4++) {
        const h4 = new Uint8Array(t5[l4]), A4 = new Uint32Array(h4.buffer);
        var c4;
        let g3 = 0, p3 = 0, m3 = r5, w3 = i5, v3 = o5 ? 1 : 0;
        if (l4 != 0) {
          const b3 = s4 || o5 || l4 == 1 || f4[l4 - 2].dispose != 0 ? 1 : 2;
          let y3 = 0, E3 = 1e9;
          for (let e4 = 0; e4 < b3; e4++) {
            var u3 = new Uint8Array(t5[l4 - 1 - e4]);
            const o6 = new Uint32Array(t5[l4 - 1 - e4]);
            let s5 = r5, f5 = i5, c5 = -1, h5 = -1;
            for (let e5 = 0; e5 < i5; e5++)
              for (let t6 = 0; t6 < r5; t6++) {
                A4[d3 = e5 * r5 + t6] != o6[d3] && (t6 < s5 && (s5 = t6), t6 > c5 && (c5 = t6), e5 < f5 && (f5 = e5), e5 > h5 && (h5 = e5));
              }
            c5 == -1 && (s5 = f5 = c5 = h5 = 0), a4 && ((1 & s5) == 1 && s5--, (1 & f5) == 1 && f5--);
            const v5 = (c5 - s5 + 1) * (h5 - f5 + 1);
            v5 < E3 && (E3 = v5, y3 = e4, g3 = s5, p3 = f5, m3 = c5 - s5 + 1, w3 = h5 - f5 + 1);
          }
          u3 = new Uint8Array(t5[l4 - 1 - y3]);
          y3 == 1 && (f4[l4 - 1].dispose = 2), c4 = new Uint8Array(m3 * w3 * 4), e3(u3, r5, i5, c4, m3, w3, -g3, -p3, 0), v3 = e3(h4, r5, i5, c4, m3, w3, -g3, -p3, 3) ? 1 : 0, v3 == 1 ? _prepareDiff(h4, r5, i5, c4, { x: g3, y: p3, width: m3, height: w3 }) : e3(h4, r5, i5, c4, m3, w3, -g3, -p3, 0);
        } else
          c4 = h4.slice(0);
        f4.push({ rect: { x: g3, y: p3, width: m3, height: w3 }, img: c4, blend: v3, dispose: 0 });
      }
      if (o5)
        for (l4 = 0; l4 < f4.length; l4++) {
          if ((A3 = f4[l4]).blend == 1)
            continue;
          const e4 = A3.rect, o6 = f4[l4 - 1].rect, s5 = Math.min(e4.x, o6.x), c5 = Math.min(e4.y, o6.y), u4 = { x: s5, y: c5, width: Math.max(e4.x + e4.width, o6.x + o6.width) - s5, height: Math.max(e4.y + e4.height, o6.y + o6.height) - c5 };
          f4[l4 - 1].dispose = 1, l4 - 1 != 0 && _updateFrame(t5, r5, i5, f4, l4 - 1, u4, a4), _updateFrame(t5, r5, i5, f4, l4, u4, a4);
        }
      let h3 = 0;
      if (t5.length != 1)
        for (var d3 = 0; d3 < f4.length; d3++) {
          var A3;
          h3 += (A3 = f4[d3]).rect.width * A3.rect.height;
        }
      return f4;
    }(t4, r4, i4, s3, f3, l3), y2 = {}, E2 = [], F2 = [];
    if (o4 != 0) {
      const e4 = [];
      for (w2 = 0; w2 < b2.length; w2++)
        e4.push(b2[w2].img.buffer);
      const t5 = function concatRGBA(e5) {
        let t6 = 0;
        for (var r6 = 0; r6 < e5.length; r6++)
          t6 += e5[r6].byteLength;
        const i6 = new Uint8Array(t6);
        let o5 = 0;
        for (r6 = 0; r6 < e5.length; r6++) {
          const t7 = new Uint8Array(e5[r6]), a4 = t7.length;
          for (let e6 = 0; e6 < a4; e6 += 4) {
            let r7 = t7[e6], a5 = t7[e6 + 1], s4 = t7[e6 + 2];
            const f4 = t7[e6 + 3];
            f4 == 0 && (r7 = a5 = s4 = 0), i6[o5 + e6] = r7, i6[o5 + e6 + 1] = a5, i6[o5 + e6 + 2] = s4, i6[o5 + e6 + 3] = f4;
          }
          o5 += a4;
        }
        return i6.buffer;
      }(e4), r5 = quantize(t5, o4);
      for (w2 = 0; w2 < r5.plte.length; w2++)
        E2.push(r5.plte[w2].est.rgba);
      let i5 = 0;
      for (w2 = 0; w2 < b2.length; w2++) {
        const e5 = (B2 = b2[w2]).img.length;
        var _ = new Uint8Array(r5.inds.buffer, i5 >> 2, e5 >> 2);
        F2.push(_);
        const t6 = new Uint8Array(r5.abuf, i5, e5);
        h2 && dither(B2.img, B2.rect.width, B2.rect.height, E2, t6, _), B2.img.set(t6), i5 += e5;
      }
    } else
      for (p2 = 0; p2 < b2.length; p2++) {
        var B2 = b2[p2];
        const e4 = new Uint32Array(B2.img.buffer);
        var U2 = B2.rect.width;
        m2 = e4.length, _ = new Uint8Array(m2);
        F2.push(_);
        for (w2 = 0; w2 < m2; w2++) {
          const t5 = e4[w2];
          if (w2 != 0 && t5 == e4[w2 - 1])
            _[w2] = _[w2 - 1];
          else if (w2 > U2 && t5 == e4[w2 - U2])
            _[w2] = _[w2 - U2];
          else {
            let e5 = y2[t5];
            if (e5 == null && (y2[t5] = e5 = E2.length, E2.push(t5), E2.length >= 300))
              break;
            _[w2] = e5;
          }
        }
      }
    const C2 = E2.length;
    C2 <= 256 && u2 == 0 && (A2 = C2 <= 2 ? 1 : C2 <= 4 ? 2 : C2 <= 16 ? 4 : 8, A2 = Math.max(A2, c3));
    for (p2 = 0; p2 < b2.length; p2++) {
      (B2 = b2[p2]).rect.x, B2.rect.y;
      U2 = B2.rect.width;
      const e4 = B2.rect.height;
      let t5 = B2.img;
      new Uint32Array(t5.buffer);
      let r5 = 4 * U2, i5 = 4;
      if (C2 <= 256 && u2 == 0) {
        r5 = Math.ceil(A2 * U2 / 8);
        var I2 = new Uint8Array(r5 * e4);
        const o5 = F2[p2];
        for (let t6 = 0; t6 < e4; t6++) {
          w2 = t6 * r5;
          const e5 = t6 * U2;
          if (A2 == 8)
            for (var Q2 = 0; Q2 < U2; Q2++)
              I2[w2 + Q2] = o5[e5 + Q2];
          else if (A2 == 4)
            for (Q2 = 0; Q2 < U2; Q2++)
              I2[w2 + (Q2 >> 1)] |= o5[e5 + Q2] << 4 - 4 * (1 & Q2);
          else if (A2 == 2)
            for (Q2 = 0; Q2 < U2; Q2++)
              I2[w2 + (Q2 >> 2)] |= o5[e5 + Q2] << 6 - 2 * (3 & Q2);
          else if (A2 == 1)
            for (Q2 = 0; Q2 < U2; Q2++)
              I2[w2 + (Q2 >> 3)] |= o5[e5 + Q2] << 7 - 1 * (7 & Q2);
        }
        t5 = I2, d2 = 3, i5 = 1;
      } else if (v2 == 0 && b2.length == 1) {
        I2 = new Uint8Array(U2 * e4 * 3);
        const o5 = U2 * e4;
        for (w2 = 0; w2 < o5; w2++) {
          const e5 = 3 * w2, r6 = 4 * w2;
          I2[e5] = t5[r6], I2[e5 + 1] = t5[r6 + 1], I2[e5 + 2] = t5[r6 + 2];
        }
        t5 = I2, d2 = 2, i5 = 3, r5 = 3 * U2;
      }
      B2.img = t5, B2.bpl = r5, B2.bpp = i5;
    }
    return { ctype: d2, depth: A2, plte: E2, frames: b2 };
  }
  function _updateFrame(t4, r4, i4, o4, a3, s3, f3) {
    const l3 = Uint8Array, c3 = Uint32Array, u2 = new l3(t4[a3 - 1]), h2 = new c3(t4[a3 - 1]), d2 = a3 + 1 < t4.length ? new l3(t4[a3 + 1]) : null, A2 = new l3(t4[a3]), g2 = new c3(A2.buffer);
    let p2 = r4, m2 = i4, w2 = -1, v2 = -1;
    for (let e4 = 0; e4 < s3.height; e4++)
      for (let t5 = 0; t5 < s3.width; t5++) {
        const i5 = s3.x + t5, f4 = s3.y + e4, l4 = f4 * r4 + i5, c4 = g2[l4];
        c4 == 0 || o4[a3 - 1].dispose == 0 && h2[l4] == c4 && (d2 == null || d2[4 * l4 + 3] != 0) || (i5 < p2 && (p2 = i5), i5 > w2 && (w2 = i5), f4 < m2 && (m2 = f4), f4 > v2 && (v2 = f4));
      }
    w2 == -1 && (p2 = m2 = w2 = v2 = 0), f3 && ((1 & p2) == 1 && p2--, (1 & m2) == 1 && m2--), s3 = { x: p2, y: m2, width: w2 - p2 + 1, height: v2 - m2 + 1 };
    const b2 = o4[a3];
    b2.rect = s3, b2.blend = 1, b2.img = new Uint8Array(s3.width * s3.height * 4), o4[a3 - 1].dispose == 0 ? (e3(u2, r4, i4, b2.img, s3.width, s3.height, -s3.x, -s3.y, 0), _prepareDiff(A2, r4, i4, b2.img, s3)) : e3(A2, r4, i4, b2.img, s3.width, s3.height, -s3.x, -s3.y, 0);
  }
  function _prepareDiff(t4, r4, i4, o4, a3) {
    e3(t4, r4, i4, o4, a3.width, a3.height, -a3.x, -a3.y, 2);
  }
  function _filterZero(e4, t4, r4, i4, o4, a3, s3) {
    const f3 = [];
    let l3, c3 = [0, 1, 2, 3, 4];
    a3 != -1 ? c3 = [a3] : (t4 * i4 > 5e5 || r4 == 1) && (c3 = [0]), s3 && (l3 = { level: 0 });
    const u2 = UZIP;
    for (var h2 = 0; h2 < c3.length; h2++) {
      for (let a4 = 0; a4 < t4; a4++)
        _filterLine(o4, e4, a4, i4, r4, c3[h2]);
      f3.push(u2.deflate(o4, l3));
    }
    let d2, A2 = 1e9;
    for (h2 = 0; h2 < f3.length; h2++)
      f3[h2].length < A2 && (d2 = h2, A2 = f3[h2].length);
    return f3[d2];
  }
  function _filterLine(e4, t4, i4, o4, a3, s3) {
    const f3 = i4 * o4;
    let l3 = f3 + i4;
    if (e4[l3] = s3, l3++, s3 == 0)
      if (o4 < 500)
        for (var c3 = 0; c3 < o4; c3++)
          e4[l3 + c3] = t4[f3 + c3];
      else
        e4.set(new Uint8Array(t4.buffer, f3, o4), l3);
    else if (s3 == 1) {
      for (c3 = 0; c3 < a3; c3++)
        e4[l3 + c3] = t4[f3 + c3];
      for (c3 = a3; c3 < o4; c3++)
        e4[l3 + c3] = t4[f3 + c3] - t4[f3 + c3 - a3] + 256 & 255;
    } else if (i4 == 0) {
      for (c3 = 0; c3 < a3; c3++)
        e4[l3 + c3] = t4[f3 + c3];
      if (s3 == 2)
        for (c3 = a3; c3 < o4; c3++)
          e4[l3 + c3] = t4[f3 + c3];
      if (s3 == 3)
        for (c3 = a3; c3 < o4; c3++)
          e4[l3 + c3] = t4[f3 + c3] - (t4[f3 + c3 - a3] >> 1) + 256 & 255;
      if (s3 == 4)
        for (c3 = a3; c3 < o4; c3++)
          e4[l3 + c3] = t4[f3 + c3] - r3(t4[f3 + c3 - a3], 0, 0) + 256 & 255;
    } else {
      if (s3 == 2)
        for (c3 = 0; c3 < o4; c3++)
          e4[l3 + c3] = t4[f3 + c3] + 256 - t4[f3 + c3 - o4] & 255;
      if (s3 == 3) {
        for (c3 = 0; c3 < a3; c3++)
          e4[l3 + c3] = t4[f3 + c3] + 256 - (t4[f3 + c3 - o4] >> 1) & 255;
        for (c3 = a3; c3 < o4; c3++)
          e4[l3 + c3] = t4[f3 + c3] + 256 - (t4[f3 + c3 - o4] + t4[f3 + c3 - a3] >> 1) & 255;
      }
      if (s3 == 4) {
        for (c3 = 0; c3 < a3; c3++)
          e4[l3 + c3] = t4[f3 + c3] + 256 - r3(0, t4[f3 + c3 - o4], 0) & 255;
        for (c3 = a3; c3 < o4; c3++)
          e4[l3 + c3] = t4[f3 + c3] + 256 - r3(t4[f3 + c3 - a3], t4[f3 + c3 - o4], t4[f3 + c3 - a3 - o4]) & 255;
      }
    }
  }
  function quantize(e4, t4) {
    const r4 = new Uint8Array(e4), i4 = r4.slice(0), o4 = new Uint32Array(i4.buffer), a3 = getKDtree(i4, t4), s3 = a3[0], f3 = a3[1], l3 = r4.length, c3 = new Uint8Array(l3 >> 2);
    let u2;
    if (r4.length < 2e7)
      for (var h2 = 0; h2 < l3; h2 += 4) {
        u2 = getNearest(s3, d2 = r4[h2] * (1 / 255), A2 = r4[h2 + 1] * (1 / 255), g2 = r4[h2 + 2] * (1 / 255), p2 = r4[h2 + 3] * (1 / 255)), c3[h2 >> 2] = u2.ind, o4[h2 >> 2] = u2.est.rgba;
      }
    else
      for (h2 = 0; h2 < l3; h2 += 4) {
        var d2 = r4[h2] * (1 / 255), A2 = r4[h2 + 1] * (1 / 255), g2 = r4[h2 + 2] * (1 / 255), p2 = r4[h2 + 3] * (1 / 255);
        for (u2 = s3; u2.left; )
          u2 = planeDst(u2.est, d2, A2, g2, p2) <= 0 ? u2.left : u2.right;
        c3[h2 >> 2] = u2.ind, o4[h2 >> 2] = u2.est.rgba;
      }
    return { abuf: i4.buffer, inds: c3, plte: f3 };
  }
  function getKDtree(e4, t4, r4) {
    r4 == null && (r4 = 1e-4);
    const i4 = new Uint32Array(e4.buffer), o4 = { i0: 0, i1: e4.length, bst: null, est: null, tdst: 0, left: null, right: null };
    o4.bst = stats(e4, o4.i0, o4.i1), o4.est = estats(o4.bst);
    const a3 = [o4];
    for (; a3.length < t4; ) {
      let t5 = 0, o5 = 0;
      for (var s3 = 0; s3 < a3.length; s3++)
        a3[s3].est.L > t5 && (t5 = a3[s3].est.L, o5 = s3);
      if (t5 < r4)
        break;
      const f3 = a3[o5], l3 = splitPixels(e4, i4, f3.i0, f3.i1, f3.est.e, f3.est.eMq255);
      if (f3.i0 >= l3 || f3.i1 <= l3) {
        f3.est.L = 0;
        continue;
      }
      const c3 = { i0: f3.i0, i1: l3, bst: null, est: null, tdst: 0, left: null, right: null };
      c3.bst = stats(e4, c3.i0, c3.i1), c3.est = estats(c3.bst);
      const u2 = { i0: l3, i1: f3.i1, bst: null, est: null, tdst: 0, left: null, right: null };
      u2.bst = { R: [], m: [], N: f3.bst.N - c3.bst.N };
      for (s3 = 0; s3 < 16; s3++)
        u2.bst.R[s3] = f3.bst.R[s3] - c3.bst.R[s3];
      for (s3 = 0; s3 < 4; s3++)
        u2.bst.m[s3] = f3.bst.m[s3] - c3.bst.m[s3];
      u2.est = estats(u2.bst), f3.left = c3, f3.right = u2, a3[o5] = c3, a3.push(u2);
    }
    a3.sort((e5, t5) => t5.bst.N - e5.bst.N);
    for (s3 = 0; s3 < a3.length; s3++)
      a3[s3].ind = s3;
    return [o4, a3];
  }
  function getNearest(e4, t4, r4, i4, o4) {
    if (e4.left == null)
      return e4.tdst = function dist(e5, t5, r5, i5, o5) {
        const a4 = t5 - e5[0], s4 = r5 - e5[1], f4 = i5 - e5[2], l4 = o5 - e5[3];
        return a4 * a4 + s4 * s4 + f4 * f4 + l4 * l4;
      }(e4.est.q, t4, r4, i4, o4), e4;
    const a3 = planeDst(e4.est, t4, r4, i4, o4);
    let s3 = e4.left, f3 = e4.right;
    a3 > 0 && (s3 = e4.right, f3 = e4.left);
    const l3 = getNearest(s3, t4, r4, i4, o4);
    if (l3.tdst <= a3 * a3)
      return l3;
    const c3 = getNearest(f3, t4, r4, i4, o4);
    return c3.tdst < l3.tdst ? c3 : l3;
  }
  function planeDst(e4, t4, r4, i4, o4) {
    const { e: a3 } = e4;
    return a3[0] * t4 + a3[1] * r4 + a3[2] * i4 + a3[3] * o4 - e4.eMq;
  }
  function splitPixels(e4, t4, r4, i4, o4, a3) {
    for (i4 -= 4; r4 < i4; ) {
      for (; vecDot(e4, r4, o4) <= a3; )
        r4 += 4;
      for (; vecDot(e4, i4, o4) > a3; )
        i4 -= 4;
      if (r4 >= i4)
        break;
      const s3 = t4[r4 >> 2];
      t4[r4 >> 2] = t4[i4 >> 2], t4[i4 >> 2] = s3, r4 += 4, i4 -= 4;
    }
    for (; vecDot(e4, r4, o4) > a3; )
      r4 -= 4;
    return r4 + 4;
  }
  function vecDot(e4, t4, r4) {
    return e4[t4] * r4[0] + e4[t4 + 1] * r4[1] + e4[t4 + 2] * r4[2] + e4[t4 + 3] * r4[3];
  }
  function stats(e4, t4, r4) {
    const i4 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], o4 = [0, 0, 0, 0], a3 = r4 - t4 >> 2;
    for (let a4 = t4; a4 < r4; a4 += 4) {
      const t5 = e4[a4] * (1 / 255), r5 = e4[a4 + 1] * (1 / 255), s3 = e4[a4 + 2] * (1 / 255), f3 = e4[a4 + 3] * (1 / 255);
      o4[0] += t5, o4[1] += r5, o4[2] += s3, o4[3] += f3, i4[0] += t5 * t5, i4[1] += t5 * r5, i4[2] += t5 * s3, i4[3] += t5 * f3, i4[5] += r5 * r5, i4[6] += r5 * s3, i4[7] += r5 * f3, i4[10] += s3 * s3, i4[11] += s3 * f3, i4[15] += f3 * f3;
    }
    return i4[4] = i4[1], i4[8] = i4[2], i4[9] = i4[6], i4[12] = i4[3], i4[13] = i4[7], i4[14] = i4[11], { R: i4, m: o4, N: a3 };
  }
  function estats(e4) {
    const { R: t4 } = e4, { m: r4 } = e4, { N: i4 } = e4, a3 = r4[0], s3 = r4[1], f3 = r4[2], l3 = r4[3], c3 = i4 == 0 ? 0 : 1 / i4, u2 = [t4[0] - a3 * a3 * c3, t4[1] - a3 * s3 * c3, t4[2] - a3 * f3 * c3, t4[3] - a3 * l3 * c3, t4[4] - s3 * a3 * c3, t4[5] - s3 * s3 * c3, t4[6] - s3 * f3 * c3, t4[7] - s3 * l3 * c3, t4[8] - f3 * a3 * c3, t4[9] - f3 * s3 * c3, t4[10] - f3 * f3 * c3, t4[11] - f3 * l3 * c3, t4[12] - l3 * a3 * c3, t4[13] - l3 * s3 * c3, t4[14] - l3 * f3 * c3, t4[15] - l3 * l3 * c3], h2 = u2, d2 = o3;
    let A2 = [Math.random(), Math.random(), Math.random(), Math.random()], g2 = 0, p2 = 0;
    if (i4 != 0)
      for (let e5 = 0; e5 < 16 && (A2 = d2.multVec(h2, A2), p2 = Math.sqrt(d2.dot(A2, A2)), A2 = d2.sml(1 / p2, A2), !(e5 != 0 && Math.abs(p2 - g2) < 1e-9)); e5++)
        g2 = p2;
    const m2 = [a3 * c3, s3 * c3, f3 * c3, l3 * c3];
    return { Cov: u2, q: m2, e: A2, L: g2, eMq255: d2.dot(d2.sml(255, m2), A2), eMq: d2.dot(A2, m2), rgba: (Math.round(255 * m2[3]) << 24 | Math.round(255 * m2[2]) << 16 | Math.round(255 * m2[1]) << 8 | Math.round(255 * m2[0]) << 0) >>> 0 };
  }
  var o3 = { multVec: (e4, t4) => [e4[0] * t4[0] + e4[1] * t4[1] + e4[2] * t4[2] + e4[3] * t4[3], e4[4] * t4[0] + e4[5] * t4[1] + e4[6] * t4[2] + e4[7] * t4[3], e4[8] * t4[0] + e4[9] * t4[1] + e4[10] * t4[2] + e4[11] * t4[3], e4[12] * t4[0] + e4[13] * t4[1] + e4[14] * t4[2] + e4[15] * t4[3]], dot: (e4, t4) => e4[0] * t4[0] + e4[1] * t4[1] + e4[2] * t4[2] + e4[3] * t4[3], sml: (e4, t4) => [e4 * t4[0], e4 * t4[1], e4 * t4[2], e4 * t4[3]] };
  UPNG.encode = function encode(e4, t4, r4, i4, o4, a3, s3) {
    i4 == null && (i4 = 0), s3 == null && (s3 = false);
    const f3 = compress2(e4, t4, r4, i4, [false, false, false, 0, s3, false]);
    return compressPNG(f3, -1), _main(f3, t4, r4, o4, a3);
  }, UPNG.encodeLL = function encodeLL(e4, t4, r4, i4, o4, a3, s3, f3) {
    const l3 = { ctype: 0 + (i4 == 1 ? 0 : 2) + (o4 == 0 ? 0 : 4), depth: a3, frames: [] }, c3 = (i4 + o4) * a3, u2 = c3 * t4;
    for (let i5 = 0; i5 < e4.length; i5++)
      l3.frames.push({ rect: { x: 0, y: 0, width: t4, height: r4 }, img: new Uint8Array(e4[i5]), blend: 0, dispose: 1, bpp: Math.ceil(c3 / 8), bpl: Math.ceil(u2 / 8) });
    return compressPNG(l3, 0, true), _main(l3, t4, r4, s3, f3);
  }, UPNG.encode.compress = compress2, UPNG.encode.dither = dither, UPNG.quantize = quantize, UPNG.quantize.getKDtree = getKDtree, UPNG.quantize.getNearest = getNearest;
}();
var r2 = { toArrayBuffer(e3, t3) {
  const i3 = e3.width, o3 = e3.height, a3 = i3 << 2, s3 = e3.getContext("2d").getImageData(0, 0, i3, o3), f3 = new Uint32Array(s3.data.buffer), l3 = (32 * i3 + 31) / 32 << 2, c3 = l3 * o3, u2 = 122 + c3, h2 = new ArrayBuffer(u2), d2 = new DataView(h2), A2 = 1 << 20;
  let g2, p2, m2, w2, v2 = A2, b2 = 0, y2 = 0, E2 = 0;
  function set16(e4) {
    d2.setUint16(y2, e4, true), y2 += 2;
  }
  function set32(e4) {
    d2.setUint32(y2, e4, true), y2 += 4;
  }
  function seek(e4) {
    y2 += e4;
  }
  set16(19778), set32(u2), seek(4), set32(122), set32(108), set32(i3), set32(-o3 >>> 0), set16(1), set16(32), set32(3), set32(c3), set32(2835), set32(2835), seek(8), set32(16711680), set32(65280), set32(255), set32(4278190080), set32(1466527264), function convert() {
    for (; b2 < o3 && v2 > 0; ) {
      for (w2 = 122 + b2 * l3, g2 = 0; g2 < a3; )
        v2--, p2 = f3[E2++], m2 = p2 >>> 24, d2.setUint32(w2 + g2, p2 << 8 | m2), g2 += 4;
      b2++;
    }
    E2 < f3.length ? (v2 = A2, setTimeout(convert, r2._dly)) : t3(h2);
  }();
}, toBlob(e3, t3) {
  this.toArrayBuffer(e3, (e4) => {
    t3(new Blob([e4], { type: "image/bmp" }));
  });
}, _dly: 9 };
var i2 = { CHROME: "CHROME", FIREFOX: "FIREFOX", DESKTOP_SAFARI: "DESKTOP_SAFARI", IE: "IE", IOS: "IOS", ETC: "ETC" };
var o2 = { [i2.CHROME]: 16384, [i2.FIREFOX]: 11180, [i2.DESKTOP_SAFARI]: 16384, [i2.IE]: 8192, [i2.IOS]: 4096, [i2.ETC]: 8192 };
var a2 = typeof window != "undefined";
var s2 = typeof WorkerGlobalScope != "undefined" && self instanceof WorkerGlobalScope;
var f2 = a2 && window.cordova && window.cordova.require && window.cordova.require("cordova/modulemapper");
var CustomFile = (a2 || s2) && (f2 && f2.getOriginalSymbol(window, "File") || typeof File != "undefined" && File);
var CustomFileReader = (a2 || s2) && (f2 && f2.getOriginalSymbol(window, "FileReader") || typeof FileReader != "undefined" && FileReader);
function getFilefromDataUrl(e3, t3, r3 = Date.now()) {
  return new Promise((i3) => {
    const o3 = e3.split(","), a3 = o3[0].match(/:(.*?);/)[1], s3 = globalThis.atob(o3[1]);
    let f3 = s3.length;
    const l3 = new Uint8Array(f3);
    for (; f3--; )
      l3[f3] = s3.charCodeAt(f3);
    const c3 = new Blob([l3], { type: a3 });
    c3.name = t3, c3.lastModified = r3, i3(c3);
  });
}
function getDataUrlFromFile(e3) {
  return new Promise((t3, r3) => {
    const i3 = new CustomFileReader();
    i3.onload = () => t3(i3.result), i3.onerror = (e4) => r3(e4), i3.readAsDataURL(e3);
  });
}
function loadImage(e3) {
  return new Promise((t3, r3) => {
    const i3 = new Image();
    i3.onload = () => t3(i3), i3.onerror = (e4) => r3(e4), i3.src = e3;
  });
}
function getBrowserName() {
  if (getBrowserName.cachedResult !== void 0)
    return getBrowserName.cachedResult;
  let e3 = i2.ETC;
  const { userAgent: t3 } = navigator;
  return /Chrom(e|ium)/i.test(t3) ? e3 = i2.CHROME : /iP(ad|od|hone)/i.test(t3) && /WebKit/i.test(t3) ? e3 = i2.IOS : /Safari/i.test(t3) ? e3 = i2.DESKTOP_SAFARI : /Firefox/i.test(t3) ? e3 = i2.FIREFOX : (/MSIE/i.test(t3) || !!document.documentMode == true) && (e3 = i2.IE), getBrowserName.cachedResult = e3, getBrowserName.cachedResult;
}
function approximateBelowMaximumCanvasSizeOfBrowser(e3, t3) {
  const r3 = getBrowserName(), i3 = o2[r3];
  let a3 = e3, s3 = t3, f3 = a3 * s3;
  const l3 = a3 > s3 ? s3 / a3 : a3 / s3;
  for (; f3 > i3 * i3; ) {
    const e4 = (i3 + a3) / 2, t4 = (i3 + s3) / 2;
    e4 < t4 ? (s3 = t4, a3 = t4 * l3) : (s3 = e4 * l3, a3 = e4), f3 = a3 * s3;
  }
  return { width: a3, height: s3 };
}
function getNewCanvasAndCtx(e3, t3) {
  let r3, i3;
  try {
    if (r3 = new OffscreenCanvas(e3, t3), i3 = r3.getContext("2d"), i3 === null)
      throw new Error("getContext of OffscreenCanvas returns null");
  } catch (e4) {
    r3 = document.createElement("canvas"), i3 = r3.getContext("2d");
  }
  return r3.width = e3, r3.height = t3, [r3, i3];
}
function drawImageInCanvas(e3, t3) {
  const { width: r3, height: i3 } = approximateBelowMaximumCanvasSizeOfBrowser(e3.width, e3.height), [o3, a3] = getNewCanvasAndCtx(r3, i3);
  return t3 && /jpe?g/.test(t3) && (a3.fillStyle = "white", a3.fillRect(0, 0, o3.width, o3.height)), a3.drawImage(e3, 0, 0, o3.width, o3.height), o3;
}
function isIOS() {
  return isIOS.cachedResult !== void 0 || (isIOS.cachedResult = ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(navigator.platform) || navigator.userAgent.includes("Mac") && typeof document != "undefined" && "ontouchend" in document), isIOS.cachedResult;
}
function drawFileInCanvas(e3, t3 = {}) {
  return new Promise(function(r3, o3) {
    let a3, s3;
    var $Try_2_Post = function() {
      try {
        return s3 = drawImageInCanvas(a3, t3.fileType || e3.type), r3([a3, s3]);
      } catch (e4) {
        return o3(e4);
      }
    }, $Try_2_Catch = function(t4) {
      try {
        0;
        var $Try_3_Catch = function(e4) {
          try {
            throw e4;
          } catch (e5) {
            return o3(e5);
          }
        };
        try {
          let t5;
          return getDataUrlFromFile(e3).then(function(e4) {
            try {
              return t5 = e4, loadImage(t5).then(function(e5) {
                try {
                  return a3 = e5, function() {
                    try {
                      return $Try_2_Post();
                    } catch (e6) {
                      return o3(e6);
                    }
                  }();
                } catch (e6) {
                  return $Try_3_Catch(e6);
                }
              }, $Try_3_Catch);
            } catch (e5) {
              return $Try_3_Catch(e5);
            }
          }, $Try_3_Catch);
        } catch (e4) {
          $Try_3_Catch(e4);
        }
      } catch (e4) {
        return o3(e4);
      }
    };
    try {
      if (isIOS() || [i2.DESKTOP_SAFARI, i2.MOBILE_SAFARI].includes(getBrowserName()))
        throw new Error("Skip createImageBitmap on IOS and Safari");
      return createImageBitmap(e3).then(function(e4) {
        try {
          return a3 = e4, $Try_2_Post();
        } catch (e5) {
          return $Try_2_Catch();
        }
      }, $Try_2_Catch);
    } catch (e4) {
      $Try_2_Catch();
    }
  });
}
function canvasToFile(e3, t3, i3, o3, a3 = 1) {
  return new Promise(function(s3, f3) {
    let l3;
    if (t3 === "image/png") {
      let c3, u2, h2;
      return c3 = e3.getContext("2d"), { data: u2 } = c3.getImageData(0, 0, e3.width, e3.height), h2 = UPNG.encode([u2.buffer], e3.width, e3.height, 4096 * a3), l3 = new Blob([h2], { type: t3 }), l3.name = i3, l3.lastModified = o3, $If_4.call(this);
    }
    {
      let $If_5 = function() {
        return $If_4.call(this);
      };
      if (t3 === "image/bmp")
        return new Promise((t4) => r2.toBlob(e3, t4)).then(function(e4) {
          try {
            return l3 = e4, l3.name = i3, l3.lastModified = o3, $If_5.call(this);
          } catch (e5) {
            return f3(e5);
          }
        }.bind(this), f3);
      {
        let $If_6 = function() {
          return $If_5.call(this);
        };
        if (typeof OffscreenCanvas == "function" && e3 instanceof OffscreenCanvas)
          return e3.convertToBlob({ type: t3, quality: a3 }).then(function(e4) {
            try {
              return l3 = e4, l3.name = i3, l3.lastModified = o3, $If_6.call(this);
            } catch (e5) {
              return f3(e5);
            }
          }.bind(this), f3);
        {
          let d2;
          return d2 = e3.toDataURL(t3, a3), getFilefromDataUrl(d2, i3, o3).then(function(e4) {
            try {
              return l3 = e4, $If_6.call(this);
            } catch (e5) {
              return f3(e5);
            }
          }.bind(this), f3);
        }
      }
    }
    function $If_4() {
      return s3(l3);
    }
  });
}
function cleanupCanvasMemory(e3) {
  e3.width = 0, e3.height = 0;
}
function isAutoOrientationInBrowser() {
  return new Promise(function(e3, t3) {
    let r3, i3, o3, a3, s3;
    return isAutoOrientationInBrowser.cachedResult !== void 0 ? e3(isAutoOrientationInBrowser.cachedResult) : (r3 = "data:image/jpeg;base64,/9j/4QAiRXhpZgAATU0AKgAAAAgAAQESAAMAAAABAAYAAAAAAAD/2wCEAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAf/AABEIAAEAAgMBEQACEQEDEQH/xABKAAEAAAAAAAAAAAAAAAAAAAALEAEAAAAAAAAAAAAAAAAAAAAAAQEAAAAAAAAAAAAAAAAAAAAAEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwA/8H//2Q==", getFilefromDataUrl("data:image/jpeg;base64,/9j/4QAiRXhpZgAATU0AKgAAAAgAAQESAAMAAAABAAYAAAAAAAD/2wCEAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAf/AABEIAAEAAgMBEQACEQEDEQH/xABKAAEAAAAAAAAAAAAAAAAAAAALEAEAAAAAAAAAAAAAAAAAAAAAAQEAAAAAAAAAAAAAAAAAAAAAEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwA/8H//2Q==", "test.jpg", Date.now()).then(function(r4) {
      try {
        return i3 = r4, drawFileInCanvas(i3).then(function(r5) {
          try {
            return o3 = r5[1], canvasToFile(o3, i3.type, i3.name, i3.lastModified).then(function(r6) {
              try {
                return a3 = r6, cleanupCanvasMemory(o3), drawFileInCanvas(a3).then(function(r7) {
                  try {
                    return s3 = r7[0], isAutoOrientationInBrowser.cachedResult = s3.width === 1 && s3.height === 2, e3(isAutoOrientationInBrowser.cachedResult);
                  } catch (e4) {
                    return t3(e4);
                  }
                }, t3);
              } catch (e4) {
                return t3(e4);
              }
            }, t3);
          } catch (e4) {
            return t3(e4);
          }
        }, t3);
      } catch (e4) {
        return t3(e4);
      }
    }, t3));
  });
}
function getExifOrientation(e3) {
  return new Promise((t3, r3) => {
    const i3 = new CustomFileReader();
    i3.onload = (e4) => {
      const r4 = new DataView(e4.target.result);
      if (r4.getUint16(0, false) != 65496)
        return t3(-2);
      const i4 = r4.byteLength;
      let o3 = 2;
      for (; o3 < i4; ) {
        if (r4.getUint16(o3 + 2, false) <= 8)
          return t3(-1);
        const e5 = r4.getUint16(o3, false);
        if (o3 += 2, e5 == 65505) {
          if (r4.getUint32(o3 += 2, false) != 1165519206)
            return t3(-1);
          const e6 = r4.getUint16(o3 += 6, false) == 18761;
          o3 += r4.getUint32(o3 + 4, e6);
          const i5 = r4.getUint16(o3, e6);
          o3 += 2;
          for (let a3 = 0; a3 < i5; a3++)
            if (r4.getUint16(o3 + 12 * a3, e6) == 274)
              return t3(r4.getUint16(o3 + 12 * a3 + 8, e6));
        } else {
          if ((65280 & e5) != 65280)
            break;
          o3 += r4.getUint16(o3, false);
        }
      }
      return t3(-1);
    }, i3.onerror = (e4) => r3(e4), i3.readAsArrayBuffer(e3);
  });
}
function handleMaxWidthOrHeight(e3, t3) {
  const { width: r3 } = e3, { height: i3 } = e3, { maxWidthOrHeight: o3 } = t3;
  let a3, s3 = e3;
  return isFinite(o3) && (r3 > o3 || i3 > o3) && ([s3, a3] = getNewCanvasAndCtx(r3, i3), r3 > i3 ? (s3.width = o3, s3.height = i3 / r3 * o3) : (s3.width = r3 / i3 * o3, s3.height = o3), a3.drawImage(e3, 0, 0, s3.width, s3.height), cleanupCanvasMemory(e3)), s3;
}
function followExifOrientation(e3, t3) {
  const { width: r3 } = e3, { height: i3 } = e3, [o3, a3] = getNewCanvasAndCtx(r3, i3);
  switch (t3 > 4 && t3 < 9 ? (o3.width = i3, o3.height = r3) : (o3.width = r3, o3.height = i3), t3) {
    case 2:
      a3.transform(-1, 0, 0, 1, r3, 0);
      break;
    case 3:
      a3.transform(-1, 0, 0, -1, r3, i3);
      break;
    case 4:
      a3.transform(1, 0, 0, -1, 0, i3);
      break;
    case 5:
      a3.transform(0, 1, 1, 0, 0, 0);
      break;
    case 6:
      a3.transform(0, 1, -1, 0, i3, 0);
      break;
    case 7:
      a3.transform(0, -1, -1, 0, i3, r3);
      break;
    case 8:
      a3.transform(0, -1, 1, 0, 0, r3);
  }
  return a3.drawImage(e3, 0, 0, r3, i3), cleanupCanvasMemory(e3), o3;
}
function compress(e3, t3, r3 = 0) {
  return new Promise(function(i3, o3) {
    let a3, s3, f3, l3, c3, u2, h2, d2, A2, g2, p2, m2, w2, v2, b2, y2, E2, F2, _, B2;
    function incProgress(e4 = 5) {
      if (t3.signal && t3.signal.aborted)
        throw t3.signal.reason;
      a3 += e4, t3.onProgress(Math.min(a3, 100));
    }
    function setProgress(e4) {
      if (t3.signal && t3.signal.aborted)
        throw t3.signal.reason;
      a3 = Math.min(Math.max(e4, a3), 100), t3.onProgress(a3);
    }
    return a3 = r3, s3 = t3.maxIteration || 10, f3 = 1024 * t3.maxSizeMB * 1024, incProgress(), drawFileInCanvas(e3, t3).then(function(r4) {
      try {
        return [, l3] = r4, incProgress(), c3 = handleMaxWidthOrHeight(l3, t3), incProgress(), new Promise(function(r5, i4) {
          var o4;
          if (!(o4 = t3.exifOrientation))
            return getExifOrientation(e3).then(function(e4) {
              try {
                return o4 = e4, $If_2.call(this);
              } catch (e5) {
                return i4(e5);
              }
            }.bind(this), i4);
          function $If_2() {
            return r5(o4);
          }
          return $If_2.call(this);
        }).then(function(r5) {
          try {
            return u2 = r5, incProgress(), isAutoOrientationInBrowser().then(function(r6) {
              try {
                return h2 = r6 ? c3 : followExifOrientation(c3, u2), incProgress(), d2 = t3.initialQuality || 1, A2 = t3.fileType || e3.type, canvasToFile(h2, A2, e3.name, e3.lastModified, d2).then(function(r7) {
                  try {
                    {
                      let $Loop_3 = function() {
                        if (s3-- && (b2 > f3 || b2 > w2)) {
                          let t4, r8;
                          return t4 = B2 ? 0.95 * _.width : _.width, r8 = B2 ? 0.95 * _.height : _.height, [E2, F2] = getNewCanvasAndCtx(t4, r8), F2.drawImage(_, 0, 0, t4, r8), d2 *= A2 === "image/png" ? 0.85 : 0.95, canvasToFile(E2, A2, e3.name, e3.lastModified, d2).then(function(e4) {
                            try {
                              return y2 = e4, cleanupCanvasMemory(_), _ = E2, b2 = y2.size, setProgress(Math.min(99, Math.floor((v2 - b2) / (v2 - f3) * 100))), $Loop_3;
                            } catch (e5) {
                              return o3(e5);
                            }
                          }, o3);
                        }
                        return [1];
                      }, $Loop_3_exit = function() {
                        return cleanupCanvasMemory(_), cleanupCanvasMemory(E2), cleanupCanvasMemory(c3), cleanupCanvasMemory(h2), cleanupCanvasMemory(l3), setProgress(100), i3(y2);
                      };
                      if (g2 = r7, incProgress(), p2 = g2.size > f3, m2 = g2.size > e3.size, !p2 && !m2)
                        return setProgress(100), i3(g2);
                      var a4;
                      return w2 = e3.size, v2 = g2.size, b2 = v2, _ = h2, B2 = !t3.alwaysKeepResolution && p2, (a4 = function(e4) {
                        for (; e4; ) {
                          if (e4.then)
                            return void e4.then(a4, o3);
                          try {
                            if (e4.pop) {
                              if (e4.length)
                                return e4.pop() ? $Loop_3_exit.call(this) : e4;
                              e4 = $Loop_3;
                            } else
                              e4 = e4.call(this);
                          } catch (e5) {
                            return o3(e5);
                          }
                        }
                      }.bind(this))($Loop_3);
                    }
                  } catch (u3) {
                    return o3(u3);
                  }
                }.bind(this), o3);
              } catch (e4) {
                return o3(e4);
              }
            }.bind(this), o3);
          } catch (e4) {
            return o3(e4);
          }
        }.bind(this), o3);
      } catch (e4) {
        return o3(e4);
      }
    }.bind(this), o3);
  });
}
var l2 = "\nlet scriptImported = false\nself.addEventListener('message', async (e) => {\n  const { file, id, imageCompressionLibUrl, options } = e.data\n  options.onProgress = (progress) => self.postMessage({ progress, id })\n  try {\n    if (!scriptImported) {\n      // console.log('[worker] importScripts', imageCompressionLibUrl)\n      self.importScripts(imageCompressionLibUrl)\n      scriptImported = true\n    }\n    // console.log('[worker] self', self)\n    const compressedFile = await imageCompression(file, options)\n    self.postMessage({ file: compressedFile, id })\n  } catch (e) {\n    // console.error('[worker] error', e)\n    self.postMessage({ error: e.message + '\\n' + e.stack, id })\n  }\n})\n";
var c2;
function compressOnWebWorker(e3, t3) {
  return new Promise((r3, i3) => {
    c2 || (c2 = function createWorkerScriptURL(e4) {
      const t4 = [];
      return typeof e4 == "function" ? t4.push(`(${e4})()`) : t4.push(e4), URL.createObjectURL(new Blob(t4));
    }(l2));
    const o3 = new Worker(c2);
    o3.addEventListener("message", function handler(e4) {
      if (t3.signal && t3.signal.aborted)
        o3.terminate();
      else if (e4.data.progress === void 0) {
        if (e4.data.error)
          return i3(new Error(e4.data.error)), void o3.terminate();
        r3(e4.data.file), o3.terminate();
      } else
        t3.onProgress(e4.data.progress);
    }), o3.addEventListener("error", i3), t3.signal && t3.signal.addEventListener("abort", () => {
      i3(t3.signal.reason), o3.terminate();
    }), o3.postMessage({ file: e3, imageCompressionLibUrl: t3.libURL, options: { ...t3, onProgress: void 0, signal: void 0 } });
  });
}
function imageCompression(e3, t3) {
  return new Promise(function(r3, i3) {
    let o3, a3, s3, f3, l3, c3;
    if (o3 = { ...t3 }, s3 = 0, { onProgress: f3 } = o3, o3.maxSizeMB = o3.maxSizeMB || Number.POSITIVE_INFINITY, l3 = typeof o3.useWebWorker != "boolean" || o3.useWebWorker, delete o3.useWebWorker, o3.onProgress = (e4) => {
      s3 = e4, typeof f3 == "function" && f3(s3);
    }, !(e3 instanceof Blob || e3 instanceof CustomFile))
      return i3(new Error("The file given is not an instance of Blob or File"));
    if (!/^image/.test(e3.type))
      return i3(new Error("The file given is not an image"));
    if (c3 = typeof WorkerGlobalScope != "undefined" && self instanceof WorkerGlobalScope, !l3 || typeof Worker != "function" || c3)
      return compress(e3, o3).then(function(e4) {
        try {
          return a3 = e4, $If_4.call(this);
        } catch (e5) {
          return i3(e5);
        }
      }.bind(this), i3);
    var u2 = function() {
      try {
        return $If_4.call(this);
      } catch (e4) {
        return i3(e4);
      }
    }.bind(this), $Try_1_Catch = function(t4) {
      try {
        return compress(e3, o3).then(function(e4) {
          try {
            return a3 = e4, u2();
          } catch (e5) {
            return i3(e5);
          }
        }, i3);
      } catch (e4) {
        return i3(e4);
      }
    };
    try {
      return o3.libURL = o3.libURL || "https://cdn.jsdelivr.net/npm/browser-image-compression@2.0.2/dist/browser-image-compression.js", compressOnWebWorker(e3, o3).then(function(e4) {
        try {
          return a3 = e4, u2();
        } catch (e5) {
          return $Try_1_Catch();
        }
      }, $Try_1_Catch);
    } catch (e4) {
      $Try_1_Catch();
    }
    function $If_4() {
      try {
        a3.name = e3.name, a3.lastModified = e3.lastModified;
      } catch (e4) {
      }
      try {
        o3.preserveExif && e3.type === "image/jpeg" && (!o3.fileType || o3.fileType && o3.fileType === e3.type) && (a3 = copyExifWithoutOrientation(e3, a3));
      } catch (e4) {
      }
      return r3(a3);
    }
  });
}
imageCompression.getDataUrlFromFile = getDataUrlFromFile, imageCompression.getFilefromDataUrl = getFilefromDataUrl, imageCompression.loadImage = loadImage, imageCompression.drawImageInCanvas = drawImageInCanvas, imageCompression.drawFileInCanvas = drawFileInCanvas, imageCompression.canvasToFile = canvasToFile, imageCompression.getExifOrientation = getExifOrientation, imageCompression.handleMaxWidthOrHeight = handleMaxWidthOrHeight, imageCompression.followExifOrientation = followExifOrientation, imageCompression.cleanupCanvasMemory = cleanupCanvasMemory, imageCompression.isAutoOrientationInBrowser = isAutoOrientationInBrowser, imageCompression.approximateBelowMaximumCanvasSizeOfBrowser = approximateBelowMaximumCanvasSizeOfBrowser, imageCompression.copyExifWithoutOrientation = copyExifWithoutOrientation, imageCompression.getBrowserName = getBrowserName, imageCompression.version = "2.0.2";

// node_modules/@isaacs/balanced-match/dist/esm/index.js
var balanced = (a3, b2, str) => {
  const ma = a3 instanceof RegExp ? maybeMatch(a3, str) : a3;
  const mb = b2 instanceof RegExp ? maybeMatch(b2, str) : b2;
  const r3 = ma !== null && mb != null && range(ma, mb, str);
  return r3 && {
    start: r3[0],
    end: r3[1],
    pre: str.slice(0, r3[0]),
    body: str.slice(r3[0] + ma.length, r3[1]),
    post: str.slice(r3[1] + mb.length)
  };
};
var maybeMatch = (reg, str) => {
  const m2 = str.match(reg);
  return m2 ? m2[0] : null;
};
var range = (a3, b2, str) => {
  let begs, beg, left, right = void 0, result;
  let ai2 = str.indexOf(a3);
  let bi2 = str.indexOf(b2, ai2 + 1);
  let i3 = ai2;
  if (ai2 >= 0 && bi2 > 0) {
    if (a3 === b2) {
      return [ai2, bi2];
    }
    begs = [];
    left = str.length;
    while (i3 >= 0 && !result) {
      if (i3 === ai2) {
        begs.push(i3);
        ai2 = str.indexOf(a3, i3 + 1);
      } else if (begs.length === 1) {
        const r3 = begs.pop();
        if (r3 !== void 0)
          result = [r3, bi2];
      } else {
        beg = begs.pop();
        if (beg !== void 0 && beg < left) {
          left = beg;
          right = bi2;
        }
        bi2 = str.indexOf(b2, i3 + 1);
      }
      i3 = ai2 < bi2 && ai2 >= 0 ? ai2 : bi2;
    }
    if (begs.length && right !== void 0) {
      result = [left, right];
    }
  }
  return result;
};

// node_modules/@isaacs/brace-expansion/dist/esm/index.js
var escSlash = "\0SLASH" + Math.random() + "\0";
var escOpen = "\0OPEN" + Math.random() + "\0";
var escClose = "\0CLOSE" + Math.random() + "\0";
var escComma = "\0COMMA" + Math.random() + "\0";
var escPeriod = "\0PERIOD" + Math.random() + "\0";
var escSlashPattern = new RegExp(escSlash, "g");
var escOpenPattern = new RegExp(escOpen, "g");
var escClosePattern = new RegExp(escClose, "g");
var escCommaPattern = new RegExp(escComma, "g");
var escPeriodPattern = new RegExp(escPeriod, "g");
var slashPattern = /\\\\/g;
var openPattern = /\\{/g;
var closePattern = /\\}/g;
var commaPattern = /\\,/g;
var periodPattern = /\\./g;
function numeric(str) {
  return !isNaN(str) ? parseInt(str, 10) : str.charCodeAt(0);
}
function escapeBraces(str) {
  return str.replace(slashPattern, escSlash).replace(openPattern, escOpen).replace(closePattern, escClose).replace(commaPattern, escComma).replace(periodPattern, escPeriod);
}
function unescapeBraces(str) {
  return str.replace(escSlashPattern, "\\").replace(escOpenPattern, "{").replace(escClosePattern, "}").replace(escCommaPattern, ",").replace(escPeriodPattern, ".");
}
function parseCommaParts(str) {
  if (!str) {
    return [""];
  }
  const parts = [];
  const m2 = balanced("{", "}", str);
  if (!m2) {
    return str.split(",");
  }
  const { pre, body, post } = m2;
  const p2 = pre.split(",");
  p2[p2.length - 1] += "{" + body + "}";
  const postParts = parseCommaParts(post);
  if (post.length) {
    ;
    p2[p2.length - 1] += postParts.shift();
    p2.push.apply(p2, postParts);
  }
  parts.push.apply(parts, p2);
  return parts;
}
function expand(str) {
  if (!str) {
    return [];
  }
  if (str.slice(0, 2) === "{}") {
    str = "\\{\\}" + str.slice(2);
  }
  return expand_(escapeBraces(str), true).map(unescapeBraces);
}
function embrace(str) {
  return "{" + str + "}";
}
function isPadded(el) {
  return /^-?0\d/.test(el);
}
function lte(i3, y2) {
  return i3 <= y2;
}
function gte(i3, y2) {
  return i3 >= y2;
}
function expand_(str, isTop) {
  const expansions = [];
  const m2 = balanced("{", "}", str);
  if (!m2)
    return [str];
  const pre = m2.pre;
  const post = m2.post.length ? expand_(m2.post, false) : [""];
  if (/\$$/.test(m2.pre)) {
    for (let k2 = 0; k2 < post.length; k2++) {
      const expansion = pre + "{" + m2.body + "}" + post[k2];
      expansions.push(expansion);
    }
  } else {
    const isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m2.body);
    const isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m2.body);
    const isSequence = isNumericSequence || isAlphaSequence;
    const isOptions = m2.body.indexOf(",") >= 0;
    if (!isSequence && !isOptions) {
      if (m2.post.match(/,(?!,).*\}/)) {
        str = m2.pre + "{" + m2.body + escClose + m2.post;
        return expand_(str);
      }
      return [str];
    }
    let n2;
    if (isSequence) {
      n2 = m2.body.split(/\.\./);
    } else {
      n2 = parseCommaParts(m2.body);
      if (n2.length === 1 && n2[0] !== void 0) {
        n2 = expand_(n2[0], false).map(embrace);
        if (n2.length === 1) {
          return post.map((p2) => m2.pre + n2[0] + p2);
        }
      }
    }
    let N2;
    if (isSequence && n2[0] !== void 0 && n2[1] !== void 0) {
      const x2 = numeric(n2[0]);
      const y2 = numeric(n2[1]);
      const width = Math.max(n2[0].length, n2[1].length);
      let incr = n2.length === 3 && n2[2] !== void 0 ? Math.abs(numeric(n2[2])) : 1;
      let test = lte;
      const reverse = y2 < x2;
      if (reverse) {
        incr *= -1;
        test = gte;
      }
      const pad = n2.some(isPadded);
      N2 = [];
      for (let i3 = x2; test(i3, y2); i3 += incr) {
        let c3;
        if (isAlphaSequence) {
          c3 = String.fromCharCode(i3);
          if (c3 === "\\") {
            c3 = "";
          }
        } else {
          c3 = String(i3);
          if (pad) {
            const need = width - c3.length;
            if (need > 0) {
              const z2 = new Array(need + 1).join("0");
              if (i3 < 0) {
                c3 = "-" + z2 + c3.slice(1);
              } else {
                c3 = z2 + c3;
              }
            }
          }
        }
        N2.push(c3);
      }
    } else {
      N2 = [];
      for (let j2 = 0; j2 < n2.length; j2++) {
        N2.push.apply(N2, expand_(n2[j2], false));
      }
    }
    for (let j2 = 0; j2 < N2.length; j2++) {
      for (let k2 = 0; k2 < post.length; k2++) {
        const expansion = pre + N2[j2] + post[k2];
        if (!isTop || isSequence || expansion) {
          expansions.push(expansion);
        }
      }
    }
  }
  return expansions;
}

// node_modules/minimatch/dist/esm/assert-valid-pattern.js
var MAX_PATTERN_LENGTH = 1024 * 64;
var assertValidPattern = (pattern) => {
  if (typeof pattern !== "string") {
    throw new TypeError("invalid pattern");
  }
  if (pattern.length > MAX_PATTERN_LENGTH) {
    throw new TypeError("pattern is too long");
  }
};

// node_modules/minimatch/dist/esm/brace-expressions.js
var posixClasses = {
  "[:alnum:]": ["\\p{L}\\p{Nl}\\p{Nd}", true],
  "[:alpha:]": ["\\p{L}\\p{Nl}", true],
  "[:ascii:]": ["\\x00-\\x7f", false],
  "[:blank:]": ["\\p{Zs}\\t", true],
  "[:cntrl:]": ["\\p{Cc}", true],
  "[:digit:]": ["\\p{Nd}", true],
  "[:graph:]": ["\\p{Z}\\p{C}", true, true],
  "[:lower:]": ["\\p{Ll}", true],
  "[:print:]": ["\\p{C}", true],
  "[:punct:]": ["\\p{P}", true],
  "[:space:]": ["\\p{Z}\\t\\r\\n\\v\\f", true],
  "[:upper:]": ["\\p{Lu}", true],
  "[:word:]": ["\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}", true],
  "[:xdigit:]": ["A-Fa-f0-9", false]
};
var braceEscape = (s3) => s3.replace(/[[\]\\-]/g, "\\$&");
var regexpEscape = (s3) => s3.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var rangesToString = (ranges) => ranges.join("");
var parseClass = (glob, position) => {
  const pos = position;
  if (glob.charAt(pos) !== "[") {
    throw new Error("not in a brace expression");
  }
  const ranges = [];
  const negs = [];
  let i3 = pos + 1;
  let sawStart = false;
  let uflag = false;
  let escaping = false;
  let negate2 = false;
  let endPos = pos;
  let rangeStart = "";
  WHILE:
    while (i3 < glob.length) {
      const c3 = glob.charAt(i3);
      if ((c3 === "!" || c3 === "^") && i3 === pos + 1) {
        negate2 = true;
        i3++;
        continue;
      }
      if (c3 === "]" && sawStart && !escaping) {
        endPos = i3 + 1;
        break;
      }
      sawStart = true;
      if (c3 === "\\") {
        if (!escaping) {
          escaping = true;
          i3++;
          continue;
        }
      }
      if (c3 === "[" && !escaping) {
        for (const [cls, [unip, u2, neg]] of Object.entries(posixClasses)) {
          if (glob.startsWith(cls, i3)) {
            if (rangeStart) {
              return ["$.", false, glob.length - pos, true];
            }
            i3 += cls.length;
            if (neg)
              negs.push(unip);
            else
              ranges.push(unip);
            uflag = uflag || u2;
            continue WHILE;
          }
        }
      }
      escaping = false;
      if (rangeStart) {
        if (c3 > rangeStart) {
          ranges.push(braceEscape(rangeStart) + "-" + braceEscape(c3));
        } else if (c3 === rangeStart) {
          ranges.push(braceEscape(c3));
        }
        rangeStart = "";
        i3++;
        continue;
      }
      if (glob.startsWith("-]", i3 + 1)) {
        ranges.push(braceEscape(c3 + "-"));
        i3 += 2;
        continue;
      }
      if (glob.startsWith("-", i3 + 1)) {
        rangeStart = c3;
        i3 += 2;
        continue;
      }
      ranges.push(braceEscape(c3));
      i3++;
    }
  if (endPos < i3) {
    return ["", false, 0, false];
  }
  if (!ranges.length && !negs.length) {
    return ["$.", false, glob.length - pos, true];
  }
  if (negs.length === 0 && ranges.length === 1 && /^\\?.$/.test(ranges[0]) && !negate2) {
    const r3 = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];
    return [regexpEscape(r3), false, endPos - pos, false];
  }
  const sranges = "[" + (negate2 ? "^" : "") + rangesToString(ranges) + "]";
  const snegs = "[" + (negate2 ? "" : "^") + rangesToString(negs) + "]";
  const comb = ranges.length && negs.length ? "(" + sranges + "|" + snegs + ")" : ranges.length ? sranges : snegs;
  return [comb, uflag, endPos - pos, true];
};

// node_modules/minimatch/dist/esm/unescape.js
var unescape = (s3, { windowsPathsNoEscape = false } = {}) => {
  return windowsPathsNoEscape ? s3.replace(/\[([^\/\\])\]/g, "$1") : s3.replace(/((?!\\).|^)\[([^\/\\])\]/g, "$1$2").replace(/\\([^\/])/g, "$1");
};

// node_modules/minimatch/dist/esm/ast.js
var types = /* @__PURE__ */ new Set(["!", "?", "+", "*", "@"]);
var isExtglobType = (c3) => types.has(c3);
var startNoTraversal = "(?!(?:^|/)\\.\\.?(?:$|/))";
var startNoDot = "(?!\\.)";
var addPatternStart = /* @__PURE__ */ new Set(["[", "."]);
var justDots = /* @__PURE__ */ new Set(["..", "."]);
var reSpecials = new Set("().*{}+?[]^$\\!");
var regExpEscape = (s3) => s3.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var qmark = "[^/]";
var star = qmark + "*?";
var starNoEmpty = qmark + "+?";
var _root, _hasMagic, _uflag, _parts, _parent, _parentIndex, _negs, _filledNegs, _options, _toString, _emptyExt, _fillNegs, fillNegs_fn, _parseAST, parseAST_fn, _partsToRegExp, partsToRegExp_fn, _parseGlob, parseGlob_fn;
var _AST = class {
  constructor(type, parent, options = {}) {
    __privateAdd(this, _fillNegs);
    __privateAdd(this, _partsToRegExp);
    __publicField(this, "type");
    __privateAdd(this, _root, void 0);
    __privateAdd(this, _hasMagic, void 0);
    __privateAdd(this, _uflag, false);
    __privateAdd(this, _parts, []);
    __privateAdd(this, _parent, void 0);
    __privateAdd(this, _parentIndex, void 0);
    __privateAdd(this, _negs, void 0);
    __privateAdd(this, _filledNegs, false);
    __privateAdd(this, _options, void 0);
    __privateAdd(this, _toString, void 0);
    __privateAdd(this, _emptyExt, false);
    this.type = type;
    if (type)
      __privateSet(this, _hasMagic, true);
    __privateSet(this, _parent, parent);
    __privateSet(this, _root, __privateGet(this, _parent) ? __privateGet(__privateGet(this, _parent), _root) : this);
    __privateSet(this, _options, __privateGet(this, _root) === this ? options : __privateGet(__privateGet(this, _root), _options));
    __privateSet(this, _negs, __privateGet(this, _root) === this ? [] : __privateGet(__privateGet(this, _root), _negs));
    if (type === "!" && !__privateGet(__privateGet(this, _root), _filledNegs))
      __privateGet(this, _negs).push(this);
    __privateSet(this, _parentIndex, __privateGet(this, _parent) ? __privateGet(__privateGet(this, _parent), _parts).length : 0);
  }
  get hasMagic() {
    if (__privateGet(this, _hasMagic) !== void 0)
      return __privateGet(this, _hasMagic);
    for (const p2 of __privateGet(this, _parts)) {
      if (typeof p2 === "string")
        continue;
      if (p2.type || p2.hasMagic)
        return __privateSet(this, _hasMagic, true);
    }
    return __privateGet(this, _hasMagic);
  }
  toString() {
    if (__privateGet(this, _toString) !== void 0)
      return __privateGet(this, _toString);
    if (!this.type) {
      return __privateSet(this, _toString, __privateGet(this, _parts).map((p2) => String(p2)).join(""));
    } else {
      return __privateSet(this, _toString, this.type + "(" + __privateGet(this, _parts).map((p2) => String(p2)).join("|") + ")");
    }
  }
  push(...parts) {
    for (const p2 of parts) {
      if (p2 === "")
        continue;
      if (typeof p2 !== "string" && !(p2 instanceof _AST && __privateGet(p2, _parent) === this)) {
        throw new Error("invalid part: " + p2);
      }
      __privateGet(this, _parts).push(p2);
    }
  }
  toJSON() {
    var _a;
    const ret = this.type === null ? __privateGet(this, _parts).slice().map((p2) => typeof p2 === "string" ? p2 : p2.toJSON()) : [this.type, ...__privateGet(this, _parts).map((p2) => p2.toJSON())];
    if (this.isStart() && !this.type)
      ret.unshift([]);
    if (this.isEnd() && (this === __privateGet(this, _root) || __privateGet(__privateGet(this, _root), _filledNegs) && ((_a = __privateGet(this, _parent)) == null ? void 0 : _a.type) === "!")) {
      ret.push({});
    }
    return ret;
  }
  isStart() {
    var _a;
    if (__privateGet(this, _root) === this)
      return true;
    if (!((_a = __privateGet(this, _parent)) == null ? void 0 : _a.isStart()))
      return false;
    if (__privateGet(this, _parentIndex) === 0)
      return true;
    const p2 = __privateGet(this, _parent);
    for (let i3 = 0; i3 < __privateGet(this, _parentIndex); i3++) {
      const pp = __privateGet(p2, _parts)[i3];
      if (!(pp instanceof _AST && pp.type === "!")) {
        return false;
      }
    }
    return true;
  }
  isEnd() {
    var _a, _b, _c;
    if (__privateGet(this, _root) === this)
      return true;
    if (((_a = __privateGet(this, _parent)) == null ? void 0 : _a.type) === "!")
      return true;
    if (!((_b = __privateGet(this, _parent)) == null ? void 0 : _b.isEnd()))
      return false;
    if (!this.type)
      return (_c = __privateGet(this, _parent)) == null ? void 0 : _c.isEnd();
    const pl = __privateGet(this, _parent) ? __privateGet(__privateGet(this, _parent), _parts).length : 0;
    return __privateGet(this, _parentIndex) === pl - 1;
  }
  copyIn(part) {
    if (typeof part === "string")
      this.push(part);
    else
      this.push(part.clone(this));
  }
  clone(parent) {
    const c3 = new _AST(this.type, parent);
    for (const p2 of __privateGet(this, _parts)) {
      c3.copyIn(p2);
    }
    return c3;
  }
  static fromGlob(pattern, options = {}) {
    var _a;
    const ast = new _AST(null, void 0, options);
    __privateMethod(_a = _AST, _parseAST, parseAST_fn).call(_a, pattern, ast, 0, options);
    return ast;
  }
  toMMPattern() {
    if (this !== __privateGet(this, _root))
      return __privateGet(this, _root).toMMPattern();
    const glob = this.toString();
    const [re, body, hasMagic, uflag] = this.toRegExpSource();
    const anyMagic = hasMagic || __privateGet(this, _hasMagic) || __privateGet(this, _options).nocase && !__privateGet(this, _options).nocaseMagicOnly && glob.toUpperCase() !== glob.toLowerCase();
    if (!anyMagic) {
      return body;
    }
    const flags = (__privateGet(this, _options).nocase ? "i" : "") + (uflag ? "u" : "");
    return Object.assign(new RegExp(`^${re}$`, flags), {
      _src: re,
      _glob: glob
    });
  }
  get options() {
    return __privateGet(this, _options);
  }
  toRegExpSource(allowDot) {
    var _a;
    const dot = allowDot != null ? allowDot : !!__privateGet(this, _options).dot;
    if (__privateGet(this, _root) === this)
      __privateMethod(this, _fillNegs, fillNegs_fn).call(this);
    if (!this.type) {
      const noEmpty = this.isStart() && this.isEnd();
      const src = __privateGet(this, _parts).map((p2) => {
        var _a2;
        const [re, _, hasMagic, uflag] = typeof p2 === "string" ? __privateMethod(_a2 = _AST, _parseGlob, parseGlob_fn).call(_a2, p2, __privateGet(this, _hasMagic), noEmpty) : p2.toRegExpSource(allowDot);
        __privateSet(this, _hasMagic, __privateGet(this, _hasMagic) || hasMagic);
        __privateSet(this, _uflag, __privateGet(this, _uflag) || uflag);
        return re;
      }).join("");
      let start2 = "";
      if (this.isStart()) {
        if (typeof __privateGet(this, _parts)[0] === "string") {
          const dotTravAllowed = __privateGet(this, _parts).length === 1 && justDots.has(__privateGet(this, _parts)[0]);
          if (!dotTravAllowed) {
            const aps = addPatternStart;
            const needNoTrav = dot && aps.has(src.charAt(0)) || src.startsWith("\\.") && aps.has(src.charAt(2)) || src.startsWith("\\.\\.") && aps.has(src.charAt(4));
            const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));
            start2 = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : "";
          }
        }
      }
      let end = "";
      if (this.isEnd() && __privateGet(__privateGet(this, _root), _filledNegs) && ((_a = __privateGet(this, _parent)) == null ? void 0 : _a.type) === "!") {
        end = "(?:$|\\/)";
      }
      const final2 = start2 + src + end;
      return [
        final2,
        unescape(src),
        __privateSet(this, _hasMagic, !!__privateGet(this, _hasMagic)),
        __privateGet(this, _uflag)
      ];
    }
    const repeated = this.type === "*" || this.type === "+";
    const start = this.type === "!" ? "(?:(?!(?:" : "(?:";
    let body = __privateMethod(this, _partsToRegExp, partsToRegExp_fn).call(this, dot);
    if (this.isStart() && this.isEnd() && !body && this.type !== "!") {
      const s3 = this.toString();
      __privateSet(this, _parts, [s3]);
      this.type = null;
      __privateSet(this, _hasMagic, void 0);
      return [s3, unescape(this.toString()), false, false];
    }
    let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot ? "" : __privateMethod(this, _partsToRegExp, partsToRegExp_fn).call(this, true);
    if (bodyDotAllowed === body) {
      bodyDotAllowed = "";
    }
    if (bodyDotAllowed) {
      body = `(?:${body})(?:${bodyDotAllowed})*?`;
    }
    let final = "";
    if (this.type === "!" && __privateGet(this, _emptyExt)) {
      final = (this.isStart() && !dot ? startNoDot : "") + starNoEmpty;
    } else {
      const close = this.type === "!" ? "))" + (this.isStart() && !dot && !allowDot ? startNoDot : "") + star + ")" : this.type === "@" ? ")" : this.type === "?" ? ")?" : this.type === "+" && bodyDotAllowed ? ")" : this.type === "*" && bodyDotAllowed ? `)?` : `)${this.type}`;
      final = start + body + close;
    }
    return [
      final,
      unescape(body),
      __privateSet(this, _hasMagic, !!__privateGet(this, _hasMagic)),
      __privateGet(this, _uflag)
    ];
  }
};
var AST = _AST;
_root = new WeakMap();
_hasMagic = new WeakMap();
_uflag = new WeakMap();
_parts = new WeakMap();
_parent = new WeakMap();
_parentIndex = new WeakMap();
_negs = new WeakMap();
_filledNegs = new WeakMap();
_options = new WeakMap();
_toString = new WeakMap();
_emptyExt = new WeakMap();
_fillNegs = new WeakSet();
fillNegs_fn = function() {
  if (this !== __privateGet(this, _root))
    throw new Error("should only call on root");
  if (__privateGet(this, _filledNegs))
    return this;
  this.toString();
  __privateSet(this, _filledNegs, true);
  let n2;
  while (n2 = __privateGet(this, _negs).pop()) {
    if (n2.type !== "!")
      continue;
    let p2 = n2;
    let pp = __privateGet(p2, _parent);
    while (pp) {
      for (let i3 = __privateGet(p2, _parentIndex) + 1; !pp.type && i3 < __privateGet(pp, _parts).length; i3++) {
        for (const part of __privateGet(n2, _parts)) {
          if (typeof part === "string") {
            throw new Error("string part in extglob AST??");
          }
          part.copyIn(__privateGet(pp, _parts)[i3]);
        }
      }
      p2 = pp;
      pp = __privateGet(p2, _parent);
    }
  }
  return this;
};
_parseAST = new WeakSet();
parseAST_fn = function(str, ast, pos, opt) {
  var _a, _b;
  let escaping = false;
  let inBrace = false;
  let braceStart = -1;
  let braceNeg = false;
  if (ast.type === null) {
    let i4 = pos;
    let acc2 = "";
    while (i4 < str.length) {
      const c3 = str.charAt(i4++);
      if (escaping || c3 === "\\") {
        escaping = !escaping;
        acc2 += c3;
        continue;
      }
      if (inBrace) {
        if (i4 === braceStart + 1) {
          if (c3 === "^" || c3 === "!") {
            braceNeg = true;
          }
        } else if (c3 === "]" && !(i4 === braceStart + 2 && braceNeg)) {
          inBrace = false;
        }
        acc2 += c3;
        continue;
      } else if (c3 === "[") {
        inBrace = true;
        braceStart = i4;
        braceNeg = false;
        acc2 += c3;
        continue;
      }
      if (!opt.noext && isExtglobType(c3) && str.charAt(i4) === "(") {
        ast.push(acc2);
        acc2 = "";
        const ext2 = new _AST(c3, ast);
        i4 = __privateMethod(_a = _AST, _parseAST, parseAST_fn).call(_a, str, ext2, i4, opt);
        ast.push(ext2);
        continue;
      }
      acc2 += c3;
    }
    ast.push(acc2);
    return i4;
  }
  let i3 = pos + 1;
  let part = new _AST(null, ast);
  const parts = [];
  let acc = "";
  while (i3 < str.length) {
    const c3 = str.charAt(i3++);
    if (escaping || c3 === "\\") {
      escaping = !escaping;
      acc += c3;
      continue;
    }
    if (inBrace) {
      if (i3 === braceStart + 1) {
        if (c3 === "^" || c3 === "!") {
          braceNeg = true;
        }
      } else if (c3 === "]" && !(i3 === braceStart + 2 && braceNeg)) {
        inBrace = false;
      }
      acc += c3;
      continue;
    } else if (c3 === "[") {
      inBrace = true;
      braceStart = i3;
      braceNeg = false;
      acc += c3;
      continue;
    }
    if (isExtglobType(c3) && str.charAt(i3) === "(") {
      part.push(acc);
      acc = "";
      const ext2 = new _AST(c3, part);
      part.push(ext2);
      i3 = __privateMethod(_b = _AST, _parseAST, parseAST_fn).call(_b, str, ext2, i3, opt);
      continue;
    }
    if (c3 === "|") {
      part.push(acc);
      acc = "";
      parts.push(part);
      part = new _AST(null, ast);
      continue;
    }
    if (c3 === ")") {
      if (acc === "" && __privateGet(ast, _parts).length === 0) {
        __privateSet(ast, _emptyExt, true);
      }
      part.push(acc);
      acc = "";
      ast.push(...parts, part);
      return i3;
    }
    acc += c3;
  }
  ast.type = null;
  __privateSet(ast, _hasMagic, void 0);
  __privateSet(ast, _parts, [str.substring(pos - 1)]);
  return i3;
};
_partsToRegExp = new WeakSet();
partsToRegExp_fn = function(dot) {
  return __privateGet(this, _parts).map((p2) => {
    if (typeof p2 === "string") {
      throw new Error("string type in extglob ast??");
    }
    const [re, _, _hasMagic2, uflag] = p2.toRegExpSource(dot);
    __privateSet(this, _uflag, __privateGet(this, _uflag) || uflag);
    return re;
  }).filter((p2) => !(this.isStart() && this.isEnd()) || !!p2).join("|");
};
_parseGlob = new WeakSet();
parseGlob_fn = function(glob, hasMagic, noEmpty = false) {
  let escaping = false;
  let re = "";
  let uflag = false;
  for (let i3 = 0; i3 < glob.length; i3++) {
    const c3 = glob.charAt(i3);
    if (escaping) {
      escaping = false;
      re += (reSpecials.has(c3) ? "\\" : "") + c3;
      continue;
    }
    if (c3 === "\\") {
      if (i3 === glob.length - 1) {
        re += "\\\\";
      } else {
        escaping = true;
      }
      continue;
    }
    if (c3 === "[") {
      const [src, needUflag, consumed, magic] = parseClass(glob, i3);
      if (consumed) {
        re += src;
        uflag = uflag || needUflag;
        i3 += consumed - 1;
        hasMagic = hasMagic || magic;
        continue;
      }
    }
    if (c3 === "*") {
      if (noEmpty && glob === "*")
        re += starNoEmpty;
      else
        re += star;
      hasMagic = true;
      continue;
    }
    if (c3 === "?") {
      re += qmark;
      hasMagic = true;
      continue;
    }
    re += regExpEscape(c3);
  }
  return [re, unescape(glob), !!hasMagic, uflag];
};
__privateAdd(AST, _parseAST);
__privateAdd(AST, _parseGlob);

// node_modules/minimatch/dist/esm/escape.js
var escape = (s3, { windowsPathsNoEscape = false } = {}) => {
  return windowsPathsNoEscape ? s3.replace(/[?*()[\]]/g, "[$&]") : s3.replace(/[?*()[\]\\]/g, "\\$&");
};

// node_modules/minimatch/dist/esm/index.js
var minimatch = (p2, pattern, options = {}) => {
  assertValidPattern(pattern);
  if (!options.nocomment && pattern.charAt(0) === "#") {
    return false;
  }
  return new Minimatch(pattern, options).match(p2);
};
var starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/;
var starDotExtTest = (ext2) => (f3) => !f3.startsWith(".") && f3.endsWith(ext2);
var starDotExtTestDot = (ext2) => (f3) => f3.endsWith(ext2);
var starDotExtTestNocase = (ext2) => {
  ext2 = ext2.toLowerCase();
  return (f3) => !f3.startsWith(".") && f3.toLowerCase().endsWith(ext2);
};
var starDotExtTestNocaseDot = (ext2) => {
  ext2 = ext2.toLowerCase();
  return (f3) => f3.toLowerCase().endsWith(ext2);
};
var starDotStarRE = /^\*+\.\*+$/;
var starDotStarTest = (f3) => !f3.startsWith(".") && f3.includes(".");
var starDotStarTestDot = (f3) => f3 !== "." && f3 !== ".." && f3.includes(".");
var dotStarRE = /^\.\*+$/;
var dotStarTest = (f3) => f3 !== "." && f3 !== ".." && f3.startsWith(".");
var starRE = /^\*+$/;
var starTest = (f3) => f3.length !== 0 && !f3.startsWith(".");
var starTestDot = (f3) => f3.length !== 0 && f3 !== "." && f3 !== "..";
var qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/;
var qmarksTestNocase = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExt([$0]);
  if (!ext2)
    return noext;
  ext2 = ext2.toLowerCase();
  return (f3) => noext(f3) && f3.toLowerCase().endsWith(ext2);
};
var qmarksTestNocaseDot = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExtDot([$0]);
  if (!ext2)
    return noext;
  ext2 = ext2.toLowerCase();
  return (f3) => noext(f3) && f3.toLowerCase().endsWith(ext2);
};
var qmarksTestDot = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExtDot([$0]);
  return !ext2 ? noext : (f3) => noext(f3) && f3.endsWith(ext2);
};
var qmarksTest = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExt([$0]);
  return !ext2 ? noext : (f3) => noext(f3) && f3.endsWith(ext2);
};
var qmarksTestNoExt = ([$0]) => {
  const len = $0.length;
  return (f3) => f3.length === len && !f3.startsWith(".");
};
var qmarksTestNoExtDot = ([$0]) => {
  const len = $0.length;
  return (f3) => f3.length === len && f3 !== "." && f3 !== "..";
};
var defaultPlatform = typeof process === "object" && process ? typeof process.env === "object" && process.env && process.env.__MINIMATCH_TESTING_PLATFORM__ || process.platform : "posix";
var path = {
  win32: { sep: "\\" },
  posix: { sep: "/" }
};
var sep = defaultPlatform === "win32" ? path.win32.sep : path.posix.sep;
minimatch.sep = sep;
var GLOBSTAR = Symbol("globstar **");
minimatch.GLOBSTAR = GLOBSTAR;
var qmark2 = "[^/]";
var star2 = qmark2 + "*?";
var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
var filter = (pattern, options = {}) => (p2) => minimatch(p2, pattern, options);
minimatch.filter = filter;
var ext = (a3, b2 = {}) => Object.assign({}, a3, b2);
var defaults = (def) => {
  if (!def || typeof def !== "object" || !Object.keys(def).length) {
    return minimatch;
  }
  const orig = minimatch;
  const m2 = (p2, pattern, options = {}) => orig(p2, pattern, ext(def, options));
  return Object.assign(m2, {
    Minimatch: class Minimatch extends orig.Minimatch {
      constructor(pattern, options = {}) {
        super(pattern, ext(def, options));
      }
      static defaults(options) {
        return orig.defaults(ext(def, options)).Minimatch;
      }
    },
    AST: class AST extends orig.AST {
      constructor(type, parent, options = {}) {
        super(type, parent, ext(def, options));
      }
      static fromGlob(pattern, options = {}) {
        return orig.AST.fromGlob(pattern, ext(def, options));
      }
    },
    unescape: (s3, options = {}) => orig.unescape(s3, ext(def, options)),
    escape: (s3, options = {}) => orig.escape(s3, ext(def, options)),
    filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),
    defaults: (options) => orig.defaults(ext(def, options)),
    makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),
    braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),
    match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),
    sep: orig.sep,
    GLOBSTAR
  });
};
minimatch.defaults = defaults;
var braceExpand = (pattern, options = {}) => {
  assertValidPattern(pattern);
  if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
    return [pattern];
  }
  return expand(pattern);
};
minimatch.braceExpand = braceExpand;
var makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();
minimatch.makeRe = makeRe;
var match = (list, pattern, options = {}) => {
  const mm = new Minimatch(pattern, options);
  list = list.filter((f3) => mm.match(f3));
  if (mm.options.nonull && !list.length) {
    list.push(pattern);
  }
  return list;
};
minimatch.match = match;
var globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/;
var regExpEscape2 = (s3) => s3.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var Minimatch = class {
  constructor(pattern, options = {}) {
    __publicField(this, "options");
    __publicField(this, "set");
    __publicField(this, "pattern");
    __publicField(this, "windowsPathsNoEscape");
    __publicField(this, "nonegate");
    __publicField(this, "negate");
    __publicField(this, "comment");
    __publicField(this, "empty");
    __publicField(this, "preserveMultipleSlashes");
    __publicField(this, "partial");
    __publicField(this, "globSet");
    __publicField(this, "globParts");
    __publicField(this, "nocase");
    __publicField(this, "isWindows");
    __publicField(this, "platform");
    __publicField(this, "windowsNoMagicRoot");
    __publicField(this, "regexp");
    assertValidPattern(pattern);
    options = options || {};
    this.options = options;
    this.pattern = pattern;
    this.platform = options.platform || defaultPlatform;
    this.isWindows = this.platform === "win32";
    this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
    if (this.windowsPathsNoEscape) {
      this.pattern = this.pattern.replace(/\\/g, "/");
    }
    this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;
    this.regexp = null;
    this.negate = false;
    this.nonegate = !!options.nonegate;
    this.comment = false;
    this.empty = false;
    this.partial = !!options.partial;
    this.nocase = !!this.options.nocase;
    this.windowsNoMagicRoot = options.windowsNoMagicRoot !== void 0 ? options.windowsNoMagicRoot : !!(this.isWindows && this.nocase);
    this.globSet = [];
    this.globParts = [];
    this.set = [];
    this.make();
  }
  hasMagic() {
    if (this.options.magicalBraces && this.set.length > 1) {
      return true;
    }
    for (const pattern of this.set) {
      for (const part of pattern) {
        if (typeof part !== "string")
          return true;
      }
    }
    return false;
  }
  debug(..._) {
  }
  make() {
    const pattern = this.pattern;
    const options = this.options;
    if (!options.nocomment && pattern.charAt(0) === "#") {
      this.comment = true;
      return;
    }
    if (!pattern) {
      this.empty = true;
      return;
    }
    this.parseNegate();
    this.globSet = [...new Set(this.braceExpand())];
    if (options.debug) {
      this.debug = (...args) => console.error(...args);
    }
    this.debug(this.pattern, this.globSet);
    const rawGlobParts = this.globSet.map((s3) => this.slashSplit(s3));
    this.globParts = this.preprocess(rawGlobParts);
    this.debug(this.pattern, this.globParts);
    let set = this.globParts.map((s3, _, __) => {
      if (this.isWindows && this.windowsNoMagicRoot) {
        const isUNC = s3[0] === "" && s3[1] === "" && (s3[2] === "?" || !globMagic.test(s3[2])) && !globMagic.test(s3[3]);
        const isDrive = /^[a-z]:/i.test(s3[0]);
        if (isUNC) {
          return [...s3.slice(0, 4), ...s3.slice(4).map((ss) => this.parse(ss))];
        } else if (isDrive) {
          return [s3[0], ...s3.slice(1).map((ss) => this.parse(ss))];
        }
      }
      return s3.map((ss) => this.parse(ss));
    });
    this.debug(this.pattern, set);
    this.set = set.filter((s3) => s3.indexOf(false) === -1);
    if (this.isWindows) {
      for (let i3 = 0; i3 < this.set.length; i3++) {
        const p2 = this.set[i3];
        if (p2[0] === "" && p2[1] === "" && this.globParts[i3][2] === "?" && typeof p2[3] === "string" && /^[a-z]:$/i.test(p2[3])) {
          p2[2] = "?";
        }
      }
    }
    this.debug(this.pattern, this.set);
  }
  preprocess(globParts) {
    if (this.options.noglobstar) {
      for (let i3 = 0; i3 < globParts.length; i3++) {
        for (let j2 = 0; j2 < globParts[i3].length; j2++) {
          if (globParts[i3][j2] === "**") {
            globParts[i3][j2] = "*";
          }
        }
      }
    }
    const { optimizationLevel = 1 } = this.options;
    if (optimizationLevel >= 2) {
      globParts = this.firstPhasePreProcess(globParts);
      globParts = this.secondPhasePreProcess(globParts);
    } else if (optimizationLevel >= 1) {
      globParts = this.levelOneOptimize(globParts);
    } else {
      globParts = this.adjascentGlobstarOptimize(globParts);
    }
    return globParts;
  }
  adjascentGlobstarOptimize(globParts) {
    return globParts.map((parts) => {
      let gs = -1;
      while ((gs = parts.indexOf("**", gs + 1)) !== -1) {
        let i3 = gs;
        while (parts[i3 + 1] === "**") {
          i3++;
        }
        if (i3 !== gs) {
          parts.splice(gs, i3 - gs);
        }
      }
      return parts;
    });
  }
  levelOneOptimize(globParts) {
    return globParts.map((parts) => {
      parts = parts.reduce((set, part) => {
        const prev = set[set.length - 1];
        if (part === "**" && prev === "**") {
          return set;
        }
        if (part === "..") {
          if (prev && prev !== ".." && prev !== "." && prev !== "**") {
            set.pop();
            return set;
          }
        }
        set.push(part);
        return set;
      }, []);
      return parts.length === 0 ? [""] : parts;
    });
  }
  levelTwoFileOptimize(parts) {
    if (!Array.isArray(parts)) {
      parts = this.slashSplit(parts);
    }
    let didSomething = false;
    do {
      didSomething = false;
      if (!this.preserveMultipleSlashes) {
        for (let i3 = 1; i3 < parts.length - 1; i3++) {
          const p2 = parts[i3];
          if (i3 === 1 && p2 === "" && parts[0] === "")
            continue;
          if (p2 === "." || p2 === "") {
            didSomething = true;
            parts.splice(i3, 1);
            i3--;
          }
        }
        if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
          didSomething = true;
          parts.pop();
        }
      }
      let dd = 0;
      while ((dd = parts.indexOf("..", dd + 1)) !== -1) {
        const p2 = parts[dd - 1];
        if (p2 && p2 !== "." && p2 !== ".." && p2 !== "**") {
          didSomething = true;
          parts.splice(dd - 1, 2);
          dd -= 2;
        }
      }
    } while (didSomething);
    return parts.length === 0 ? [""] : parts;
  }
  firstPhasePreProcess(globParts) {
    let didSomething = false;
    do {
      didSomething = false;
      for (let parts of globParts) {
        let gs = -1;
        while ((gs = parts.indexOf("**", gs + 1)) !== -1) {
          let gss = gs;
          while (parts[gss + 1] === "**") {
            gss++;
          }
          if (gss > gs) {
            parts.splice(gs + 1, gss - gs);
          }
          let next = parts[gs + 1];
          const p2 = parts[gs + 2];
          const p22 = parts[gs + 3];
          if (next !== "..")
            continue;
          if (!p2 || p2 === "." || p2 === ".." || !p22 || p22 === "." || p22 === "..") {
            continue;
          }
          didSomething = true;
          parts.splice(gs, 1);
          const other = parts.slice(0);
          other[gs] = "**";
          globParts.push(other);
          gs--;
        }
        if (!this.preserveMultipleSlashes) {
          for (let i3 = 1; i3 < parts.length - 1; i3++) {
            const p2 = parts[i3];
            if (i3 === 1 && p2 === "" && parts[0] === "")
              continue;
            if (p2 === "." || p2 === "") {
              didSomething = true;
              parts.splice(i3, 1);
              i3--;
            }
          }
          if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
            didSomething = true;
            parts.pop();
          }
        }
        let dd = 0;
        while ((dd = parts.indexOf("..", dd + 1)) !== -1) {
          const p2 = parts[dd - 1];
          if (p2 && p2 !== "." && p2 !== ".." && p2 !== "**") {
            didSomething = true;
            const needDot = dd === 1 && parts[dd + 1] === "**";
            const splin = needDot ? ["."] : [];
            parts.splice(dd - 1, 2, ...splin);
            if (parts.length === 0)
              parts.push("");
            dd -= 2;
          }
        }
      }
    } while (didSomething);
    return globParts;
  }
  secondPhasePreProcess(globParts) {
    for (let i3 = 0; i3 < globParts.length - 1; i3++) {
      for (let j2 = i3 + 1; j2 < globParts.length; j2++) {
        const matched = this.partsMatch(globParts[i3], globParts[j2], !this.preserveMultipleSlashes);
        if (matched) {
          globParts[i3] = [];
          globParts[j2] = matched;
          break;
        }
      }
    }
    return globParts.filter((gs) => gs.length);
  }
  partsMatch(a3, b2, emptyGSMatch = false) {
    let ai2 = 0;
    let bi2 = 0;
    let result = [];
    let which = "";
    while (ai2 < a3.length && bi2 < b2.length) {
      if (a3[ai2] === b2[bi2]) {
        result.push(which === "b" ? b2[bi2] : a3[ai2]);
        ai2++;
        bi2++;
      } else if (emptyGSMatch && a3[ai2] === "**" && b2[bi2] === a3[ai2 + 1]) {
        result.push(a3[ai2]);
        ai2++;
      } else if (emptyGSMatch && b2[bi2] === "**" && a3[ai2] === b2[bi2 + 1]) {
        result.push(b2[bi2]);
        bi2++;
      } else if (a3[ai2] === "*" && b2[bi2] && (this.options.dot || !b2[bi2].startsWith(".")) && b2[bi2] !== "**") {
        if (which === "b")
          return false;
        which = "a";
        result.push(a3[ai2]);
        ai2++;
        bi2++;
      } else if (b2[bi2] === "*" && a3[ai2] && (this.options.dot || !a3[ai2].startsWith(".")) && a3[ai2] !== "**") {
        if (which === "a")
          return false;
        which = "b";
        result.push(b2[bi2]);
        ai2++;
        bi2++;
      } else {
        return false;
      }
    }
    return a3.length === b2.length && result;
  }
  parseNegate() {
    if (this.nonegate)
      return;
    const pattern = this.pattern;
    let negate2 = false;
    let negateOffset = 0;
    for (let i3 = 0; i3 < pattern.length && pattern.charAt(i3) === "!"; i3++) {
      negate2 = !negate2;
      negateOffset++;
    }
    if (negateOffset)
      this.pattern = pattern.slice(negateOffset);
    this.negate = negate2;
  }
  matchOne(file, pattern, partial = false) {
    const options = this.options;
    if (this.isWindows) {
      const fileDrive = typeof file[0] === "string" && /^[a-z]:$/i.test(file[0]);
      const fileUNC = !fileDrive && file[0] === "" && file[1] === "" && file[2] === "?" && /^[a-z]:$/i.test(file[3]);
      const patternDrive = typeof pattern[0] === "string" && /^[a-z]:$/i.test(pattern[0]);
      const patternUNC = !patternDrive && pattern[0] === "" && pattern[1] === "" && pattern[2] === "?" && typeof pattern[3] === "string" && /^[a-z]:$/i.test(pattern[3]);
      const fdi = fileUNC ? 3 : fileDrive ? 0 : void 0;
      const pdi = patternUNC ? 3 : patternDrive ? 0 : void 0;
      if (typeof fdi === "number" && typeof pdi === "number") {
        const [fd, pd] = [file[fdi], pattern[pdi]];
        if (fd.toLowerCase() === pd.toLowerCase()) {
          pattern[pdi] = fd;
          if (pdi > fdi) {
            pattern = pattern.slice(pdi);
          } else if (fdi > pdi) {
            file = file.slice(fdi);
          }
        }
      }
    }
    const { optimizationLevel = 1 } = this.options;
    if (optimizationLevel >= 2) {
      file = this.levelTwoFileOptimize(file);
    }
    this.debug("matchOne", this, { file, pattern });
    this.debug("matchOne", file.length, pattern.length);
    for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
      this.debug("matchOne loop");
      var p2 = pattern[pi];
      var f3 = file[fi];
      this.debug(pattern, p2, f3);
      if (p2 === false) {
        return false;
      }
      if (p2 === GLOBSTAR) {
        this.debug("GLOBSTAR", [pattern, p2, f3]);
        var fr = fi;
        var pr = pi + 1;
        if (pr === pl) {
          this.debug("** at the end");
          for (; fi < fl; fi++) {
            if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
              return false;
          }
          return true;
        }
        while (fr < fl) {
          var swallowee = file[fr];
          this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
            this.debug("globstar found match!", fr, fl, swallowee);
            return true;
          } else {
            if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
              this.debug("dot detected!", file, fr, pattern, pr);
              break;
            }
            this.debug("globstar swallow a segment, and continue");
            fr++;
          }
        }
        if (partial) {
          this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
          if (fr === fl) {
            return true;
          }
        }
        return false;
      }
      let hit;
      if (typeof p2 === "string") {
        hit = f3 === p2;
        this.debug("string match", p2, f3, hit);
      } else {
        hit = p2.test(f3);
        this.debug("pattern match", p2, f3, hit);
      }
      if (!hit)
        return false;
    }
    if (fi === fl && pi === pl) {
      return true;
    } else if (fi === fl) {
      return partial;
    } else if (pi === pl) {
      return fi === fl - 1 && file[fi] === "";
    } else {
      throw new Error("wtf?");
    }
  }
  braceExpand() {
    return braceExpand(this.pattern, this.options);
  }
  parse(pattern) {
    assertValidPattern(pattern);
    const options = this.options;
    if (pattern === "**")
      return GLOBSTAR;
    if (pattern === "")
      return "";
    let m2;
    let fastTest = null;
    if (m2 = pattern.match(starRE)) {
      fastTest = options.dot ? starTestDot : starTest;
    } else if (m2 = pattern.match(starDotExtRE)) {
      fastTest = (options.nocase ? options.dot ? starDotExtTestNocaseDot : starDotExtTestNocase : options.dot ? starDotExtTestDot : starDotExtTest)(m2[1]);
    } else if (m2 = pattern.match(qmarksRE)) {
      fastTest = (options.nocase ? options.dot ? qmarksTestNocaseDot : qmarksTestNocase : options.dot ? qmarksTestDot : qmarksTest)(m2);
    } else if (m2 = pattern.match(starDotStarRE)) {
      fastTest = options.dot ? starDotStarTestDot : starDotStarTest;
    } else if (m2 = pattern.match(dotStarRE)) {
      fastTest = dotStarTest;
    }
    const re = AST.fromGlob(pattern, this.options).toMMPattern();
    if (fastTest && typeof re === "object") {
      Reflect.defineProperty(re, "test", { value: fastTest });
    }
    return re;
  }
  makeRe() {
    if (this.regexp || this.regexp === false)
      return this.regexp;
    const set = this.set;
    if (!set.length) {
      this.regexp = false;
      return this.regexp;
    }
    const options = this.options;
    const twoStar = options.noglobstar ? star2 : options.dot ? twoStarDot : twoStarNoDot;
    const flags = new Set(options.nocase ? ["i"] : []);
    let re = set.map((pattern) => {
      const pp = pattern.map((p2) => {
        if (p2 instanceof RegExp) {
          for (const f3 of p2.flags.split(""))
            flags.add(f3);
        }
        return typeof p2 === "string" ? regExpEscape2(p2) : p2 === GLOBSTAR ? GLOBSTAR : p2._src;
      });
      pp.forEach((p2, i3) => {
        const next = pp[i3 + 1];
        const prev = pp[i3 - 1];
        if (p2 !== GLOBSTAR || prev === GLOBSTAR) {
          return;
        }
        if (prev === void 0) {
          if (next !== void 0 && next !== GLOBSTAR) {
            pp[i3 + 1] = "(?:\\/|" + twoStar + "\\/)?" + next;
          } else {
            pp[i3] = twoStar;
          }
        } else if (next === void 0) {
          pp[i3 - 1] = prev + "(?:\\/|" + twoStar + ")?";
        } else if (next !== GLOBSTAR) {
          pp[i3 - 1] = prev + "(?:\\/|\\/" + twoStar + "\\/)" + next;
          pp[i3 + 1] = GLOBSTAR;
        }
      });
      return pp.filter((p2) => p2 !== GLOBSTAR).join("/");
    }).join("|");
    const [open, close] = set.length > 1 ? ["(?:", ")"] : ["", ""];
    re = "^" + open + re + close + "$";
    if (this.negate)
      re = "^(?!" + re + ").+$";
    try {
      this.regexp = new RegExp(re, [...flags].join(""));
    } catch (ex) {
      this.regexp = false;
    }
    return this.regexp;
  }
  slashSplit(p2) {
    if (this.preserveMultipleSlashes) {
      return p2.split("/");
    } else if (this.isWindows && /^\/\/[^\/]+/.test(p2)) {
      return ["", ...p2.split(/\/+/)];
    } else {
      return p2.split(/\/+/);
    }
  }
  match(f3, partial = this.partial) {
    this.debug("match", f3, this.pattern);
    if (this.comment) {
      return false;
    }
    if (this.empty) {
      return f3 === "";
    }
    if (f3 === "/" && partial) {
      return true;
    }
    const options = this.options;
    if (this.isWindows) {
      f3 = f3.split("\\").join("/");
    }
    const ff2 = this.slashSplit(f3);
    this.debug(this.pattern, "split", ff2);
    const set = this.set;
    this.debug(this.pattern, "set", set);
    let filename = ff2[ff2.length - 1];
    if (!filename) {
      for (let i3 = ff2.length - 2; !filename && i3 >= 0; i3--) {
        filename = ff2[i3];
      }
    }
    for (let i3 = 0; i3 < set.length; i3++) {
      const pattern = set[i3];
      let file = ff2;
      if (options.matchBase && pattern.length === 1) {
        file = [filename];
      }
      const hit = this.matchOne(file, pattern, partial);
      if (hit) {
        if (options.flipNegate) {
          return true;
        }
        return !this.negate;
      }
    }
    if (options.flipNegate) {
      return false;
    }
    return this.negate;
  }
  static defaults(def) {
    return minimatch.defaults(def).Minimatch;
  }
};
minimatch.AST = AST;
minimatch.Minimatch = Minimatch;
minimatch.escape = escape;
minimatch.unescape = unescape;

// main.ts
var DEFAULT_SETTINGS = {
  accessKey: "",
  secretKey: "",
  region: "",
  bucket: "",
  folder: "",
  imageUrlPath: "",
  uploadOnDrag: true,
  localUpload: false,
  localUploadFolder: "",
  useCustomEndpoint: false,
  customEndpoint: "",
  forcePathStyle: false,
  useCustomImageUrl: false,
  customImageUrl: "",
  uploadVideo: false,
  uploadAudio: false,
  uploadPdf: false,
  bypassCors: false,
  queryStringValue: "",
  queryStringKey: "",
  enableImageCompression: false,
  maxImageCompressionSize: 1,
  imageCompressionQuality: 0.7,
  maxImageWidthOrHeight: 4096,
  ignorePattern: "",
  disableAutoUploadOnCreate: false
};
var S3UploaderPlugin = class extends import_obsidian.Plugin {
  async replaceText(editor, target, replacement) {
    const content = editor.getValue();
    const position = content.indexOf(target);
    console.log("replaceText called:", { target, replacement });
    if (position !== -1) {
      console.log("Target found at position:", position);
      const surroundingBefore = content.substring(Math.max(0, position - 20), position);
      const surroundingAfter = content.substring(position + target.length, Math.min(content.length, position + target.length + 20));
      console.log("Surrounding text:", {
        before: surroundingBefore,
        after: surroundingAfter
      });
      const isInTable = surroundingBefore.includes("|") && surroundingAfter.includes("|");
      console.log("Is in table:", isInTable);
      if (isInTable) {
        const from = editor.offsetToPos(position);
        const to = editor.offsetToPos(position + target.length);
        console.log("Table replacement positions:", { from, to });
        try {
          editor.transaction({
            changes: [
              {
                from,
                to,
                text: replacement
              }
            ]
          });
          console.log("Table transaction completed");
          setTimeout(() => {
            try {
              editor.refresh();
              console.log("Editor refreshed");
            } catch (e3) {
              console.error("Error refreshing editor:", e3);
            }
          }, 100);
        } catch (e3) {
          console.error("Error during table transaction:", e3);
        }
      } else {
        const from = editor.offsetToPos(position);
        const to = editor.offsetToPos(position + target.length);
        console.log("Normal replacement positions:", { from, to });
        try {
          editor.transaction({
            changes: [
              {
                from,
                to,
                text: replacement
              }
            ]
          });
          console.log("Normal transaction completed");
        } catch (e3) {
          console.error("Error during normal transaction:", e3);
        }
      }
    } else {
      console.log("Target not found in content");
    }
  }
  shouldIgnoreCurrentFile() {
    const noteFile = this.app.workspace.getActiveFile();
    if (!noteFile || !this.settings.ignorePattern) {
      return false;
    }
    const filePath = noteFile.path;
    return matchesGlobPattern(filePath, this.settings.ignorePattern);
  }
  async uploadFile(file, key) {
    if (!this.s3) {
      throw new Error("S3 client not configured. Please configure the plugin settings first.");
    }
    const buf = await file.arrayBuffer();
    await this.s3.send(new PutObjectCommand({
      Bucket: this.settings.bucket,
      Key: key,
      Body: new Uint8Array(buf),
      ContentType: file.type
    }));
    let urlString = this.settings.imageUrlPath + key;
    if (this.settings.queryStringKey && this.settings.queryStringValue) {
      const urlObject = new URL(urlString);
      urlObject.searchParams.append(this.settings.queryStringKey, this.settings.queryStringValue);
      urlString = urlObject.toString();
    }
    return urlString;
  }
  async compressImage(file) {
    const compressedFile = await imageCompression(file, {
      useWebWorker: false,
      maxWidthOrHeight: this.settings.maxImageWidthOrHeight,
      maxSizeMB: this.settings.maxImageCompressionSize,
      initialQuality: this.settings.imageCompressionQuality
    });
    const fileBuffer = await compressedFile.arrayBuffer();
    const originalSize = filesize(file.size);
    const newSize = filesize(compressedFile.size);
    new import_obsidian.Notice(`Image compressed from ${originalSize} to ${newSize}`);
    return fileBuffer;
  }
  async pasteHandler(ev, editor, directFile) {
    var _a, _b, _c, _d, _e, _f, _g;
    if (ev == null ? void 0 : ev.defaultPrevented) {
      return;
    }
    const noteFile = this.app.workspace.getActiveFile();
    if (!noteFile || !noteFile.name)
      return;
    const fm = (_a = this.app.metadataCache.getFileCache(noteFile)) == null ? void 0 : _a.frontmatter;
    const localUpload = (_b = fm == null ? void 0 : fm.localUpload) != null ? _b : this.settings.localUpload;
    const uploadVideo = (_c = fm == null ? void 0 : fm.uploadVideo) != null ? _c : this.settings.uploadVideo;
    const uploadAudio = (_d = fm == null ? void 0 : fm.uploadAudio) != null ? _d : this.settings.uploadAudio;
    const uploadPdf = (_e = fm == null ? void 0 : fm.uploadPdf) != null ? _e : this.settings.uploadPdf;
    let files = [];
    if (directFile) {
      files = [directFile];
    } else if (ev) {
      switch (ev.type) {
        case "paste":
          files = Array.from(((_f = ev.clipboardData) == null ? void 0 : _f.files) || []);
          break;
        case "drop":
          if (!this.settings.uploadOnDrag && !(fm && fm.uploadOnDrag)) {
            return;
          }
          files = Array.from(((_g = ev.dataTransfer) == null ? void 0 : _g.files) || []);
          break;
        case "input":
          files = Array.from(ev.target.files || []);
          break;
      }
    }
    if (files.length > 0) {
      if (this.shouldIgnoreCurrentFile()) {
        return;
      }
      if (ev)
        ev.preventDefault();
      new import_obsidian.Notice("Uploading files...");
      const cursorPos = editor.getCursor();
      const uploads = files.map(async (file) => {
        var _a2, _b2;
        let thisType = "";
        if (file.type.match(/video.*/) && uploadVideo) {
          thisType = "video";
        } else if (file.type.match(/audio.*/) && uploadAudio) {
          thisType = "audio";
        } else if (file.type.match(/application\/pdf/) && uploadPdf) {
          thisType = "pdf";
        } else if (file.type.match(/image.*/)) {
          thisType = "image";
        } else if (file.type.match(/presentation.*/) || file.type.match(/powerpoint.*/)) {
          thisType = "ppt";
        }
        if (!thisType) {
          return;
        }
        let buf = await file.arrayBuffer();
        const digest = await generateFileHash(new Uint8Array(buf));
        const newFileName = `${digest}.${file.name.split(".").pop()}`;
        let folder = "";
        if (localUpload) {
          folder = (_a2 = fm == null ? void 0 : fm.uploadFolder) != null ? _a2 : this.settings.localUploadFolder;
        } else {
          folder = (_b2 = fm == null ? void 0 : fm.uploadFolder) != null ? _b2 : this.settings.folder;
        }
        const currentDate = new Date();
        folder = folder.replace("${year}", currentDate.getFullYear().toString()).replace("${month}", String(currentDate.getMonth() + 1).padStart(2, "0")).replace("${day}", String(currentDate.getDate()).padStart(2, "0")).replace("${basename}", noteFile.basename.replace(/ /g, "-"));
        const key = folder ? `${folder}/${newFileName}` : newFileName;
        try {
          let url;
          if (thisType === "image" && this.settings.enableImageCompression) {
            buf = await this.compressImage(file);
            file = new File([buf], newFileName, {
              type: file.type
            });
          }
          if (!localUpload) {
            url = await this.uploadFile(file, key);
          } else {
            await this.app.vault.adapter.writeBinary(key, new Uint8Array(buf));
            url = this.app.vault.adapter instanceof import_obsidian.FileSystemAdapter ? this.app.vault.adapter.getFilePath(key) : key;
          }
          return wrapFileDependingOnType(url, thisType, "");
        } catch (error) {
          console.error(error);
          return `Error uploading file: ${error.message}`;
        }
      });
      try {
        const results = await Promise.all(uploads);
        const validResults = results.filter((result) => result !== void 0);
        if (validResults.length > 0) {
          const text = validResults.join("\n");
          editor.transaction({
            changes: [
              {
                from: cursorPos,
                text
              }
            ]
          });
          new import_obsidian.Notice("All files uploaded successfully");
        }
      } catch (error) {
        console.error("Error during upload or insertion:", error);
        new import_obsidian.Notice(`Error: ${error.message}`);
      }
    }
  }
  createS3Client() {
    if (!this.settings.region) {
      return;
    }
    const apiEndpoint = this.settings.useCustomEndpoint ? this.settings.customEndpoint : `https://s3.${this.settings.region}.amazonaws.com/`;
    this.settings.imageUrlPath = this.settings.useCustomImageUrl ? this.settings.customImageUrl : this.settings.forcePathStyle ? apiEndpoint + this.settings.bucket + "/" : apiEndpoint.replace("://", `://${this.settings.bucket}.`);
    if (this.settings.bypassCors) {
      this.s3 = new S3Client({
        region: this.settings.region,
        credentials: {
          accessKeyId: this.settings.accessKey,
          secretAccessKey: this.settings.secretKey
        },
        endpoint: apiEndpoint,
        forcePathStyle: this.settings.forcePathStyle,
        requestHandler: new ObsHttpHandler({ keepAlive: false })
      });
    } else {
      this.s3 = new S3Client({
        region: this.settings.region,
        credentials: {
          accessKeyId: this.settings.accessKey,
          secretAccessKey: this.settings.secretKey
        },
        endpoint: apiEndpoint,
        forcePathStyle: this.settings.forcePathStyle,
        requestHandler: new ObsHttpHandler({ keepAlive: false })
      });
    }
  }
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new S3UploaderSettingTab(this.app, this));
    this.createS3Client();
    this.addCommand({
      id: "upload-image",
      name: "Upload image",
      icon: "image-plus",
      mobileOnly: false,
      editorCallback: (editor) => {
        const input = document.createElement("input");
        input.type = "file";
        input.oninput = (event) => {
          if (!event.target)
            return;
          this.pasteHandler(event, editor);
        };
        input.click();
        input.remove();
      }
    });
    this.pasteFunction = (event, editor) => {
      this.pasteHandler(event, editor);
    };
    this.registerEvent(this.app.workspace.on("editor-paste", this.pasteFunction));
    this.registerEvent(this.app.workspace.on("editor-drop", this.pasteFunction));
    this.registerEvent(this.app.vault.on("create", async (file) => {
      if (this.settings.disableAutoUploadOnCreate)
        return;
      if (!(file instanceof import_obsidian.TFile))
        return;
      if (!file.path.match(/\.(jpg|jpeg|png|gif|webp)$/i))
        return;
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
      if (!activeView)
        return;
      if (this.shouldIgnoreCurrentFile()) {
        return;
      }
      try {
        const fileContent = await this.app.vault.readBinary(file);
        const newFile = new File([fileContent], file.name, {
          type: `image/${file.extension}`
        });
        await this.pasteHandler(null, activeView.editor, newFile);
        await new Promise((resolve) => setTimeout(resolve, 50));
        const content = activeView.editor.getValue();
        const obsidianLink = this.app.vault.getConfig("useMarkdownLinks") ? `![](${file.name.split(" ").join("%20")})` : `![[${file.name}]]`;
        const position = content.indexOf(obsidianLink);
        if (position !== -1) {
          const from = activeView.editor.offsetToPos(position);
          const to = activeView.editor.offsetToPos(position + obsidianLink.length);
          activeView.editor.replaceRange("", from, to);
        } else {
          new import_obsidian.Notice(`Failed to find: ${obsidianLink}`);
        }
        await this.app.vault.delete(file);
      } catch (error) {
        new import_obsidian.Notice(`Error processing file: ${error.message}`);
      }
    }));
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var S3UploaderSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  toggleCompressionSettings(show) {
    if (this.compressionSizeSettings && this.compressionQualitySettings && this.compressionDimensionSettings) {
      const displayStyle = show ? "" : "none";
      this.compressionSizeSettings.settingEl.style.display = displayStyle;
      this.compressionQualitySettings.settingEl.style.display = displayStyle;
      this.compressionDimensionSettings.settingEl.style.display = displayStyle;
    }
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Settings for S3 Image Uploader" });
    containerEl.createEl("br");
    const coffeeDiv = containerEl.createDiv("coffee");
    const coffeeLink = coffeeDiv.createEl("a", {
      href: "https://www.buymeacoffee.com/jvsteiner"
    });
    const coffeeImg = coffeeLink.createEl("img", {
      attr: {
        src: "https://cdn.buymeacoffee.com/buttons/v2/default-blue.png"
      }
    });
    coffeeImg.height = 45;
    containerEl.createEl("br");
    new import_obsidian.Setting(containerEl).setName("AWS Access Key ID").setDesc("AWS access key ID for a user with S3 access.").addText((text) => {
      wrapTextWithPasswordHide(text);
      text.setPlaceholder("access key").setValue(this.plugin.settings.accessKey).onChange(async (value) => {
        this.plugin.settings.accessKey = value.trim();
        this.plugin.createS3Client();
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("AWS Secret Key").setDesc("AWS secret key for that user.").addText((text) => {
      wrapTextWithPasswordHide(text);
      text.setPlaceholder("secret key").setValue(this.plugin.settings.secretKey).onChange(async (value) => {
        this.plugin.settings.secretKey = value.trim();
        this.plugin.createS3Client();
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Region").setDesc("AWS region of the S3 bucket.").addText((text) => text.setPlaceholder("aws region").setValue(this.plugin.settings.region).onChange(async (value) => {
      this.plugin.settings.region = value.trim();
      this.plugin.createS3Client();
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("S3 Bucket").setDesc("S3 bucket name.").addText((text) => text.setPlaceholder("bucket name").setValue(this.plugin.settings.bucket).onChange(async (value) => {
      this.plugin.settings.bucket = value.trim();
      this.plugin.createS3Client();
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Bucket folder").setDesc("Optional folder in s3 bucket. Support the use of ${year}, ${month}, ${day} and ${basename} variables.").addText((text) => text.setPlaceholder("folder").setValue(this.plugin.settings.folder).onChange(async (value) => {
      this.plugin.settings.folder = value.trim();
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Upload on drag").setDesc("Upload drag and drop images as well as pasted images. To override this setting on a per-document basis, you can add `uploadOnDrag: true` to YAML frontmatter of the note.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.uploadOnDrag).onChange(async (value) => {
        this.plugin.settings.uploadOnDrag = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Upload video files").setDesc("Upload videos. To override this setting on a per-document basis, you can add `uploadVideo: true` to YAML frontmatter of the note.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.uploadVideo).onChange(async (value) => {
        this.plugin.settings.uploadVideo = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Upload audio files").setDesc("Upload audio files. To override this setting on a per-document basis, you can add `uploadAudio: true` to YAML frontmatter of the note.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.uploadAudio).onChange(async (value) => {
        this.plugin.settings.uploadAudio = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Upload pdf files").setDesc("Upload and embed PDF files. To override this setting on a per-document basis, you can add `uploadPdf: true` to YAML frontmatter of the note. Local uploads are not supported for PDF files.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.uploadPdf).onChange(async (value) => {
        this.plugin.settings.uploadPdf = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Copy to local folder").setDesc("Copy images to local folder instead of s3. To override this setting on a per-document basis, you can add `localUpload: true` to YAML frontmatter of the note.  This will copy the images to a folder in your local file system, instead of s3.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.localUpload).onChange(async (value) => {
        this.plugin.settings.localUpload = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Local folder").setDesc('Local folder to save images, instead of s3. To override this setting on a per-document basis, you can add `uploadFolder: "myFolder"` to YAML frontmatter of the note.  This affects only local uploads.').addText((text) => text.setPlaceholder("folder").setValue(this.plugin.settings.localUploadFolder).onChange(async (value) => {
      this.plugin.settings.localUploadFolder = value.trim();
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Use custom endpoint").setDesc("Use the custom api endpoint below.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.useCustomEndpoint).onChange(async (value) => {
        this.plugin.settings.useCustomEndpoint = value;
        this.plugin.createS3Client();
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Custom S3 Endpoint").setDesc("Optionally set a custom endpoint for any S3 compatible storage provider.").addText((text) => text.setPlaceholder("https://s3.myhost.com/").setValue(this.plugin.settings.customEndpoint).onChange(async (value) => {
      value = value.match(/^https?:\/\//) ? value : "https://" + value;
      value = value.replace(/([^/])$/, "$1/");
      this.plugin.settings.customEndpoint = value.trim();
      this.plugin.createS3Client();
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("S3 Path Style URLs").setDesc("Advanced option to force using (legacy) path-style s3 URLs (s3.myhost.com/bucket) instead of the modern AWS standard host-style (bucket.s3.myhost.com).").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.forcePathStyle).onChange(async (value) => {
        this.plugin.settings.forcePathStyle = value;
        this.plugin.createS3Client();
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Use custom image URL").setDesc("Use the custom image URL below.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.useCustomImageUrl).onChange(async (value) => {
        this.plugin.settings.useCustomImageUrl = value;
        this.plugin.createS3Client();
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Custom Image URL").setDesc("Advanced option to force inserting custom image URLs. This option is helpful if you are using CDN.").addText((text) => text.setValue(this.plugin.settings.customImageUrl).onChange(async (value) => {
      value = value.match(/^https?:\/\//) ? value : "https://" + value;
      value = value.replace(/([^/])$/, "$1/");
      this.plugin.settings.customImageUrl = value.trim();
      this.plugin.createS3Client();
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Bypass local CORS check").setDesc("Bypass local CORS preflight checks - it might work on later versions of Obsidian.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.bypassCors).onChange(async (value) => {
        this.plugin.settings.bypassCors = value;
        this.plugin.createS3Client();
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Query String Key").setDesc("Appended to the end of the URL. Optional").addText((text) => text.setPlaceholder("Empty means no query string key").setValue(this.plugin.settings.queryStringKey).onChange(async (value) => {
      this.plugin.settings.queryStringKey = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Query String Value").setDesc("Appended to the end of the URL. Optional").addText((text) => text.setPlaceholder("Empty means no query string value").setValue(this.plugin.settings.queryStringValue).onChange(async (value) => {
      this.plugin.settings.queryStringValue = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Enable Image Compression").setDesc("This will reduce the size of images before uploading.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.enableImageCompression).onChange(async (value) => {
        this.plugin.settings.enableImageCompression = value;
        await this.plugin.saveSettings();
        this.toggleCompressionSettings(value);
      });
    });
    this.compressionSizeSettings = new import_obsidian.Setting(containerEl).setName("Max Image Size").setDesc("Maximum size of the image after compression in MB. Default is 1MB.").addText((text) => text.setPlaceholder("1").setValue(this.plugin.settings.maxImageCompressionSize.toString()).onChange(async (value) => {
      const newValue = parseFloat(value);
      if (isNaN(newValue) || newValue <= 0) {
        new import_obsidian.Notice("Max Image Compression Size must be a number greater than 0");
        return;
      }
      this.plugin.settings.maxImageCompressionSize = newValue;
      await this.plugin.saveSettings();
    }));
    this.compressionQualitySettings = new import_obsidian.Setting(containerEl).setName("Image Compression Quality").setDesc("Maximum quality of the image after compression. Default is 0.7.").addSlider((slider) => {
      slider.setDynamicTooltip();
      slider.setLimits(0, 1, 0.05);
      slider.setValue(this.plugin.settings.imageCompressionQuality);
      slider.onChange(async (value) => {
        this.plugin.settings.imageCompressionQuality = value;
        await this.plugin.saveSettings();
      });
    });
    this.compressionDimensionSettings = new import_obsidian.Setting(containerEl).setName("Max Image Width or Height").setDesc("Maximum width or height of the image after compression. Default is 4096px.").addText((text) => text.setPlaceholder("4096").setValue(this.plugin.settings.maxImageWidthOrHeight.toString()).onChange(async (value) => {
      const parsedValue = parseInt(value);
      if (isNaN(parsedValue) || parsedValue <= 0) {
        new import_obsidian.Notice("Max Image Width or Height must be a number greater than 0");
        return;
      }
      this.plugin.settings.maxImageWidthOrHeight = parsedValue;
      await this.plugin.saveSettings();
    }));
    this.toggleCompressionSettings(this.plugin.settings.enableImageCompression);
    new import_obsidian.Setting(containerEl).setName("Disable auto-upload on file create").setDesc("Disable automatic upload when image files are created in the vault (e.g., via sync or external processes). Paste and drag-drop uploads will still work. Enable this if you experience unwanted uploads on startup or when using cloud sync.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.disableAutoUploadOnCreate).onChange(async (value) => {
        this.plugin.settings.disableAutoUploadOnCreate = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Ignore Pattern").setDesc("Glob pattern to ignore files/folders. Use * for any characters, ** for any path, ? for single character. Separate multiple patterns with commas. Example: 'private/*, **/drafts/**, temp*'").addText((text) => text.setPlaceholder("private/*, **/drafts/**").setValue(this.plugin.settings.ignorePattern).onChange(async (value) => {
      this.plugin.settings.ignorePattern = value.trim();
      await this.plugin.saveSettings();
    }));
  }
};
var wrapTextWithPasswordHide = (text) => {
  const hider = text.inputEl.insertAdjacentElement("beforebegin", createSpan());
  if (!hider) {
    return;
  }
  (0, import_obsidian.setIcon)(hider, "eye-off");
  hider.addEventListener("click", () => {
    const isText = text.inputEl.getAttribute("type") === "text";
    if (isText) {
      (0, import_obsidian.setIcon)(hider, "eye-off");
      text.inputEl.setAttribute("type", "password");
    } else {
      (0, import_obsidian.setIcon)(hider, "eye");
      text.inputEl.setAttribute("type", "text");
    }
    text.inputEl.focus();
  });
  text.inputEl.setAttribute("type", "password");
  return text;
};
var wrapFileDependingOnType = (location, type, localBase) => {
  const srcPrefix = localBase ? "file://" + localBase + "/" : "";
  if (type === "image") {
    return `![image](${location})`;
  } else if (type === "video") {
    return `<video src="${srcPrefix}${location}" controls />`;
  } else if (type === "audio") {
    return `<audio src="${srcPrefix}${location}" controls />`;
  } else if (type === "pdf") {
    if (localBase) {
      throw new Error("PDFs cannot be embedded in local mode");
    }
    return `<iframe frameborder=0 border=0 width=100% height=800
		src="https://docs.google.com/viewer?embedded=true&url=${location}?raw=true">
		</iframe>`;
  } else if (type === "ppt") {
    return `<iframe
	    src='https://view.officeapps.live.com/op/embed.aspx?src=${location}'
	    width='100%' height='600px' frameborder='0'>
	  </iframe>`;
  } else {
    throw new Error("Unknown file type");
  }
};
var ObsHttpHandler = class extends FetchHttpHandler {
  constructor(options) {
    super(options);
    this.requestTimeoutInMs = options === void 0 ? void 0 : options.requestTimeout;
  }
  async handle(request, { abortSignal } = {}) {
    if (abortSignal == null ? void 0 : abortSignal.aborted) {
      const abortError = new Error("Request aborted");
      abortError.name = "AbortError";
      return Promise.reject(abortError);
    }
    let path2 = request.path;
    if (request.query) {
      const queryString = buildQueryString(request.query);
      if (queryString) {
        path2 += `?${queryString}`;
      }
    }
    const { port, method } = request;
    const url = `${request.protocol}//${request.hostname}${port ? `:${port}` : ""}${path2}`;
    const body = method === "GET" || method === "HEAD" ? void 0 : request.body;
    const transformedHeaders = {};
    for (const key of Object.keys(request.headers)) {
      const keyLower = key.toLowerCase();
      if (keyLower === "host" || keyLower === "content-length") {
        continue;
      }
      transformedHeaders[keyLower] = request.headers[key];
    }
    let contentType = void 0;
    if (transformedHeaders["content-type"] !== void 0) {
      contentType = transformedHeaders["content-type"];
    }
    let transformedBody = body;
    if (ArrayBuffer.isView(body)) {
      transformedBody = bufferToArrayBuffer(body);
    }
    const param = {
      body: transformedBody,
      headers: transformedHeaders,
      method,
      url,
      contentType
    };
    const raceOfPromises = [
      (0, import_obsidian.requestUrl)(param).then((rsp) => {
        const headers = rsp.headers;
        const headersLower = {};
        for (const key of Object.keys(headers)) {
          headersLower[key.toLowerCase()] = headers[key];
        }
        const stream = new ReadableStream({
          start(controller) {
            controller.enqueue(new Uint8Array(rsp.arrayBuffer));
            controller.close();
          }
        });
        return {
          response: new HttpResponse({
            headers: headersLower,
            statusCode: rsp.status,
            body: stream
          })
        };
      }),
      requestTimeout(this.requestTimeoutInMs)
    ];
    if (abortSignal) {
      raceOfPromises.push(new Promise((resolve, reject) => {
        abortSignal.onabort = () => {
          const abortError = new Error("Request aborted");
          abortError.name = "AbortError";
          reject(abortError);
        };
      }));
    }
    return Promise.race(raceOfPromises);
  }
};
var bufferToArrayBuffer = (b2) => {
  return b2.buffer.slice(b2.byteOffset, b2.byteOffset + b2.byteLength);
};
async function generateFileHash(data) {
  const hashBuffer = await crypto.subtle.digest("SHA-256", data);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  const hashHex = hashArray.map((b2) => b2.toString(16).padStart(2, "0")).join("");
  return hashHex.slice(0, 32);
}
function matchesGlobPattern(filePath, pattern) {
  if (!pattern || pattern.trim() === "") {
    return false;
  }
  const patterns = pattern.split(",").map((p2) => p2.trim());
  return patterns.some((p2) => {
    return minimatch(filePath, p2);
  });
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/**
 * filesize
 *
 * @copyright 2024 Jason Mulligan <jason.mulligan@avoidwork.com>
 * @license BSD-3-Clause
 * @version 10.1.6
 */

/* nosourcemap */